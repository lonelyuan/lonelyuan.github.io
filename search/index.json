[{"content":"这个《伊万·弗拉特里克的安全博客》啊，确实是个好博客。这篇《所以你想做安保工作?》啊，确实是篇好文章。那么我一个新世纪理工科战士，怎么开始写读后感了呢？老板的任务罢了。\n伊万老哥是谷歌的安全研究员，代表作有winafl等。能上大厂当研究员，已经是我对职业生涯的理想了。文章说，对大部分人来说，安全首先是一个爱好然后才是工作。诚然，没有纯粹的爱好是无法提供长时间坐冷板凳的自驱力的。但或许大部分人并没有对某一件事的狂热爱好，在褪去光鲜外表后，大部分人都是三分钟热度。人们常说“兴趣大于天赋”，或许浓厚的兴趣本身就是一种稀有的天赋。\n Don’t look now but getting started is more difficult now than it was 10 years ago\n 安全研究的入门难度比十年前更高。而本文发布于2018年，那时我正值高考，国内CTF形势方兴未艾，现在网络上随处可见的入门知识，都是当时的热门考点。文章说CTF是很好的入门方式，可以减缓学习曲线的陡峭程度。而现在，又过去了半个十年，我也紧赶慢赶步入研究生阶段。这个结论能否适用于当下的入门者，恐怕难以下定论。（仅限于中国大陆）（只是因为作者没有去过其他国家，没有说中国大陆不好的意思）。\n当然我也不是输出负能量，面对越来越卷的市场，面对全球经济发展下行的环境，面对没有原始资本的自己，唯一能做的就是尽可能学习免费的知识和技能，静观其变。作者最后说，搞安全需要长时间坐电脑，并且\u0026quot;quite intellectually challenging\u0026quot;，经常\u0026quot;mentally exhausting\u0026quot;。此言诚然，要做好长时间得不到回报的觉悟，寻找和培养正反馈；同时也要加强锻炼，身体健康和精神健康两手抓。\n","date":"2023-07-07T20:29:12+08:00","permalink":"https://lonelyuan.github.io/p/%E6%89%80%E4%BB%A5%E4%BD%A0%E6%83%B3%E5%81%9A%E5%AE%89%E4%BF%9D%E5%B7%A5%E4%BD%9C%E8%AF%BB%E5%90%8E%E6%84%9F/","title":"《所以你想做安保工作?》读后感"},{"content":"你们 CLI 确实比 GUI 有点素质 要论计算机人的典中典，还得是n年不更新只有寥寥几篇文章的 Hexo 博客。它代表着命令行初学者的兴奋，第一次配 node 环境成功后的喜悦，以及一个月之后的疑问：\n 这点屁事我为什么不发秋秋空间/微博？ 只有我看我为什么不记 Onenote/Notion ？ 想要流量我为什么不发知乎/简书/掘金/西埃斯弟恩……？  尽管从现在看仿佛是前朝遗老，个人博客依旧是不存在于中文互联网中的极少数高质量中文内容。它代表着 RSS ，代表着永远不用担心跑路和审查，是 geek 们的精神自留地。\n但是👴还是觉得发一篇博客敲好几条命令麻烦的要死。大概是👴不再年轻了，👴开始追求简单安逸，像挨了锤的牛一样。于是👴最终选用 Gridea ，一个博客客户端，可一键推送到 Github Page。这玩意有些不太趁手的地方，等👴闲来无事的时候搞一搞二次开发……\n然而，👴还没等到闲来无事的时候，发觉Gridea作者弃坑了。。。其客户端（electron害人不浅）编辑体验差，git更新老出毛病。作者现在只更新web端，托管到他的云服务下面。👴还是更相信github不会跑路，所以👴还是赶紧跑路吧。于是：\n 你们 Js 确实比 Go 有点素质 于是👴最终选用 Hugo 做博客，因为与 Hexo 相比 Hugo 的运行速度和空间占用都十分轻量。最重要的是，作为 Go 开发的项目，可以直接下载可执行文件，不需要恼人的配环境环节。👴看中了 Stack 主题，但是这个主题用的人不少，有些千篇一律的尴尬。为此👴决定深耕换皮之道……\n 以下内容适合已了解 Hugo 基本使用之后的进一步学习。\n Hugo 框架结构 1 2 3 4 5 6 7 8 9  ├── archetypes # .md 模板 │ └── default.md ├── config.toml # 配置文件 ├── content # 在这写东西 ├── data # 更多配置文件 ├── layouts # .html 模板 ├── public # 渲染好的网站 ├── static # 静态文件，hugo会全部复制 └── themes # 博客主题   content 这里是 Hugo 的输入，存放.md格式的文章。使用hugo new命令时，会尝试从archetypes目录寻找对应的模板，模板通常仅包含front matter，定义了文章的元属性。语法如下：\nhugo new \u0026lt;SECTIONNAME\u0026gt;/\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\ncontent中的子文件夹称为 sections ，它们是网站内容的基本分块。分块的目的是分配不同的处理方式，如post需要展示文章列表，page仅展示单独页面等。配置中的permalinks项就是以分块为单位分配URL。\npublic 这里是 Hugo 的输出，存放完整的 HTML 静态网页。使用hugo命令时，会尝试从layouts目录寻找对应的模板， HTML 模板均以 GO 模板语法编写。在写文章时也可使用模板来避免写 HTML 的繁杂，如 Hugo 提供的各种 shortcode 。\n以 Github Page 为例，部署时仅需将这个文件夹同步至 github.io 仓库即可。\n主题调教 如何优雅的二次开发？观察theme的内容，会发现除了没有content目录之外和网站根目录结构完全一致。由此我们猜测，所谓theme也是一个 site，使用theme就是用其模板覆盖我们的网站。\n那么，能否直接修改theme目录里的内容？自然可行，但如果需要升级主题，则会产生许多讨厌的merge问题。如何实现数据和配置的解耦？实际上，上述关于覆盖顺序的猜想并不准确，实际顺序是：本地模板→主题模板→默认模板。故而，在本地模板中添加相同路径下的同名模板文件，即可覆盖掉主题模板的配置。\n以 Stack 主题为例，其在许多位置都存在着诸如hugo-theme-stack\\assets\\scss\\custom.scss的空白文件，只需要在根目录新建\\assets\\scss\\custom.scss即可添加对 CSS 的改动。\n一般来说，仿照主题提供的demo网站即可满足一般的二次开发需求。关于模板查找顺序还有诸多细节，请参阅官方文档：Template lookup order。\n【To be continued】\n 主题配色，字体 词云——js引入  你这静态网站不是很静态啊  评论系统 Google Analysis 收集 访问量 Github Action 收集 lastmodify   【To be continued，如果这句话还在说明作者最近不是闲来无事，这很合理】\n","date":"2021-11-07T14:19:11Z","permalink":"https://lonelyuan.github.io/p/%E9%97%B2%E6%9D%A5%E6%97%A0%E4%BA%8B%E5%80%92%E8%85%BE%E5%8D%9A%E5%AE%A2/","title":"闲来无事，倒腾博客"},{"content":"由于👴觉得👴学校的操作系统讲了个🔨，慕名而来学习上交的 MOSPI 课程。银杏书看完之后👴发现👴学校的OS确实讲了个🔨。我直接当场来一段圣经吟唱：\n那个额西电操作系统嗷，不会写教材可以不写，害特么在弄你那个管程，来我教你啊，看好了啊。首先 M.A.L.H. 原则，看懂了吗，然后开讲虚拟内存，哎我就不虚拟，我就讲那个空闲链表。哎，再扎个多线程，看到没，线程上下文切换了。我特么直接三段系统调度（短期，中期，长期），然后我直接~就一个多核调度，我就调度到IPC，进程现在已经可以通信了啊！别怪我没有教好你，进程通信了之后干什么，憋特么讲你那破几把处理机了。看好啊，讲出锁（嬉皮笑脸），讲出信号量直接就扔到互斥资源身上，就疯狂的进入他的临界区。然后我再一个，文件系统！加三段系统虚拟化（CPU虚拟化、内存虚拟化、IO虚拟化），全部吃满，完成强杀，你唛璧你懂个der，讲寄吧OS，我爱你。\n圣经原文：拖更云的鹰佐教学\n  本系列为 ChCore lab 实验报告。 Lab源码：https://gitee.com/ipads-lab/chcore-lab MOSPI在线网站：https://ipads.se.sjtu.edu.cn/mospi/\n 实验环境 需要docker和qemu，docker不赘述。linux下安装qemu： sudo apt-get install qemu-system-arm 安装完成之后查看版本号：\n1 2 3  $ qemu-system-aarch64 --version QEMU emulator version 4.2.0 Copyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers   5个实验在源码仓库分别以5个分支存在。 git clone -b即可。\n内核构建和调试：\n 用docker交叉编译内核：make build 启动qemu：make qemu  这里遇到报错： Unable to init server: Could not connect: Connection refused gtk initialization failed 解决方法：修改 Makefile ，在QEMUOPTS参数后加-nographic   启动qemu：make qemu-gdb  将监听1234端口以供gdb远程调用 退出：ctrl+a，然后按x。 如果意外退出，要杀死进程：kill $(ps -ef | grep qemu | grep 1234 | awk '{print $2}')   在另一个终端启动gdb调试：make gdb  这里可能需要安装gdb-multiarch：sudo apt-get install gdb-multiarch    可以看到，本项目中 Makefile 主要是封装了一些命令。\n Lab1 练习3-加载入口定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  root@lastyear:~/chcore-lab# readelf -S build/kernel.img There are 9 section headers, starting at offset 0x20cd8: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] init PROGBITS 0000000000080000 00010000 000000000000b5b0 0000000000000008 WAX 0 0 4096 [ 2] .text PROGBITS ffffff000008c000 0001c000 00000000000011dc 0000000000000000 AX 0 0 8 [ 3] .rodata PROGBITS ffffff0000090000 00020000 00000000000000f8 0000000000000001 AMS 0 0 8 [ 4] .bss NOBITS ffffff0000090100 000200f8 0000000000008000 0000000000000000 WA 0 0 16 [ 5] .comment PROGBITS 0000000000000000 000200f8 0000000000000032 0000000000000001 MS 0 0 1 [ 6] .symtab SYMTAB 0000000000000000 00020130 0000000000000858 0000000000000018 7 46 8 [ 7] .strtab STRTAB 0000000000000000 00020988 000000000000030f 0000000000000000 0 0 1 [ 8] .shstrtab STRTAB 0000000000000000 00020c97 000000000000003c 0000000000000000 0 0 1   看到init段的起始地址是0x80000，和readelf -h中的 Entry point address 一致，也和 GDB 刚进入时where的输出一致。\n1 2 3  0x0000000000080000 in ?? () (gdb) where #0 0x0000000000080000 in _start ()   下面寻找_start的定义，在CMakeLists.txt中找到_start，\n1 2 3 4 5 6 7  set_property( TARGET kernel.img APPEND_STRING PROPERTY LINK_FLAGS \u0026#34;-T ${CMAKE_CURRENT_BINARY_DIR}/${link_script}-e _start\u0026#34; )   这里为kernel.img指定了链接器脚本(-T)和入口函数(-e)。\n于是跟随link_script：\n1 2  set(link_script \u0026#34;linker.lds\u0026#34;) configure_file(\u0026#34;./scripts/linker-aarch64.lds.in\u0026#34; \u0026#34;linker.lds.S\u0026#34;)   进入脚本linker-aarch64.lds.in：\n1 2 3 4 5 6 7 8 9 10  #include \u0026#34;../boot/image.h\u0026#34; SECTIONS { . = TEXT_OFFSET; img_start = .; init : { ${init_object} } // ...   其中init段指定了加载init_object，它表示bootloader的所有目标文件集合。其定义回到CmakeLists.txt：\n1 2 3 4 5 6 7  set(init_object \u0026#34;${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/start.S.o ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/mmu.c.o ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/tools.S.o ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/init_c.c.o ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/uart.c.o\u0026#34; )   可发现/boot/start.S定义了_start。\n下面继续寻找地址，在链接器脚本引用了image.h，其中有TEXT_OFFSET的定义：\n1 2 3 4 5 6 7  #pragma once  #define SZ_16K 0x4000 #define SZ_64K 0x10000  #define KERNEL_VADDR 0xffffff0000000000 #define TEXT_OFFSET 0x80000   一切终于串起来了：\n CMakeLists.txt：是CMake的脚本文件。 CMake 是跨平台的C/C++建构工具。  作用：  指定源文件集合init_object 定义链接器脚本link_script 指定入口函数_start并指定链接器脚本 最终生成kernel.img   //最近看到的挺好的CMake教程：https://www.bilibili.com/video/BV1rR4y1E7n9   linker-aarch64.lds.in：lds是链接器脚本文件，负责控制输出的ELF文件的细节。  作用：指定了起始地址0x80000    练习3-多处理器挂起 start.S中注释的很明白了，通过检查mpidr_el1寄存器来判断 cpuid ，如果不是0则进入死循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  BEGIN_FUNC(_start) mrs x8, mpidr_el1 and x8, x8, #0xFF cbz x8, primary /* hang all secondary processors before we intorduce multi-processors */ secondary_hang: bl secondary_hang primary: /* Turn to el1 from other exception levels. */ bl arm64_elX_to_el1 /* Prepare stack pointer and jump to C. */ adr x0, boot_cpu_stack add x0, x0, #0x1000 mov sp, x0 bl init_c /* Should never be here */ b . END_FUNC(_start)   练习4-LMA和VMA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  root@lastyear:~/chcore-lab# objdump -h build/kernel.img build/kernel.img: file format elf64-little Sections: Idx Name Size VMA LMA File off Algn 0 init 0000b5b0 0000000000080000 0000000000080000 00010000 2**12 CONTENTS, ALLOC, LOAD, CODE 1 .text 000011dc ffffff000008c000 000000000008c000 0001c000 2**3 CONTENTS, ALLOC, LOAD, READONLY, CODE 2 .rodata 000000f8 ffffff0000090000 0000000000090000 00020000 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 3 .bss 00008000 ffffff0000090100 0000000000090100 000200f8 2**4 ALLOC 4 .comment 00000032 0000000000000000 0000000000000000 000200f8 2**0 CONTENTS, READONLY   可以发现只有init段的VMA和LMA相同。其赋值还是回到lds脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  SECTIONS { . = TEXT_OFFSET; img_start = .; init : { //init段VMA==VMA  ${init_object} } . = ALIGN(SZ_16K); // 对齐16k  init_end = ABSOLUTE(.); // init段结束  // KERNEL_VADDR在image.h定义为0xffffff0000000000  .text KERNEL_VADDR + init_end : AT(init_end) { // AT指定LMA  *(.text*) } // .text段：VMA = KERNEL_VADDR + init_end; LMA = init_end  // 后面的段，全部按顺序对齐并递增，此时VMA和LMA已经不同，故后面的段也全都不同  . = ALIGN(SZ_64K); .data : { *(.data*) } . = ALIGN(SZ_64K); .rodata : { *(.rodata*) } _edata = . - KERNEL_VADDR; // 这些外部变量指的是LMA，则减去虚拟地址头  _bss_start = . - KERNEL_VADDR; .bss : { *(.bss*) } _bss_end = . - KERNEL_VADDR; . = ALIGN(SZ_64K); img_end = . - KERNEL_VADDR; }   回答问题：\n  为什么LMA和VMA不同\n VMA是对应虚拟内存的地址，但在内核启动时还处于物理地址模式，VMA可能超出物理内存范围。所以只能先加载，再映射到虚拟地址。 为什么内核段的VMA要映射到高位，应该是一种惯例。 为什么bootloader不用VMA，因为他负责初始化页表，他不能用，也没有必要。    LMA到VMA在何时转换\n 由上一问可知，页表初始化之后便可转换为VMA。    练习5-c语言进制转换 从后往前取余即可。\n练习6-函数栈 start.S中赋值了sp：\n1 2 3 4  /* Prepare stack pointer and jump to C. */ adr x0, boot_cpu_stack add x0, x0, #0x1000 mov sp, x0 /* sp = boot_cpu_stack + 0x1000 */   boot_cpu_stack在init.c\n1 2  #define INIT_STACK_SIZE 0x1000 char boot_cpu_stack[PLAT_CPU_NUMBER][INIT_STACK_SIZE] ALIGN(16);   由于PLAT_CPU_NUMBER被定义为4，故boot_cpu_stack大小为4*4096，可供四个CPU使用。sp初始化后指向第一个4069，也就是第一个cpu内核栈的最高位。初始化时，fp=sp。\n但这是bootloader的栈。后续进入内核后，会重新分配内核栈，参见head.S：\n1 2 3 4 5 6 7 8  BEGIN_FUNC(start_kernel) mov x3, #0 msr TPIDR_EL1, x3 ldr x2, =kernel_stack add x2, x2, KERNEL_STACK_SIZE mov sp, x2 bl main END_FUNC(start_kernel)   于是内核栈的定义在start_kernel函数。\n有关内核栈的位置，因为kernel_stack是全局数组，且未初始化，因而位于.bss。同时没有其他未初始化变量，因此首地址在.bss + KERNEL_STACK_SIZE。\n通过readelf得到.bss的VMA为0xffffff0000090100，KERNEL_STACK_SIZE为0x2000，进入gdb调试可以验证\n1 2  gef➤ x/g $sp 0xffffff0000092100 \u0026lt;kernel_stack+8192\u0026gt;: 0x0   练习7-调用惯例 先看stack_test函数。这里gdb安装了gef插件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  gef➤ b stack_test Breakpoint 1 at 0xffffff000008c020 gef➤ disas Dump of assembler code for function stack_test: =\u0026gt; 0xffffff000008c020 \u0026lt;+0\u0026gt;: stp x29, x30, [sp, #-32]! /* FP、LR 入栈 */ 0xffffff000008c024 \u0026lt;+4\u0026gt;: mov x29, sp 0xffffff000008c028 \u0026lt;+8\u0026gt;: str x19, [sp, #16] /* x 入栈 */ 0xffffff000008c02c \u0026lt;+12\u0026gt;: mov x19, x0 0xffffff000008c030 \u0026lt;+16\u0026gt;: mov x1, x0 0xffffff000008c034 \u0026lt;+20\u0026gt;: adrp x0, 0xffffff0000090000 # 计算偏移 0xffffff000008c038 \u0026lt;+24\u0026gt;: add x0, x0, #0x0 0xffffff000008c03c \u0026lt;+28\u0026gt;: bl 0xffffff000008c620 \u0026lt;printk\u0026gt; 0xffffff000008c040 \u0026lt;+32\u0026gt;: cmp x19, #0x0 0xffffff000008c044 \u0026lt;+36\u0026gt;: b.gt 0xffffff000008c068 \u0026lt;stack_test+72\u0026gt; # greater than /* 递归 */ 0xffffff000008c048 \u0026lt;+40\u0026gt;: bl 0xffffff000008c0dc \u0026lt;stack_backtrace\u0026gt; 0xffffff000008c04c \u0026lt;+44\u0026gt;: mov x1, x19 0xffffff000008c050 \u0026lt;+48\u0026gt;: adrp x0, 0xffffff0000090000 0xffffff000008c054 \u0026lt;+52\u0026gt;: add x0, x0, #0x20 0xffffff000008c058 \u0026lt;+56\u0026gt;: bl 0xffffff000008c620 \u0026lt;printk\u0026gt; 0xffffff000008c05c \u0026lt;+60\u0026gt;: ldr x19, [sp, #16] # x19 = sp + 16 /* x 出栈 */ 0xffffff000008c060 \u0026lt;+64\u0026gt;: ldp x29, x30, [sp], #32 # load pair /* FP、LR 出栈 */ 0xffffff000008c064 \u0026lt;+68\u0026gt;: ret 0xffffff000008c068 \u0026lt;+72\u0026gt;: sub x0, x19, #0x1 0xffffff000008c06c \u0026lt;+76\u0026gt;: bl 0xffffff000008c020 \u0026lt;stack_test\u0026gt; 0xffffff000008c070 \u0026lt;+80\u0026gt;: mov x1, x19 0xffffff000008c074 \u0026lt;+84\u0026gt;: adrp x0, 0xffffff0000090000 0xffffff000008c078 \u0026lt;+88\u0026gt;: add x0, x0, #0x20 0xffffff000008c07c \u0026lt;+92\u0026gt;: bl 0xffffff000008c620 \u0026lt;printk\u0026gt; 0xffffff000008c080 \u0026lt;+96\u0026gt;: ldr x19, [sp, #16] 0xffffff000008c084 \u0026lt;+100\u0026gt;: ldp x29, x30, [sp], #32 0xffffff000008c088 \u0026lt;+104\u0026gt;: ret End of assembler dump.   运行，观察栈的变化，这里省略部分输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  gef➤ c ───────────────────────────────────────── registers ──── $x0 : 0x0000000000000005 # 这一层函数的输入值 $x19 : 0x0000000000000000 # 上一层函数的返回值 $x29 : 0xffffff00000920f0 # FP $x30 : 0xffffff000008c0d4 → \u0026lt;main+72\u0026gt; # LR $sp : 0xffffff00000920f0 ───────────────────────────────────────────── stack ──── 0xffffff00000920f0│+0x0000: 0x0000000000000000 0xffffff00000920f8│+0x0008: 0xffffff000008c018 # 栈头，可能是栈初始化的数据结构 ──────────────────────────────────────────── trace ──── [#0] 0xffffff000008c020 → stack_test() [#1] 0xffffff000008c0d4 → main() ─────────────────────────────────────────────────────── gef➤ c ───────────────────────────────────────── registers ──── $x0 : 0x0000000000000004 $x19 : 0x0000000000000005 $x29 : 0xffffff00000920d0 $x30 : 0xffffff000008c070 #→ \u0026lt;stack_test+80\u0026gt; $sp : 0xffffff00000920d0 → 0xffffff00000920f0 ───────────────────────────────────────────── stack ──── 0xffffff00000920d0│+0x0000: 0xffffff00000920f0 ─┐ # FP 0xffffff00000920d8│+0x0008: 0xffffff000008c0d4 │ # LR 0xffffff00000920e0│+0x0010: 0x0000000000000000 │ 0xffffff00000920e8│+0x0018: 0x00000000ffffffc0 │ 0xffffff00000920f0│+0x0020: 0x0000000000000000 ◄┘ 0xffffff00000920f8│+0x0028: 0xffffff000008c018 ───────────────────────────────────────────── trace ──── [#0] 0xffffff000008c020 → stack_test() [#1] 0xffffff000008c070 → stack_test() [#2] 0xffffff000008c0d4 → main() ──────────────────────────────────────────────────────── gef➤ c ───────────────────────────────────────── registers ──── $x0 : 0x0000000000000003 $x19 : 0x0000000000000004 $x29 : 0xffffff00000920b0 → 0xffffff00000920d0 → 0xffffff00000920f0 $x30 : 0xffffff000008c070 $sp : 0xffffff00000920b0 → 0xffffff00000920d0 → 0xffffff00000920f0 ──────────────────────────────────────────── stack ──── 0xffffff00000920b0│+0x0000: 0xffffff00000920d0 ─┐ # [#1] 0xffffff00000920b8│+0x0008: 0xffffff000008c070 │ 0xffffff00000920c0│+0x0010: 0x0000000000000005 │ 0xffffff00000920c8│+0x0018: 0x00000000ffffffc0 │ 0xffffff00000920d0│+0x0020: 0xffffff00000920f0 ◄┘ # [#2] 0xffffff00000920d8│+0x0028: 0xffffff000008c0d4 │ 0xffffff00000920e0│+0x0010: 0x0000000000000000 │ 0xffffff00000920e8│+0x0018: 0x00000000ffffffc0 │ 0xffffff00000920f0│+0x0020: 0x0000000000000000 ◄┘ # [#3] 0xffffff00000920f8│+0x0028: 0xffffff000008c018 ─────────────────────────────────────────── trace ──── [#0] 0xffffff000008c020 → stack_test() [#1] 0xffffff000008c070 → stack_test() [#2] 0xffffff000008c070 → stack_test() [#3] 0xffffff000008c0d4 → main() ──────────────────────────────────────────────────────   可以看到每次递归调用压栈4个64位字，分别是：上一层FP，LR，参数x和0x00000000ffffffc0。最后一个64位字用途未知。\n练习9-backtrace 提供read_fp()接口，我们知道fp永远指向父函数的fp，故递归调用即可。\n1 2 3 4 5  u64* fp = (u64*) *((u64*)read_fp()); // 双层指针，因为第一层是本函数 \twhile(fp != 0) { printk(\u0026#34;LR %lx FP %lx Args %d %d %d %d %d\\n\u0026#34;, *(fp + 1), fp, *(fp - 2), *(fp - 1), *(fp), *(fp + 1), *(fp + 2)); //为什么5个参数是fp-2到fp+2？样例只包括一个参数，只要出现fp+2就能测试通过  fp = (u64*) *fp; //下一层 \t}   满分通过，懒得贴图了。\n 看到大佬写的，瞬间不想写了，寄。 https://www.cnblogs.com/kangyupl/p/chcore_lab1.html\n","date":"2021-10-29T17:03:14Z","permalink":"https://lonelyuan.github.io/p/mospi-chcore-lab-1/","title":"MOSPI-ChCore lab (1)"},{"content":"众所周知，计网被评为最困的计算机专业课，俗称计算机中的语文。👴看了《计算机网络－自顶向下方法》（后文简称CNTDA）之后，觉得翻译就像汤姆叔叔的烂苹果派一样糟糕，上帝啊，我发誓会狠狠踢他的屁股。建议带🔥去看英文原版。\n但是👴最近接触的许多实验还是很好玩的，于是本文试图通过全程动手实操学习计网。\n 主要工具：\n wireshark是坠nb的网络封包分析软件。就是用来抓包的。   下载：https://www.wireshark.org/download.html 教程：https://www.javatpoint.com/wireshark\n  scapy库是python的网络编程库，可以让你细致入微的操纵网络流量。就是用来发包的。  //不要和爬虫库scrapy混淆     scapy文档：https://scapy.readthedocs.io/en/latest/ 中文版：https://www.osgeo.cn/scapy/introduction.html //有些翻译错误\n  计网基本概念 💣包(package) 等等，啥是“抓包”？啥是“发包”？啥是“包”？\n当然，包不仅仅是一个 CSGO 术语，在计算机网络中，包(package)有多个近义词，包括：报文/数据报(Datagram)，分组/封包(Packet)……根据语境不同而区分，但大致指的是同一件事情：即网络中真正流动着的东西，我们希望网络来传递的东西。只不过“包”是最通俗的叫法，那么抓包和发包就不难理解了。\n你还想问，包到底长什么样？众所周知，快递由包装和里面的东西组成，其实网络上的封包也差不多，也大致都有两部分：\n 包头，学名首部(Header)——快递包装上的标签，写着目的地址，联系电话，快递号等信息 包体，学名载荷(Payload)——快递要运输的货物本身。某些语境下也喜欢称为报文。  当然，网络封包归根结底还是线性的比特序列，于是我们需要包头来识别这个封包的相关信息，就像看快递先看标签一样。\n另外，一个协议的封包也可以成为另一个协议的载荷，后面你会看到诸如pkt.payload.payload.payload.payload的套娃用法，要理解这种套娃，还需要知道分层思想。\n🍰分层(layering) CNTDA 中用邮政系统类比计算机网络，这是最常用的例子，这里我们用快递物流网来举例。随便打开你的网购记录，你会发现快递物流大概经过以下过程：\n  客户发货：把货物和地址交给快递点  快递网点揽件：包装货物而变成包裹；包裹被送往最近的中转中心  中转中心运输：根据包裹目的地不同，分拣并装车运输给不同的中转中心；若收到本片区的包裹，卸车并分拣给不同的网点   快递网点派送：按包裹的地址，快递员送货上门   客户取件：拆箱，拿到货物，确认无误签收   你知道发一个快递要经历怎样的困难吗？你不知道，你只关心你自己。这里的重点是，客户不需要关心中转中心如何指挥重型货车或飞机，网点也只需要关心如何包装好客户的货物。快递网络明显的呈现出三层的分层架构，每一层之间只需要关心自己的工作，并和相邻的层交互。这就是应对复杂系统的组织方法——分层。\n课本上会提到OSI七层模型或者TCP/IP五层模型，这里的模型全称是协议分层模型，又来新词了，别急，后面还有：\n 协议(Protocol)：同一层级内的交互规则。//横向 服务(Service)：不同层级间的交互规则。//纵向  每一层的工作，就是调用下层的接口，并为上层提供服务。接口(Interface)和服务的区别是，服务作为实体，由本层负责实现，暴露出接口供上层调用；而接口则是抽象的，本层并不知道下一层的可靠性。\n由此你能否看出分层思想的优越性？每一层只关注自己的实现，于是大问题被分解成了小问题。好比一个总工作量100的问题，不了解分层思想的你只能10+10+10+……=100；而分层思想提供了乘法法则，于是你可以通过10*10=100，只需要完成20工作量。//个中思想也体现了OOP中的解耦。\n上述类比中标注了一些对应关系：\n 封包(Packaging)：包装，货物→包裹。信息在层次间传递的过程就是封包/解封的过程。 路由(Routing)：分拣。根据包裹上的标签，决定包装的去向。  可以看到，每一层都有自己的“货物”，比如中转中心的载荷是满载包裹的长途货车而不是单个包裹。报文在每一层都被封装并交给下一层，要想得到原始报文只能一层一层解开，操作模式类似栈。由此协议分层模型也被简称为协议栈(Protocol stack)。\n最后简单解释五层模型每一层的分工，自底向上顺序：\n 物理层：对接物理介质，运输比特  提供基于比特的通信路径   链路层：将路径串联成链  提供基于链路的接入、交付、和传输服务   网络层：将链路编织成网  提供任意两主机之间的通信   运输层：将主机的通信分解为进程的通信  提供进程间的逻辑通信   应用层：实现用户需求  向用户提供透明可靠的网络服务    偶剋！你已经了解了分层思想，下面来设计互联网吧！（迫真）\n⌚️开始实验 有关计网的学习顺序自古就有自顶向下还是自底向上的分歧，余以为只要理解了分层思想，顺序便不算很重要。本系列实验将遵从浅入深出的原则，从应用层逐步深入到链路层再返回应用层，同时难度不断加大。\n实验来源：\n 👴自己：0x10, 0x20 SEEDLab，雪城大学的信息安全课配套实验，网络安全部分。国内知名度不高所以值得一做。官方网站 CNTDA 实验：GIthub上抄的作业   实验代码仓库：lonelyuan/ComputerNetwork-exp (github.com)\n实验编号规则：0xabn\n a：层级：1 - 应用层；2 - 传输层；3 - 网络层；4 - 链路层；5 - 物理层 b：难度：0 - ⭐；1 - ⭐⭐；2 - ⭐⭐⭐；3 - ⭐⭐⭐⭐；4 - ⭐⭐⭐⭐⭐； n：重复难度则再加一位编号  //【想看哪个没更新的可以催👴】\n 0x10 应用层: Server | ⭐ Intro   目标：用scapy/socket做一个静态服务器。\n  实际上，python3已经自带了一个简易http服务器：\n1 2 3  $ python3 -m http.server Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 127.0.0.1 - - [10/Nov/2021 14:51:57] \u0026#34;GET / HTTP/1.1\u0026#34; 200 -   浏览器访问：localhost:8000，如果当前目录下有index.html文件，浏览器即可显示该html文档。\n  该http服务器也是基于另一个python标准库socket编写的，本实验我们直接用socket实现一个更简单的http服务器。\n    前置：\n  术语：\n  C/S架构(client-server)：互联网的基本模型。通信的双方通常分成两个角色：\n 发起的一方称为客户端(C)，即前端。 接收的一方称为服务端(C)，即后端。为了保证随时接收请求，服务端需要持久监听某通信端口    URL：统一资源标识符。也就是互联网上的地址，网址。\n 完整语法：[协议名]://[用户名]:[密码]@[服务器地址]:[服务器端口号]/[路径]?[查询字符串]#[片段]    HTTP协议：应用层最普遍的文本协议之一。文本协议表示其所有内容都是可读的，其主要格式如下：\n  1 2 3 4 5  GET / HTTP/1.1\\r\\n /* 一个状态行 */ Host: localhost\\r\\n /* 多个首部行 */ ... Connection: close\\r\\n\\r\\n /* 以两个CRLF(回车换行，编程时用\\r\\n表示)隔断 */ \u0026lt;html\u0026gt;... \u0026lt;/html\u0026gt; /* payload */       HTML：标记语言，用\u0026lt;\u0026gt;组织起网页的骨架。浏览器会把HTML源码渲染成好看的网页。\n  socket：逻辑通信的端点。\n socket是逻辑通信的接口。上文提到网络层为运输层和应用层提供了点到点的逻辑通信服务，该服务的基本接口就是socket。 socket是通信端点的抽象。它将进程/应用和(主机host,端口port) 二元组绑定，于是通过 (host,port) 即可标记网络上的进程。  一个主机有一个地址和多个端口。地址和端口的关系，就像房子和窗户的关系。   socket由操作系统提供。本实验用到的是python对socket的封装，但不管换什么语言本质上都是系统调用。 //其翻译“套接字”非常具有误导性，建议直接用英文单词。      建议花5分钟通读《图解HTTP》前6章（或者《CNTDA》2.1-2.2节），以理解上述术语\n    Guidelines   Socket通信   要使用socket通信，通信双方都需要持有一个socket对象，其主要方法和生命周期如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  SERVER CLIENT socket() socket() │ │ ▼ │ bind((host,port)) │ │ │ ▼ │ listen(num) │ │ │ ▼ ▼ accept() connect((host,port)) │ │ ├──►send()──►recv()◄──┤ │ │ ├──►recv()◄──send()◄──┤ │ │ ▼ ▼ close() close()   于是我们可以建立起服务器代码的框架：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  import socket s = socket.socket() s.bind((\u0026#39;0.0.0.0\u0026#39;, 8000)) # 绑定地址和端口 s.listen(5) # 开始监听，num表示最大连接数量 while True: c, addr = s.accept() # c是客户端socket print(\u0026#39;[+] accepted:\u0026#39;, addr) req = c.recv(1024) print(\u0026#39;[+] recieved:\u0026#39;, req.decode(\u0026#39;utf-8\u0026#39;)) # 接收类型为字节对象bytes，要打印则应当编码为字符串 res = http_handler(req) # 解析请求，返回响应 c.send(res) c.close()    It\u0026rsquo;s worth noting that，服务端socket并没有发送任何数据！accept()方法将返回一个客户端socket对象，由这个socket执行数据的收发。这样做的原因是为了实现多路复用，即让服务器支持多个连接同时通信。 于是我们可以看到，对每个TCP连接，都有一对socket存在于通信的两端。而服务端socket仅仅做了管理连接的工作，他们放在一个类里，是出于简化代码的考虑。（当然实现多路复用的方式不只有一种。  现在，你可以自己尝试编写socket客户端跟该服务器进行明文的通信。不过我们的目标是HTTP服务器，先复习一下HTTP协议格式，状态码，首部等知识吧。\n HTTP解析   如果编程能力尚可，你可以自己写HTTP类来把报文解析成对象。这里还是用现成的，scapy库提供的HTTPRequest和HTTPResponse类。\n1 2 3 4 5 6 7 8 9 10 11 12 13  from scapy.layers.http import * from scapy.all import * def http_handler(req_str): req = HTTPRequest() req.do_dissect(req_str) # 解析请求 print(\u0026#39;[+] req: \u0026#39;, req.summary()) # body = route(req.Path.decode()) # 路由函数 body = \u0026#34;\u0026lt;h1\u0026gt;Hello~~~\u0026lt;/h1\u0026gt;\u0026#34; res = HTTPResponse() res = HTTP() / res / body print(\u0026#39;[+] res: \u0026#39;, res.summary()) return raw(res)     do_dissect()方法将字符串解析为对象\n  HTTP()/res/body：scapy核心语法/，表示协议栈的堆叠，可以链式调用。\n  这里的类型为：HTTP / HTTPResponse / Raw，之所以要这样三层表示，是因为HTTPResponse/HTTPRequest类仅仅是一个中间层，如果没有HTTP层，scapy会报warning。\n  raw()方法返回封包的字节数组，可以看到在socket之上，我们先把报文转化为对象，解析之后再返回报文。\n  观察封包的常用方法还有：\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  In [2]: a = Ether()/IP(dst=\u0026#34;www.wsnd.com\u0026#34;)/TCP() In [3]: a Out[3]: \u0026lt;Ether type=IPv4 |\u0026lt;IP frag=0 proto=tcp dst=Net(\u0026#34;www.wsnd.com/32\u0026#34;) |\u0026lt;TCP |\u0026gt;\u0026gt;\u0026gt; In [4]: a.summary() Out[4]: \u0026#39;Ether / IP / TCP 0.0.0.0:ftp_data \u0026gt; Net(\u0026#34;www.wsnd.com/32\u0026#34;):http S\u0026#39; In [5]: a.show() ###[ Ethernet ]### dst = ff:ff:ff:ff:ff:ff src = 00:00:00:00:00:00 type = IPv4 ###[ IP ]### version = 4 ... proto = tcp chksum = None src = 0.0.0.0 dst = Net(\u0026#34;www.wsnd.com/32\u0026#34;) \\options \\ ###[ TCP ]### sport = ftp_data dport = http ... In [6]: ls(a) dst : DestMACField = \u0026#39;ff:ff:ff:ff:ff:ff\u0026#39; (\u0026#39;None\u0026#39;) src : SourceMACField = \u0026#39;00:00:00:00:00:00\u0026#39; (\u0026#39;None\u0026#39;) type : XShortEnumField = 2048 (\u0026#39;36864\u0026#39;) ... In [7]: raw(a) Out[7]: b\u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00E\\x00\\x00(\\x00\\x01\\x00\\x00@\\x06\\xc9\\xa8\\x00\\x00\\x00\\x00H\\ti\\x1e\\x00\\x14\\x00P\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00P\\x02 \\x00\\xdeW\\x00\\x00\u0026#39; In [8]: hexdump(a) 0000 FF FF FF FF FF FF 00 00 00 00 00 00 08 00 45 00 ..............E. 0010 00 28 00 01 00 00 40 06 C9 A8 00 00 00 00 48 09 .(....@.......H. 0020 69 1E 00 14 00 50 00 00 00 00 00 00 00 00 50 02 i....P........P. 0030 20 00 DE 57 00 00 ..W..   现在运行服务器，用浏览器访问localhost:8000，你可以看到大大的“Hello”了！\nTask 下面的任务交给你，目标是尽量接近python自带http服务器的表现。\n为了实现静态服务器，你需要根据访问的路径返回对应的内容。为此，请完善route()函数：\n 访问根路径/将返回index.html 使用os模块读取文件，注意文本文件和二进制文件（如图片）的处理 用HTTP响应码进行错误处理，比如404 NOT FOUND，302 REDIRECT  最后，在根目录(你在哪里运行你的服务器脚本，那里就是你的根目录)下放入任意文件，浏览器都可以访问其内容，如果不存在则会返回404。\nExpand  抓包观察访问你的网站和访问正常网站有什么区别。你会发现，本实验几乎没有讲解HTTP首部的细节，请自行了解诸如Content-Type:，Content-Length:，Transfer-Encoding:等首部，看看传输图片/压缩文件时的标准做法，以及在遇到大文件时如何实现分段运输。（尽管我们的实现很简陋，浏览器还是能正常工作，说明HTTP是相当健壮的协议） 你的服务器是否有安全问题？你可以访问根目录之外的文件吗？如： /../../../../etc/passwd（linux下） 服务器概念辨析：Web初学者容易对服务器概念感到迷惑。软件语境下，服务器指对外提供服务的程序，常用服务器如apache、nginx，tomcat等；硬件语境下则指运行着服务器软件的机器。 我们实现的是静态网站，你可能疑惑是不是还有动态网站。当然有，区分动态和静态并不是网页会不会自己动，而是服务器上的数据是否可以动态的改变，而我们的服务器只能被动的显示文件，客户端无法做出任何更改。现代web框架诸如Springboot，Django之类当然是动态网站框架。  实际上，计网并不关心应用层以上的东西，让我们向下看，探究socket背后的原理吧。\n0x20 传输层：Socket | ⭐ Intro  目标：用 scapy 实现TCP协议，以尽可能替换上一个实验使用的socket模块  // 你可能猜到了，下一个实验是不是要自己实现IP协议呀？恭喜你猜错了。   前置：  术语  TCP/UDP TCP报文格式 有限状态机   完成本实验仅涉及《CNTDA》3.4-3.5节，如果理解有困难，建议先完成Wireshark 实验：TCP观察   在上一个实验中，我们了解到socket是操作系统提供的系统调用，例如 Linux 中，创建socket对象返回的sock_fd本质上就是一个文件描述符，即建立连接后可以直接像文件一样读写，绑定端口后操作系统会保护该端口不被其他进程占用。而本实验关注运输层原理，所以绕过了操作系统，使用更底层的接口实现TCP。当然，是最简陋的一种实现。  Guidelines  Socket实现原理  那么，socket里面到底有什么？首先，要保存地址端口等信息；其次，要有收发的两个缓冲区，这里可以用队列；然后，为了实现可靠运输，需要用到计时器来触发重传，需要变量标记滑动窗口；我们还用自动机思想来管理连接状态。Socket底层模型如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  ┌─────Socket──────┐ ┌─────┐ │ ────────────┐ │ ┌────┐ │ ├──┼─► SendQ ├──┼─►│ │ │ │ │ ────────────┘ │ │ │ │ App │ │ Buffers │ │ IP │ │ │ │ ┌──────────── │ │ │ │ │◄─┼──┤ RecvQ ◄─┼──┤ │ └─────┘ │ └──────────── │ └────┘ ├────Variables────┤ │ Status │ │ Timer │ │ SendBase │ │ NextSeq │ └─────────────────┘   这里就需要面向对象上场了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Socket: def __init__(): self.SendQ = Queue() self.RecvQ = Queue() self.Status = Status.CLOSED self.Timer = Timer() self.SendBase = 0 self.NextSeq = 0 # SERVER def bind(addr): self.addr = addr pass def listen(num): pass def accept(): #return c, addr  pass # CLIENT def connect(addr): pass # BOTH def recv(length): #return data pass def send(data): pass def close(): pass   下面逐个实现socket接口。\n 定制TCP报文\n  连接管理\n  了解了三次握手，就可以实现connect函数了\nTask  多路复用  目前的实现只能支持一个TCP连接，请实现listen(num)函数，调用时创建 num 对读写缓冲区，响应的为\n 完善TCP功能：   RTT 可靠运输 流量控制 阻塞控制  拓展UDP到你的socket  Expand 0x30 网络层: 路由追踪 | ⭐ Intro 术语：\n IP层：IP协议，ICMP协议，路由协议 路由追踪：请求某地址经过了那些路由器？  Guidelines scapy实现了路由追踪函数，你可以钻研一下源码（很短），下面写一个自己的traceroute。\nTask 下面用Ipython演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  In [1]: from scapy.all import * In [2]: target=\u0026#34;www.amazon.com\u0026#34; In [3]: ans, unans = sr(IP(dst=target,ttl=(1,30))/TCP(flags=0x2)) Begin emission: Finished sending 30 packets. .*****..**********..........................................................................^C Received 92 packets, got 15 answers, remaining 15 packets In [4]: for snd, rcv in ans: ...: print(snd.ttl, rcv.src, isinstance(rcv.payload, TCP)) ...: 1 11.206.119.46 False 2 11.110.80.173 False 3 10.102.15.74 False 4 11.73.2.241 False 5 124.160.189.101 False 6 219.158.97.2 False 7 219.158.34.190 False 8 69.192.14.38 True 9 219.158.24.134 False 10 219.158.10.30 False 11 69.192.14.38 True 12 69.192.14.38 True 13 69.192.14.38 True 14 69.192.14.38 True   下面讲解核心代码：\nans,unans=sr(IP(dst=target,ttl=(1,30),id=RandShort())/TCP(flags=0x2))\n sr()：send and receive，返回的两个参数分别是得到应答的数据包列表和未应答的包列表。 ttl=(4,30)：ttl参数在IP层表示ICMP包的转发次数（跳数）。此外，传入tuple表示一个范围，sr函数将会为这个范围内的每个值生成一个发包。（如果有多个tuple参数，则会按笛卡尔积规则生成发包列表） TCP(flags=0x2)：在TCP头部设定flag字段的值，0x2对应ACK，即确认收到包。 综合起来，这条代码将发送30个包，其ttl从1到30。并筛选返回ACK的包。 这样根据IP层路由算法，到达ttl的包无论是否找到目标都会返回，直到找到目标，TCP层返回ACK。遍历ttl形成的列表即是经过的所有路由。  Expand 0x301 网络层: 欺骗ping | ⭐ | TODO Intro  来源：https://seedsecuritylabs.org/Labs_20.04/Files/ICMP_Redirect/ICMP_Redirect.pdf 术语：  Guidelines Task Expand 0x41 链路层: ARP缓存投毒 | ⭐⭐ | TODO https://seedsecuritylabs.org/Labs_20.04/Files/ARP_Attack/ARP_Attack.pdf\n0x21 传输层: TCP攻击 | ⭐⭐ | TODO https://seedsecuritylabs.org/Labs_20.04/Files/TCP_Attacks/TCP_Attacks.pdf\nTCP协议 SYN泛洪 TCP reset TCP session hijacking反弹shell （重点）\n0x31 网络层: NAT，DHCP和虚拟机 | ⭐⭐ | TODO 相信折腾过虚拟机的同学都绕不过这个问题：我的虚拟机怎么连不上网？本实验基于wmware虚拟机平台，讲解几种虚拟机网络模式及其原理。\n0x13 应用层: DNS本地攻击 | ⭐⭐⭐ | TODO https://seedsecuritylabs.org/Labs_20.04/Files/DNS_Local/DNS_Local.pdf\n0x14 应用层: SSL协议和HTTPS | ⭐⭐⭐⭐ | TODO 0x15 应用层: 多线程Web代理服务器 | ⭐⭐⭐⭐⭐ | TODO 0x151 应用层: VPN | ⭐⭐⭐⭐⭐ | TODO 探究VPN原理\n0x152 应用层: V2Ray协议学习 | ？？？ | TODO 有生之年研究一下Vmess等协议\n  ","date":"2021-10-22T23:55:54Z","permalink":"https://lonelyuan.github.io/p/%E4%BB%8Escapy%E5%92%8Cwireshark%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"从scapy和wireshark学计算机网络"},{"content":" 上回书说到，网站初具雏形，但经高人指点，还是有很多不足。 本文将大胆扩充网站结构，目标是将网站拓展成一个 CMS 。 所以，不要停下来啊！👆（指开发\n  0x00 蓝图与重构 与之前相比，网站将增加以下功能：\n 图库：文件上传模块 评论：楼中楼功能 后台：权限模块，后台模块 优化：更健壮的数据库接口，更细致的权限控制 plus功能：用 redis 实现热搜  在开发这些功能之前，首先重整项目结构。如：\n 完全蓝图化。参考  模板也放入独立子目录里，蓝图注册时使用template_folder参数，不过这样容易产生bug，flask 官方推荐使用硬编码，汗。   清理依赖，不使用维护状态差的库。  开发新功能的时候，去哪里找最佳实践，找好用的库呢？有一个 Github 搜索小技巧，名为 \u0026ldquo;awesome-xxx\u0026rdquo; 的仓库通常是某技术的优质资源列表。如：https://github.com/humiaozuzu/awesome-flask    0x01 文件系统  本部分参考了李辉大佬的系列文章， https://zhuanlan.zhihu.com/p/23731819?refer=flask\n 头像，照片……文件上传是绕不开的话题。在上一篇参考的教程中，头像的实现是由托管网站生成随机的图片。遗憾的是并没有像 ORM 一样方便数据库处理的文件处理框架可供使用，还是自己把他啃下来吧。\n注意踩坑！大部份资料推荐使用Flask_uploads插件，然而使用该插件时出现如下报错：\n1  ImportError: cannot import name \u0026#39;secure_filename\u0026#39; from \u0026#39;werkzeug\u0026#39;   查阅Stackoverflow得知是PYPI源上的Flask_uploads插件不再维护了，于是和 werkzeug 库的api不兼容，是插件内在的bug。网上的解决方法有二：\n 一是修改库源码 二是换另一个库，维护良好且可无缝迁移，名为Flask-Reuploaded  前者不利于后续部署，本人倾向于后者。然而，使用新库也遇到了诸多麻烦，使用UploadSet.url()方法时，报错如下：\n1  werkzeug.routing.BuildError: Could not build url for endpoint \u0026#39;_uploads.uploaded_file\u0026#39; with values [\u0026#39;filename\u0026#39;, \u0026#39;setname\u0026#39;].   UploadSet.url()方法返回对应文件的可访问url，返回的url默认带有_upload/前缀，这是 Flask-Uploads 自带的路由，也被称为 autoserve 。 然而官方文档里有这样一句话\n autoserve of uploaded images now has been deactivated; this was a poorly documented “feature”, which even could have lead to unwanted data disclosure; if you want to activate the feature again, you need to set UPLOADS_AUTOSERVE=True\n 看来 Flask-Reuploaded 的作者似乎认为文件读取功能与我无瓜。好吧，这部分我们自己实现。\n// 浪费了一晚上debug，结果只是因为文档没看明白，再次证明读文档的重要性。\nFlask-Reuploaded: 文件上传 插件将上传的一类文件抽象成集合UploadSet。对每个 Set 有如下操作：\n 配置文件类型：photos = UploadSet('photos', IMAGES) //类型包括：IMAGES、TEXT、AUDIO…… 配置存贮路径：app.config['UPLOADED_PHOTOS_DEST'] // Photos 为 Set 的变量名 保存文件：filename = photos.save(request.files['photo']) 返回链接：photos.url(filename)  最后，注册 Set 和插件注册类似：configure_uploads(app, [avatars, photos]) //可一次性全部注册\n实现头像上传的步骤如下：\n 模型层： User 添加 avatar 字段，储存头像的文件名。原avatar()方法作为默认头像。 表单层： edit_profile 表单增加FileField字段 视图层： 储存文件，向数据库提交文件名。 模板层： 改用硬路由获取url。// 最终 .url() 还是有bug，再次说明不要乱用不知名的插件  图库模块 本模块包括如下路由：\n /index：主页显示瀑布流 /upload：上传接口：参考头像上传 /detail：详情，显示评论 /delete：删除接口：同时删除文件  由于本项目前端框架是 Bootstrap ，👴不想写Jquery，所以直接刷新页面，也不弄无限滚动了，按钮了事。另外为了不同列长度尽量均匀，故采用取巧的方法，平均分配。根据大数定理，只要随机图片足够多肯定会差不多均匀。。。。\n0x02 评论系统 数据库设计 评论包含了两个一对多关系，既是评论和文章的一对多关系，也是评论和用户的一对多。为此，只需要给User和Post添加关系即可。 然而，我们希望设计统一的Comment模型，评论的对象既可以是文章，也可以是图片，也可以是其他评论。为此，添加一个枚举类型的字段指示评论类型，从而采用不同的处理逻辑。\n楼中楼 而主流网站不光支持对文章评论，还支持楼中楼。对楼中楼的实现有以下几种方案：\n 按时间平铺：以原百度贴吧为例  添加 reply_id 字段，指示要回复的人   套娃式缩进：以某些老式bbs为例  添加 parent_id 字段，指示父评论（顶层评论则为本身id），在实体类中保存子评论列表   弹窗式查看：以知乎，b站为例  在按时间平铺的基础上，若 reply_id存在添加“查看对话”按钮，递归的构建对话并弹窗。    其中，第一种实现简单，用户不友好；第二种实现复杂，对多层级对话无法胜任；第三种是最主流的实现方式。\n通过以reply_id作为指针，所有评论连接成了一棵树，在任意一个节点进行“查看对话”操作，就是执行树的寻根。“查看对话”函数如下：\n1 2 3 4 5 6 7 8 9  @staticmethod def view_dialogue(c_id): dialogue = [c_id] while Comment.query.get(c_id).type == \u0026#39;comment\u0026#39;: c_id = Comment.query.get(c_id).reply_id if Comment.query.get(c_id) is None: break dialogue.append(c_id) return dialogue   0x03 网站后台 网站的后台通常给管理员提供统一监管数据库的界面。有以下插件帮助实现：\n Flask-admin：一键生成后台页面，并可以自定义视图和模型。 Flask-Security： 比admin层次更高，封装了常用视图和模板。但是文档少，且很多功能我们已经实现了，再使用它就要推翻重做。遂弃用。  本教程中使用了 RBAC（Role-Based Access Control) 基于角色的访问控制，简单说就是设计一个角色表，用户表和角色表用关联表实现多对多关联。这样做的好处是，针对角色的权限分配，修改权限时无需修改每个用户。\n0x04 热搜 本节再加入一个重量级内容，利用 redis 实现浏览量排行榜，也就是热搜。当然，真正的热搜榜单排名规则更加复杂，这里只通过简单的浏览量计数来练习 redis 的使用。\n【👴有时间再做】\n不要让开发停下来 可以加的功能还有很多：时间线，emoji支持，多媒体，前后端分离(Vue)，，\n除了功能，当面对更高量级的流量时，网站性能便更加重要，这时候消息队列，PRC，微服务/分布式，，，更让人头秃。\nWeb开发之路，道阻且长。但是，只要开发不停下来，道路就会不断延申。。。（希望之花.mp3）\n","date":"2021-09-16T12:43:23Z","permalink":"https://lonelyuan.github.io/p/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%BD%91%E7%AB%99%E4%BA%8C-flask-supreme-tutorial/","title":"年轻人的第二个网站（二） - flask-supreme-tutorial"},{"content":" 本文为 Flask 框架学习笔记，主要参考了 The-Flask-Mega-Tutorial 和 《Flask Web开发：基于Python的Web应用开发实战》两本书，并在原项目的基础上拓展。（下文统称这两个资源为“本教程”） 不熟悉 Flask 框架请先阅读快速上手 - flask 中文文档 。\n这两本书的作者是同一个人，就内容上说后者算是前者的豪华版。本教程的优点是内容全面，从入门到部署一站式服务；缺点是不够深入，且有些过时，书中举例的诸多插件均为作者为了此书而开发的，已经许久不再维护，导致很难在其示例项目上拓展。一看扉页，2015年出版，那没事了。 至于第一个网站？参见#TODO:年轻人的第一个网站\n  0x00 大型项目结构 在大部分面向初学者的 demo 中，应用以简单的项目结构甚至单文件表示。在大型项目中，网站的不同功能被拆分成独立的模块，以方便拓展和维护。一个更通用的 Flask 项目代码架构如下：（仅考虑业务代码）\n1 2 3 4 5 6 7 8 9 10  microblog/ # 根目录 app/ # 项目源码 __init__.py # 项目初始化，当该包被import，首先执行__init__.py routes.py forms.py ... main.py # 框架入口 config.py # Config配置类 .flaskenv ...   根目录下的文件有：\n app/所有网站源代码统一归到app目录下。  在app/内部，不同的功能可进一步划分成独立模块，详见[模块化应用](#0x05 模块化应用：功能解耦)一章。   main.py: 入口脚本，通过该文件引入app中的代码并生成应用实例（命名随意） .flaskenv: flask环境变量，以配合flask命令。入口脚本被定义为FLASK_APP，执行flask run时将启动该脚本。 config.py: 配置脚本，整个项目的配置信息都写在Config类里。与环境变量的区别在于，因为是python脚本，功能更强大，可被任何地方的代码引用。  0x01 Hello world：模板和视图 最基本的 web 功能，无非接受请求、返回数据。其中，路由 (route) 用来区分不同的请求，模板 (templates) 用来生成不同的数据。\n路由/视图 在非前后端分离的项目中，视图函数直接返回渲染好的网页，由@app.route()修饰后，视图和路由便绑定在一起。 在mvc模型中更像controller控制器的角色，然而在flask生态中更喜欢称为视图函数。\n url_for() 使用URL到视图函数的内部映射关系来生成URL，用来替换硬链接。在业务功能解耦后必须使用这种方式。  NOTE：当路由和视图函数名不一致，访问该路由可以正确响应，但是使用url_for()调用该视图时会报错   {% extends \u0026quot;base.html\u0026quot; %} and {% include \u0026quot;_post.html\u0026quot; %} 使用子模板来实现网页公用的部分。如：页眉，页脚，列表项等。  模板和 Python 代码的关系有些类似与 JSP 和 Java 代码的关系，但模板语法并不是完整的脚本语言，相较而言限制更多，安全性更好。    表单  几乎所有成功的框架都有丰富的插件生态。下面引入新功能时，大多借助插件来方便的实现。大多数Flask插件使用flask_\u0026lt;name\u0026gt; 命名约定。\n Flask-WTF插件提供了对Web表单的抽象，只需定义表单类以及设置类属性即可。\n模板语法：\n {{ form.\u0026lt;name\u0026gt;.label }}渲染标签 {{ form.\u0026lt;name\u0026gt;() }}获取属性值 form.hidden_tag()模板参数生成了一个隐藏字段，其中包含一个用于保护表单免受CSRF攻击的token  将表单引入模板\n1 2  form = LoginForm() # 生成了一个实例传入模板 return render_template(\u0026#39;login.html\u0026#39;, title=\u0026#39;Sign In\u0026#39;, form=form)   flash 闪现消息 flash 通过 session 储存，用于显示只出现一次的提示消息。用法：\n 在路由中使用flash()，触发时消息便写入 session 中的 message 列表 在模板中使用get_flashed_messages()，从 session 中读取  0x02 数据库 ORM 很久很久以前，web网站和数据库交互还需要写很多很硬的 SQL 语句，效率低且容易出现注入漏洞(SQLi)。现代web开发都使用 ORM 框架简化数据库交互，且基本杜绝了 SQLi 漏洞。\n本项目使用如下插件打通数据库：\n Flask-SQLAlchemy: Python生态最知名的ORM框架 Flask-Migrate: 本教程作者编写的数据库迁移框架   插件首先要注册。统一流程: 初始化app实例，传入插件类作为插件实例的参数\n1 2 3 4 5  # app/__init__.py app = Flask(__name__) # flask基类 app.config.from_object(Config) db = SQLAlchemy(app) migrate = Migrate(app, db)    SQLalchemy：model层 模型定义 使用类和类属性代表 table 和 colunm ，便可轻松编写数据模型。SQLalchemy 的概念抽象如下图： Flask-SQLAlchemy 自动设置类名为小写来作为对应表的名称，也可以用__tablename__类属性来定义。\n1 2 3  class Post(db.Model): # 表 id = db.Column(db.Integer, primary_key=True) # 列 ....   CURD基本操作 ORM 框架通常集成了常用操作，但也支持更底层的数据库接口。\n 在 Springboot Jpa 中，根据方法名的拼写来写自定义查询，而在 SQLalchemy 中，提供的接口通过链式调用拼接。\n 在 SQLalchemy 中，基本操作大都有基于事务 (session) 的和基于查询 (query) 的两种方式。\n  查\n1  session.query(User)   query方法只有构造一个查询，只有在Query.get()、Query.all()、Query.one()等结束符之后才会执行查询\n  增：\n1 2  db.session.add(user) db.session.commit()     删\n1 2 3 4  session.query(User).delete() # or session.delete(session.query(User).get(1)) session.commit()     改\n1 2 3 4 5 6 7 8 9  query = (session .query(User) .filter_by(id=1) .update({\u0026#34;username\u0026#34;: User.username + \u0026#34;a\u0026#34;}, synchronize_session=False) ) # or user = (session.query(User).get(1)) user.password = \u0026#34;zxcv\u0026#34; session.commit()     Flask-Migrate: 数据库迁移 配置数据库的初始数据框架，一般写成SQL脚本形式。 migrate 框架直接根据 model 层生成迁移脚本，可以方便的跟踪数据模型的修改和数据库的切换。（这个框架还是本教程作者自己开发的，强）\nflask db子命令\n flask db init：初始化，生成migrations目录 flask db migrate：生成迁移脚本，修改model后使其生效  flask db migrate -m \u0026quot;posts table\u0026quot;    flask db upgrade：应用数据库修改（开发阶段默认使用sqlite数据库 flask db downgrade：回滚上次的迁移  0x03 开发范式：用户系统  mixin：混入，多重继承的一种形式\n 表单和数据库支持分别解决了前端和后端的基本需求，下面可以上线一个基本功能了，用户登录。 所需插件：Flask-Login。\nUserMixin类 UserMixin类集成了login插件要求的用户模型属性，将其混入到 User 模型中，即可用@login_required 实现权限控制。\n1 2  @app.route(\u0026#39;/result/\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) # NOTE：有顺序关系，反之则不生效 @login_required   用户系统，包括登录、登出、注册几个功能。编写这些功能的步骤其实很类似：\n 设计数据库，在model.py中 设计表单对象，在form.py中 设计页面，在模板.html中 设计视图函数，在routes.py中  也对应了mvc框架的设计理念，比如设计表单就有些像 javaweb 中的 DAO 层。但也有区别， Flask 框架更希望业务逻辑写在数据库模型中，而视图函数尽量保持简洁，以方便单元测试。\nPRG 模式 即为 Post/Redirect/Get，其格式大概如下：\n1 2 3 4 5 6 7 8 9  @bp.route(\u0026#39;/some_form\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def some_form(): # prepare forms  if form.validate_on_submit(): # submit modification return redirect(url_for(\u0026#39;main.some_form\u0026#39;)) elif request.method == \u0026#39;GET\u0026#39;: # GET data return render_template(\u0026#39;some_form.html\u0026#39;, form=form)   默认情况，提交 POST 请求后，如果直接刷新浏览器，会重新在 POST 一次。使用PRG模式即可解决重复提交表单的问题。\n0x04 深入数据库：粉丝机制 数据库关系 要关注别人，就要让数据库记住我关注的人的名字，当然，只记住名字肯定不够，万一改名了呢。因此每个用户都需要有唯一有效的标识（其实更重要的是性能因素）。正因如此，数据库中每个表都要有一个唯一的列，称为主键(primary key)。当不同表之间存在关系，一个表要通过主键寻找其他表项，其他表的主键储存在本表中，称为外键(foreign key)。外键关联既可以表示一对一的关系，也可以一对多(1-\u0026gt;n)。\nSQLalchemy 对关系的定义如下：\n 外键：db.ForeignKey('user.id') 关系：db.relationship('Post', backref='author', lazy='dynamic')  参数1：所关联的表(n in 1-\u0026gt;n)，这里是模型的变量名 参数2：由 \u0026ldquo;n\u0026rdquo; 回调 \u0026ldquo;1\u0026rdquo; 的虚拟字段，用法：post.author    粉丝机制 然而，粉丝机制包括关注和被关注。这是一种多对多的关系，于是需要用含有两个外键的关联表表示。又因为关注者和被关注者在一个表里（User），这种关系又称为自引用。\n模型   关联表只有引用类型，故不需要派生模型类\n1 2 3 4 5  followers = db.Table( \u0026#39;followers\u0026#39;, db.Column(\u0026#39;follower_id\u0026#39;, db.Integer, db.ForeignKey(\u0026#39;user.id\u0026#39;)), db.Column(\u0026#39;followed_id\u0026#39;, db.Integer, db.ForeignKey(\u0026#39;user.id\u0026#39;)) )     为User添加关系\n1 2 3 4 5  followed = db.relationship(\u0026#39;User\u0026#39;, # 右侧实体 secondary=followers, # 指定关联表 primaryjoin=(followers.c.follower_id == id), # 指定左关系 secondaryjoin=(followers.c.followed_id == id), # 指定右关系 backref=db.backref(\u0026#39;followers\u0026#39;, lazy=\u0026#39;dynamic\u0026#39;), lazy=\u0026#39;dynamic\u0026#39;) # 指定回调     复杂查询   查询粉丝列表\n  SQL 语句：SELECT * FROM user, followers WHERE followers.follower_id = 3 AND followers.followed_id = user.id\n  SQLalchemy 接口：user.followers.all()\n  实际执行的 SQL 语句：（打印 query 对象得到）\n1 2  SELECT ,,, FROM user, followers WHERE followers.followed_id = ? AND followers.follower_id = user.id     NOTE：如果方法集成在model里，方法名不要和字段名相同，自己定义的方法会覆盖该字段。\n    查看已关注用户的动态\n  SQL 语句：SELECT * FROM post JOIN followers on followers.followed_id = post.user_id where followers.follower_id = 2\n  SQLalchemy 接口：\n  1 2 3 4  Post.query.join(followers,(followers.c.followed_id==Post.user_id)).filter(followers.c.follower_id==self.id).order_by(Post.timestamp.desc())    实际执行的SQL语句：\n1 2 3 4 5 6 7 8 9  SELECT,,,FROM(SELECT,,,FROMpostJOINfollowersONfollowers.followed_id=post.user_idWHEREfollowers.follower_id=?UNIONSELECT*FROMpostWHEREpost.user_id=?)ASanon_1ORDERBYanon_1.post_timestampDESC      由于python的弱类型特征，有时候很难明白函数之间传递的是什么对象。我们从上往下梳理一遍：\n 请求到达路由函数，开始执行查询Post.query.....，此时只是在构造查询，并未取得数据，此时的对象类型：\u0026lt;class 'sqlalchemy.orm.query.Query'\u0026gt; 直到get(),all(),paginate().items结束符等出现，查询才被执行，返回数据类型实例，如User。 数据类实例传入模板，并由__str__等方法参与渲染。  0x05 网站美化 本教程提供的flask-bootstrap插件，较为简陋，且该插件年久失修，遂替换之。在此之前，先搞明白目前项目前端的架构\n1 2 3 4 5 6 7  /templates auth/ errors/ base.html _posts.html index.html ...   所有模板都有一个父模版：base.html，其结构如下：\n1 2 3 4 5 6 7 8 9  {% extends \u0026#39;bootstrap/base.html\u0026#39; %} {% block title %}Hallo Wolrd{% endblock %} {% block head %} ... {% endblock %} {% block scripts %} ... {% endblock %} {% block navbar %} ... {% endblock %} {% block content %} ... {% block app_content %}{% endblock %} {% endblock %}   app_content留空，即其余模板均在app_content内填充。\n进一步追溯bootstrap/base.html的源码，发现其它 block 诸如navbar也都留空或仅仅配置了 Bootstrap 的 cdn。 由此，只需将base.html迁移即可。\n在网上寻找新的UI模板，不要在中文互联网搜索，basically garbage。找到一个 Meterial 模板 还算顺眼，遂用之。\n不熟悉 Bootstrap 布局的可以使用可视化工具来设计前端，如：http://www.ibootstrap.cn/\n对照模板，将base.html掏空，效果如下：\n遇到的bug有：\n 下拉菜单失效：查询得知有可能是bootstrap版本冲突  //结果并不是，只是忘记引入js文件而已，我是傻逼。   文件上传按钮消失：本教程中，表单渲染采用wtf.quick_form()，这玩意还是来自bootstrap/wtf.html  最后决定整个🐏了 Flask-Bootstrap 插件。\n富文本编辑器 在《Flask Web开发：基于Python的Web应用开发实战》中提到了markdown编辑器的实现。\n需要的包：\n PageDown: JS 版 Markdown 渲染器，用于客户端预览。 Flask-PageDown: flask 集成插件。该插件需要注册 Markdown: Python 版 Markdown 渲染器，用于服务端渲染。 Bleach: HTML 清理器，保证安全性  为了兼顾安全和效率，做法是同时保存 markdown 源文本和 HTML 文件。步骤如下：\n 表单改为 PageDownField 模板引入 PageDown 宏，以实现即时预览 为 Post 模型增加字段，并添加 markdown 渲染方法，该方法为类方法，需要@staticmethod修饰 在模型外部监听数据库事件，仅当 markdown 文本出现变动时调用渲染方法。 修改模板以显示服务端返回的 html 文本  然而预览器过于简陋，也很难修改。在github仓库上发现该插件也是本教程作者写的，已经很久没有维护。顿时对本书作者有些不满。\n0x06 模块化应用：功能解耦 保持 app 作为全局变量的模式，可能会给后续引入新功能和单元测试带来麻烦。 要适应大型项目需求，需要把网站功能拆分成独立的模块。\nBlueprint化 要实现解耦，一种功能的相关代码可以借助Blueprint归类到一个包里。其文件结构大致如下：\n1 2 3 4 5 6 7  app/ some_fuction/ \u0026lt;-- blueprint package __init__.py \u0026lt;-- blueprint creation ... other code ... templates/ some_fuction/ \u0026lt;-- templates __init__.py \u0026lt;-- blueprint registration   创建blueprint与创建应用非常相似。\n1 2 3  from flask import Blueprint bp = Blueprint(\u0026#39;func\u0026#39;, __name__) from app.func import Func   而消灭了app，蓝图内部的引用统一变成了蓝图名。而外部诸如url_for的参数则需要加上包名.做前缀。\n应用工厂模式 工厂函数是一个外部函数，在这个函数内部执行插件注册和配置工作，并通过他返回应用实例。\n1 2 3 4 5 6 7 8  # app/__init__.py db = SQLAlchemy() # ... def create_app(config_class=Config): app = Flask(__name__) app.config.from_object(config_class) db.init_app(app) # ...   返回后，flask提供的上下文对象current_app将指向应用实例。详见官方文档：应用上下文\n多线程 current_app是线程绑定的，若要在诸如邮件服务的位于其他线程的功能调用他，则会发现没有赋值。 需要使用current_app._get_current_object()表达式。\nPython概念辨析：包，库，插件  包 (package) 是指一种代码结构，只要有文件夹和 __init__.py 都是包。 库 (library) 和插件 (plugin) 都是从外部引入的包，区别在于，插件要集成进应用，所以需要注册等步骤；而库更独立，可以随时随地调用\n 0x07 开发帮手 本节讲解一些杂项。\n调试  flask shell命令：为避免每次调试都要重新import app，使用上下文调用解释器，用@app.shell_context_processor装饰上下文函数  单元测试 unittest 库，详见下一篇。\n记录日志到文件 logger 库\n1 2 3 4 5 6 7 8 9 10 11 12  if not app.debug: if not os.path.exists(\u0026#39;logs\u0026#39;): os.mkdir(\u0026#39;logs\u0026#39;) file_handler = RotatingFileHandler(\u0026#39;logs/microblog.log\u0026#39;, maxBytes=10240, backupCount=10) file_handler.setFormatter(logging.Formatter( \u0026#39;%(asctime)s%(levelname)s: %(message)s[in %(pathname)s:%(lineno)d]\u0026#39;)) file_handler.setLevel(logging.INFO) app.logger.addHandler(file_handler) app.logger.setLevel(logging.INFO) app.logger.info(\u0026#39;Microblog startup\u0026#39;)   requirement.txt 装的库太多怎么办？只需要两条命令：\n1 2  pip freeze \u0026gt; requirements.txt pip install -r requirements.txt   0x08 网站上线 最后简单列出几种网站部署的方法，详情参考本教程或自行搜索。\nnative模式  买主机  连主机：ssh   买域名  配域名   配环境  数据库 服务器 其他依赖   持续运维  容器化技术：docker  写dockerfile docker-compose up \u0026ndash;build -d  云技术：PaaS  注册云平台账户 写Procfile git push  ","date":"2021-09-09T20:18:56Z","permalink":"https://lonelyuan.github.io/p/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%BD%91%E7%AB%99-the-flask-mega-tutorial/","title":"年轻人的第二个网站 - The Flask Mega Tutorial"},{"content":"🛁 这是👴第一次打高达80支队伍的大型AWD，👴此行的目标就是称霸酒店的游泳池。后来发现游泳池要钱，👴只能遗憾败北。（后来发现情报出了问题，根本不要钱，血亏）总的来说，酒店浴缸很带，主办方态度很好，赛场很清真，参赛体验很爽，赚了。\n “终端越炫，嗨客越带；嗨客越带，帽子越带”\n 🐐AWD复盘 首先根据参赛手册，进行一个规则的复制：\n1 2 3 4 5 6 7 8 9 10 11  1、 采用线下赛的方式，参赛团队通过有线连接到局域网，并进行网络连通性的测试。请自备连接网络所需要的设备如usb转RJ45转换器等工具。 2、 攻防赛部署若干道赛题，初始分值为10500分。 3、 使用xctf用户通过ssh连接GameBox，GameBox的ip地址和登录密码通过赛事页面下载获取。 4、 比赛10分钟/回合，每个回合会更新GameBox上的flag。 5、 每个回合内，一个战队的一个服务被渗透攻击成功（被获取到flag并提交），则扣除10分，攻击成功的战队平分这些分数。 6、 每个回合内，服务宕机或无法通过check则会被扣除10分，服务正常的战队平分这些分数。 7、 参赛战队在修复漏洞时，请保持服务的正常功能和打印字符、界面样式，否则将无法通过系统check。 8、 每个回合内，服务异常和被拿flag可以同时发生，即战队在一个回合内单个服务可能会被扣除两者叠加的分数，最多扣除20分。 。。。 7、 请参赛战队在比赛开始时对所有服务进行备份，主办方仅提供2次重置机会，2次机会使用后不予重置。申请重置时请提供战队名称。 8、 禁止使用通用防御方法如waf等工具，违规者第一次被发现扣除当前分值的10%，第二次被发现扣除当前分值的50%，第三次被发现取消参赛资格并向其学校发文进行通报批评。    比赛全程收手机，断外网，不能用waf，不准用不死马，大家都很清真，找回了ctf最初的快乐。  然后按照AWD开局的任务清单，进行一个盘的复：\n准备阶段  ssh连接：  主办方提供了ssh密钥，和靶机ip  于是省略 ssh-copy-id -i ~/.ssh/id_rsa.pub root@xx.xx.xx.xx环节。   但是万能的Windows Terminal连不上去（依然不知道为啥），👴只能用图形化ssh客户端添加私钥连接。   IP扫描：  共有7道题，3道web，4道pwn，每道题目一个独立靶机，有独立的ip地址。不同靶机d段不同，不同队伍c段不同，按初赛排名分配。平台上告知了全部的ip列表。  于是省略nmap -sn xx.xx.xx.0/24环节。   选手机和靶机池在一个局域网内。不同队伍c段不同，一个队伍内的不同电脑d段不同。   流量监控：  主办方贴心的提供了被打流量(但是只有下行流量)，直接在~/package目录下给出.pcap文件。  于是省略tcpdump tcp -i eth0 -t -s 0 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap环节。 (不过用户名叫xctf，权限卡的很死。不给流量的话估计也只能在站里上流量监控脚本)   更新速度很快，被打之后几乎可以立刻找到流量。于是手速很重要。    开局阶段  备份源码：tar -zcvf w.tar.gz /var/www/html  结果\u0026gt; Permission Denied，遂跳过   扫马删马：D盾  👴直接在图形化shell里下载代码，然后崩屎了几次，手速慢了。 每个web题都有一个不明小文件，显然是小马，删除之。   备份数据库：mysqldump -uctf -p --databases [dbname] \u0026gt; /tmp/db.sql  结果\u0026gt; Permission Denied，遂跳过   改数据库密码：mysql\u0026gt;SET PASSWORD FOR ctf@localhost=PASSWORD('newpass');  结果\u0026gt; Permission Denied，(╯▔皿▔)╯玩nm    然后开始源码审计(❌) 然后等待被打之后翻流量(✔️)  攻防阶段 👴只看得懂web题目。三道web题全是cms，是经典lamp环境。可是👴看不懂cms，👴是five。\nweb1：safecms  比赛一开始，啪的一下很快啊，全场被打，翻流量抓到payload，是一个模板文件的任意读漏洞。直接批量拿flag。 定位到路由，注释之，不好使，还是被打；删除这个.class.php，不好使；👴怀疑是运行时缓存不更新，直接service restart apache2  结果\u0026gt;Permission Denied，👴佛了   就这样被打了好一会，才发现直接修改index.php，能直接生效，血亏。  web2：eyou  这道题被打的很少，被宕机的很多。抓流量，发现很多混淆流量。（日志写shell？） 👴跟着流量尝试用过滤的方法修复，但是还是被宕。 若干轮后，👴没办法，只好申请重置，并在下一轮被宕。 若干轮后，👴没办法，只好申请重置，并在这一轮被宕。 若干轮后，👴没办法，只好白给，并在某一轮恢复正常并坚持到最后。我？？？  该不会是某队或者裁判看我们太可怜帮我们重置了吧，世界上还有这么温柔的人，我真的哭死   这道题无了。（赛后才知道，有队伍找到sqli并登录后台，在后台关闭了站点并羊了管理员账号。修nm。  web3：lol  这道题是最后三小时放的，👴这时候已经自闭了几个小时。于是👴痛定思痛，开局直接把admin.php羊了，然后奇迹般的守到了最后。坏了，好起来了。 全场被打，翻流量找到payload，某路径下有白给shell，直接删马并反打。 某队使用了在网页输出中塞随机字符串的防御方法，但是没破坏flag，且填充的字符是固定的，被我肉眼识破，我直接进行一个if ip == xx: flag = flag[12:]。虽然没什么卵用，但是很快乐。  pwn： 一看到4个pwn👴直接傻掉。👴觉得👴不会做，因此也没去看，但听大佬说，直接抓流量进行一个转发就能拿分，👴下次一定准备好pwntools。\n🔒自动化攻防框架 AWD中，手交flag实在是很浪费时间的行为。虽然有时候自动化不太好写只能手交，像这次十分钟一轮，有72支队伍，就算你手速惊奇，也没有时间审计源码了。因此打AWD重点就在一个自动化。网上能找到各种框架，但是用的时候总是不顺手，遇到bug也不会修。只有自己写的才最好用。\n先说说用处最大的工具，就是批量攻击框架/自动化攻击脚本。这个框架主要有以下要素：\n 输入：  待攻击ip列表：通常写在ip.txt里 攻击函数：即封装好的payload请求 交flag函数：根据平台接口封装   输出：  批量攻击，输出攻击结果 攻击成功则提交 反馈得分结果    框架的核心无非以下逻辑：\n1 2 3 4 5 6 7 8  while True: for j in challenge_list: # 攻击函数索引 for i in ip_list: # 首先生成ip列表 flag = get_flag(i,j) # 根据j找到相应攻击函数 if flag!=\u0026#39;Attacked failed\u0026#39;: submit_flag(flag) print_result(j) time.sleep(round)   比赛时，找到漏洞或者抓到流量，立刻写好相应的攻击函数，重启脚本即可。\n为了提高稳定性和易用性，这套框架可以写的很复杂。比如：\n 加入多线程，让框架非阻塞的持续运行 加入面向对象，写成类库 自带一些trick，比如流量混淆器等。 当然，还可以写一个网站来可视化管理  这里就涉及框架编程了，能深挖的地方还有很多。\n除了批量攻击脚本，用到的脚本还有：\n 权限维持/批量shell脚本：用于管理多个shell  但是不死马被禁用，因此本次比赛中shell出现的不是很多。 （👴还准备了拿到白给shell之后持久化的脚本，结果一个shell都没拿到，准备个🔨。   文件监控脚本：用于监控flag等重要文件被读取和修改的准确时间，可以帮助确定payload  再牛逼一点还可以提供系统备份和回复功能。    上述都是系统脚本，大多在本机用python写的。下面说几种网页脚本，即直接用require/include包含的php脚本\n 流量监控脚本：区别于系统级流量监控，用于监控敏感流量以抓取payload 通防脚本：也就是waf，可以进行很充分的过滤  本次比赛中被禁用，因为确实破坏游戏体验    这些脚本，用好了才是趁手的兵器。这次比赛中👴的手速远不够快，延误了很多战机。\n🌊快进到《考试周破防》 回顾整场比赛，相比正经的漏洞挖掘，随机应变的能力对分数也有很大影响。总结几个因素：\n  awd的得分是随时间积累的，因此要掌控全局，时刻盯紧每道题有无薄弱环节和突破口。本次比赛题目数量多达7道，👴队有大佬没来，还带了一个萌新，约等于二打四，出现了看不过来题的情况。\n  还有就是手速，由于流量很及时，payload一被抓到，甚至可以在一轮check之内丢进批量攻击脚本，直接和首先挖掘到漏洞的队伍平分分数。这要求自动化脚本的熟练运用，尽量避免手交flag。\n  最后还有一点策略问题。分析三种题目状态，列个表定性分析一波最优解：\n      能反打 不能反打     场上大多数Attacked 先反打再修洞 不能修洞则down自己   场上大多数CheckDown 打他喵的 尽量别down     出现漏洞大部分人会被打，这时如果你不能立刻修补而能立刻反打，相当程度上是不亏的。如果你修不好也可以选择宕机，因为这样分摊了丢掉的分数。 尽量避免被打+被宕，扣双倍分数属实是血亏。如果决定宕机，先摸清check的时间和结算的时间，最好在新一轮结算后立即删站down自己。 当然，如果您能挖到洞，宁就是垂直上分的👴。  从8点半到6点半，打10个小时的AWD，要全程保持敏感和机智，确实对身体素质有些要求。👴坐高铁到合肥坐了6小时，打比赛坐了10小时，好悬没给我痔疮坐出来。晚上回到青岛并进行最后一次夜店，快进到《考试周破防》。\n","date":"2021-06-16T16:54:30Z","image":"https://lonelyuan.github.io/p/ciscn2021%E5%8D%8E%E4%B8%9C%E7%99%BE%E8%B5%9B%E5%8C%BA%E5%88%86%E5%8C%BA%E9%80%89%E6%8B%94%E8%B5%9Bawd%E5%A4%8D%E7%9B%98/awd-da-pian_hub2213acc3516fead069948e4c2b6c9af_78570_120x120_fill_q75_box_smart1.jfif","permalink":"https://lonelyuan.github.io/p/ciscn2021%E5%8D%8E%E4%B8%9C%E7%99%BE%E8%B5%9B%E5%8C%BA%E5%88%86%E5%8C%BA%E9%80%89%E6%8B%94%E8%B5%9Bawd%E5%A4%8D%E7%9B%98/","title":"CISCN2021华东百赛区分区选拔赛AWD复盘"},{"content":" 本文所述为计算机组成原理课拓展实验的相关记录，基于“龙芯体系结构与CPU设计教学实验系统” 项目官网： http://www.loongson.cn/business/general/teach/356.html； 相关资料代码：#TODO:: github仓库 PS：标题可简记为《基于基于的一种基于的一种实现》\n 🤓吐槽时间 快考试了，👴发觉👴计组学了个🔨，👴去年也学了个🔨，但是去年可以归因于晦气的晦气，今年只能说自己晦气。难道还要重蹈去年的晦气吗？👴本应该回去背课本，刷考研题，但是👴一看ppt就想起我们敬爱的《计算机组成原理》课的任课老师，丐哥反复强调的至理名言：“听不懂的举手（无停顿）都没举手，都听懂了，非常好。”本人十分钦佩丐哥老师对幽默感的独特理解。\n（但是特此声明：本人不了解、不认同其关于\u0026quot;5G是个几把\u0026quot;，\u0026ldquo;高晓松很nb这个人\u0026rdquo;，\u0026ldquo;钱=浪漫\u0026quot;等议题的看法）\n而且👴这人很怪，课本上的重点，不好玩；选做的实验，好玩！哎就是玩，怪不得卷不过别人，你也配卷？滚去考研吧。\n众所周知，计算机学生的本科生涯，如果能做到在自己设计的CPU上运行自己写的操作系统并用自己写的编译器跑代码，那就非常成功了。👴差不多，👴能在自己搜的代码上写自己的注释并用自己的电脑截图，都是三个\u0026quot;自己\u0026rdquo;。那么今天给大家爆个啥捏，流水线奥。\n🔧 “用”计算机→“造”计算机 上回书说到（#TODO:: CSAPP大篇），汇编器(as)让我们得到了机器能看懂的比特流，最后一步只需要连接器(ld)将其和其他调用一起载入内存。这回答了程序如何在CPU这个平台上运行的问题，然而一个更基本的问题是，这个现有的平台是如何实现的？一个粗略的认识是，我们知道这些足以实现CPU的复杂的逻辑，其最小单元总对应到简单的诸如逻辑门上面，但是落实到真正的物理实现之上，如何使效率最高？功耗最小？这些问题所跨越的复杂度的量级依然是一片巨大的迷雾。照亮这片迷雾的知识，大概隶属于IC学科。\nHowever，作为CS专业而不是IC专业，我们的目标仅在于理解所谓“组成原理”。在IC产业的复杂度规模数轴上，向下是专有芯片（又称嵌入式？），功能专用，规模较小；向上是通用芯片，即手机电脑等的核心，其难度不言而喻。位于中间的FPGA则既兼顾了自由度也考虑了速度，因此，这玩意能满足CS本科教学的需要（主要是便宜耐操）。\n🔮高贵的IC工程师都用啥轮子 Vivado是一个FPGA集成设计平台（也算一个EDA？），他主界面左侧的工作流窗口很好的概括了利用FPGA开发的基本流程。即\n 编写设计源码(Source)：使用Verilog语言编写逻辑或引入IP  设计仿真模拟(Simulation)：通过观察仿真波形图和编写testbench来对设计进行debug  综合(Systhesis)门级网表：从RTL级描述降维到门级网表  生成(Implementation)布局布线：根据管脚约束，将依然是虚拟的门级连线落实为实际的线路  进行硬件编程(program)：生成比特流并写入目标设备           名词解释： IC：集成电路 FPGA：现场可编程门阵列 Verilog：一种硬件描述语言，语法涵盖了自顶向下五个抽象层面：系统级、算法级、RTL级、门级、开关级。 RTL：寄存器传输级。一般使用最多的就是RTL级。 IP：Intellectual Property内核模块，可以理解为将代码封装为函数。分为，软IP内核(soft IP core)，固IP内核(firm IP core)和硬IP内核(hard IP core)3个层次，相当于集成电路的毛坯、半成品和成品。 SoC：片上系统，大概是芯片及其装载的第一层软件接口的集合，很宽泛的概念。 EDA：电子设计自动化。\n 由此，我们可以大致探清了这片迷雾，CPU的设计如何从高抽象层次的逻辑，梳理成最底层的逻辑门，再实现为小小的芯片。那么我们有了轮子，要造一个CPU，还要确定目标指令集。由于本项目由龙芯公司赞助，那必然要选MIPS了。\n📌MIPS指令集格式 啥叫指令集呢，学过几种语言就不难理解。高级程序语言规定每个ascii码的组合所对应的含义，指令集规定0和1的组合所对应的寄存器，ALU的各种信号。MIPS指令集从属于RISC系列，最基本的指令有31条。\n//讲到这里本应该打个表展示31条指令，但是👴懒得打了。\nVivado中，.coe文件用于初始化IP核，本实验给出的.coe文件中存放了几条指令，不过是16进制数字，写个小脚本打印成可读的形式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  # mips_dump.py with open(path,\u0026#39;r\u0026#39;) as f: hex_list = f.read().split(\u0026#39;\\n\u0026#39;) bin_list = list(map(lambda x:bin(int(x,16)),hex_list)) # bin_code_list = [\u0026#34;{:0\u0026gt;32}\u0026#34;.format(i[2:],\u0026#39;b\u0026#39;) for i in bin_list] bin_code_list = [i[2:].zfill(32) for i in bin_list] IType_op_dict = { \u0026#39;001000\u0026#39;:\u0026#39;addi\u0026#39;, \u0026#39;001001\u0026#39;:\u0026#39;addiu\u0026#39;, \u0026#39;001100\u0026#39;:\u0026#39;ori\u0026#39;, \u0026#39;001101\u0026#39;:\u0026#39;xori\u0026#39;, \u0026#39;001111\u0026#39;:\u0026#39;lui\u0026#39;, \u0026#39;100011\u0026#39;:\u0026#39;lw\u0026#39;, \u0026#39;101011\u0026#39;:\u0026#39;sw\u0026#39;, \u0026#39;000100\u0026#39;:\u0026#39;beq\u0026#39;, \u0026#39;000101\u0026#39;:\u0026#39;bne\u0026#39;, \u0026#39;001010\u0026#39;:\u0026#39;slti\u0026#39;, \u0026#39;001011\u0026#39;:\u0026#39;sltiu\u0026#39; } RType_func_dict = { \u0026#39;100000\u0026#39;:\u0026#39;add\u0026#39;, \u0026#39;100001\u0026#39;:\u0026#39;addu\u0026#39;, \u0026#39;100010\u0026#39;:\u0026#39;sub\u0026#39;, \u0026#39;100011\u0026#39;:\u0026#39;subu\u0026#39;, \u0026#39;100100\u0026#39;:\u0026#39;and\u0026#39;, \u0026#39;100101\u0026#39;:\u0026#39;or\u0026#39;, \u0026#39;100110\u0026#39;:\u0026#39;xor\u0026#39;, \u0026#39;100111\u0026#39;:\u0026#39;nor\u0026#39;, \u0026#39;101010\u0026#39;:\u0026#39;slt\u0026#39;, \u0026#39;101011\u0026#39;:\u0026#39;sltu\u0026#39;, \u0026#39;000000\u0026#39;:\u0026#39;sll\u0026#39;, \u0026#39;000010\u0026#39;:\u0026#39;srl\u0026#39;, \u0026#39;000011\u0026#39;:\u0026#39;sra\u0026#39;, \u0026#39;000100\u0026#39;:\u0026#39;sllv\u0026#39;, \u0026#39;000110\u0026#39;:\u0026#39;srlv\u0026#39;, \u0026#39;000111\u0026#39;:\u0026#39;srav\u0026#39;, \u0026#39;001000\u0026#39;:\u0026#39;jr\u0026#39;, } def f_hex(ori, width): # bin-\u0026gt;hex return \u0026#34;0x\u0026#34;+hex(int(ori,2))[2:].zfill(width) def f_reg(ori): # print register num return \u0026#34;$\u0026#34;+str(int(ori,2)).zfill(2) def code_dump(type:str,inst:str,params:list): if type == \u0026#39;R\u0026#39;: s = inst.ljust(6) + \u0026#34;, \u0026#34;.join([f_reg(params[0]),f_reg(params[1]),f_reg(params[2]),f_hex(params[3],2)]) elif type == \u0026#39;I\u0026#39;: s = inst.ljust(6) + \u0026#34;, \u0026#34;.join([f_reg(params[0]),f_reg(params[1]),f_hex(params[2],8)]) else: s = inst.ljust(6) +\u0026#39;0x\u0026#39;+ hex(int(params[0],2))[2:].zfill(8) return s assembly_list = [] for _ in bin_code_list: op = _[:6] # public field try: if op == \u0026#39;000000\u0026#39;: # R-Type rs = _[6:11] rt = _[11:16] rd = _[16:21] shamt = _[21:26] func = _[26:] assembly_list.append(code_dump(\u0026#39;R\u0026#39;,RType_func_dict[func],[rs,rt,rd,shamt])) elif op in [\u0026#39;000010\u0026#39;, \u0026#39;000011\u0026#39;]: # J-Type target = _[6:] assembly_list.append(code_dump(\u0026#39;J\u0026#39;,\u0026#39;j\u0026#39;,[target])) else: # I-Type rs = _[6:12] rt = _[12:18] imm = _[18:] assembly_list.append(code_dump(\u0026#39;I\u0026#39;,IType_op_dict[op],[rs, rt, imm])) except Exception as e: assembly_list.append(\u0026#34;***** decode error! *****\u0026#34;) head = \u0026#34;+---hexdump----|--------- assembly ---------+\u0026#34; print(head) addr = 0 for i in range(len(bin_code_list)): print(\u0026#34;|\u0026#34;+ f_hex(bin(addr),2) +\u0026#34; \u0026#34;+ hex_list[i] +\u0026#34; | \u0026#34;+ assembly_list[i].ljust(26) + \u0026#34; |\u0026#34;) addr += 4 tail = \u0026#34;+\u0026#34;+\u0026#34;-\u0026#34;*43+\u0026#34;+\u0026#34; print(tail)   打印出来👴傻了，怎么还有不在31条范围里的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  +---hexdump----|--------- assembly ---------+ |0x00 24010001 | addiu $00, $04, 0x00000001 | |0x04 00011100 | sll $00, $01, $02, 0x04 | |0x08 00411821 | addu $02, $01, $03, 0x00 | |0x0c 00022082 | srl $00, $02, $04, 0x02 | |0x10 28990005 | slti $09, $36, 0x00000005 | |0x14 07210010 | ***** decode error! ***** | |0x18 00642823 | subu $03, $04, $05, 0x00 | |0x1c AC050014 | sw $00, $20, 0x00000014 | |0x20 00A23027 | nor $05, $02, $06, 0x00 | |0x24 00C33825 | or $06, $03, $07, 0x00 | |0x28 00E64026 | xor $07, $06, $08, 0x00 | |0x2c AC08001C | sw $00, $32, 0x0000001c | |0x30 11030002 | beq $16, $12, 0x00000002 | |0x34 00C7482A | slt $06, $07, $09, 0x00 | |0x38 24010008 | addiu $00, $04, 0x00000008 | |0x3c 8C2A0014 | lw $02, $40, 0x00000014 | |0x40 15450004 | bne $20, $20, 0x00000004 | |0x44 00415824 | and $02, $01, $11, 0x00 | |0x48 AC2B001C | sw $02, $44, 0x0000001c | |0x4c AC240010 | sw $02, $16, 0x00000010 | |0x50 0C000019 | j 0x00000019 | |0x54 3C0C000C | lui $00, $48, 0x0000000c | |0x58 004CD007 | srav $02, $12, $26, 0x00 | |0x5c 003AD804 | sllv $01, $26, $27, 0x00 | |0x60 0360F809 | ***** decode error! ***** | |0x64 A07A0005 | ***** decode error! ***** | |0x68 0063682B | sltu $03, $03, $13, 0x00 | |0x6c 1DA00003 | ***** decode error! ***** | |0x70 00867004 | sllv $04, $06, $14, 0x00 | |0x74 000E7883 | sra $00, $14, $15, 0x02 | |0x78 002F8006 | srlv $01, $15, $16, 0x00 | |0x7c 1A000008 | ***** decode error! ***** | |0x80 002F8007 | srav $01, $15, $16, 0x00 | |0x84 240B008C | addiu $00, $44, 0x0000008c | |0x88 06000006 | ***** decode error! ***** | |0x8c 8D5C0003 | lw $21, $48, 0x00000003 | |0x90 179D0007 | bne $57, $52, 0x00000007 | |0x94 A0AF0008 | ***** decode error! ***** | |0x98 80B20008 | ***** decode error! ***** | |0x9c 90B30008 | ***** decode error! ***** | |0xa0 2DF8FFFF | sltiu $31, $35, 0x00003fff | |0xa4 0185E825 | or $12, $05, $29, 0x00 | |0xa8 01600008 | jr $11, $00, $00, 0x00 | |0xac 31F4FFFF | ori $31, $19, 0x00003fff | |0xb0 35F5FFFF | xori $31, $23, 0x00003fff | |0xb4 39F6FFFF | ***** decode error! ***** | |0xb8 08000000 | j 0x00000000 | +-------------------------------------------+   总之，代码都给你了，下面给出一个vivado实验的完整流程，不全面，但是都是踩坑经验。\n🆒Vivado使用 本流程环境：Vivado 2020.2\n开发板型号：LS-CPU-EXB-1\n创建项目 下一步，下一步，下一步，，，确认。 这一步只需要注意选器件，一定要选对。否则有可能在Implementation遇到“端口电平不匹配”“端口数量不足”等硬件问题。当然，有可能型号相近的性能规格也差不多，这属于玄学问题了。实验书上选择的的型号应该是“xc7a200tfbg676-2”，但是👴用的是“xc7a200tfbv676-2”也能成功写入比特流。\n编写代码并仿真 本实验的代码大多来自“2016-04-14”，那就是龙芯公司给的源代码。在该系列代码中有一处bug，位于“单周期CPU实验”的single_cycle_cpu.v中。214行，resetn应该为{4{resetn}}，写使能位宽应为为4。 下面讲解一下项目结构，所有实验都是类似的： 三个顶层文件夹分别对应Add Source里的三类源文件：添加设计，添加仿真，添加约束。如果不需要上板，只完成仿真，那么只需要添加设计（几个.v），添加仿真（testbench.v/tb.v）就足够了，xxx_display.v也是上板需要的故而可以忽略。（实际上，图中我用箭头标记的都用不到）。\n编写tb，无非是给tb里声明为input的信号赋值，还可以使用#xx，让tb等待一段时间。\n点击Run Simulation，等一会就能看到波形图。波形图有三种颜色：\n 绿色代表信号正常正常； 红色的X代表信号不确定； 蓝色的Z代表信号休眠。  一般遇到红X，都是未初始化问题。蓝Z大概是没有模块调用这些信号。Vivado波形图的操作极其难用，这里介绍一个相对好用的操作：左键从左向右水平划，会直接缩放到鼠标滑过的这一段。右键选择进制等操作略。\n仿真需要注意的问题：\n 如果文件没问题，模块调用层次会被自动解析从而呈现成一棵树，而不是好几个顶层文件。 注意set as top，应该设为根部模块（调用其他模块的）和tb  //如果设错了可能在Implementation会出现“端口未赋初值”的报错。   中文乱码是经典字符集问题，有可能在换行处导致语法错误。建议统一换成utf-8。  简单解决方法：从vscode里复制。    引入IP核 对于流水线CPU，data_ram和inst_rom需要同步写，自己实现比较复杂，故直接实例化封装好的内存块IP。如何引入？首先说明几种文件格式：\n .dcp 原意为checkpoints文件，是一种加密压缩文件。用于封装模块方便调用，但对版本要求极其敏感。 .xci/.xcix IP核配置文件，本质是一个xml。是Vivado在新版本提倡使用xci而不是dcp。 .xdc 管脚约束文件。在Implementation用到，此处按下不表。  这几种文件格式都是可以直接Add Source添加进来的。实验老师同时提供dcp和xci文件，添加dcp崩屎了，原因估计如上。添加xci之后，提示我将IP更新为core cointainer的形式\n更新就完了。然后需要等一会，IP还要执行一步synth，这段时间里IP属于锁住的状态，不能修改配置。\n注意更换器件后，IP核都会锁住。这表示IP的配置和当前环境不匹配。对所有IP锁住的问题，只需要点击菜单栏Reports→Reports IP Status，然后点upgrade即可解除锁定。\n我直接上板 直接点生成比特流，会一步步的按工作流向下运行，等待几分钟就能愉快的收获你的报错了！\n在把上文提到的坑都踩过一遍之后，终于没有critical warning，泪目。\n但是此时实验课已经结束了，👴偷溜到没人的实验室，并留下以下珍贵画面\n然后👴发现data_ram写入失败。但是👴没时间搞了，👴还是滚去复习课本吧。\n🗿多周期流水线CPU原理 最后，继续复习计组。\n","date":"2021-06-09T17:14:19Z","image":"https://lonelyuan.github.io/p/%E5%9F%BA%E4%BA%8Evivado%E7%9A%84%E5%9F%BA%E4%BA%8Efpga%E7%9A%84%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8Emips%E7%9A%84%E4%B8%80%E7%A7%8D%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B3%A8%E9%87%8A/mips_pipeline_cpu_hu41671eab994e10b990ecc8a898c73896_308650_120x120_fill_q75_box_smart1.jfif","permalink":"https://lonelyuan.github.io/p/%E5%9F%BA%E4%BA%8Evivado%E7%9A%84%E5%9F%BA%E4%BA%8Efpga%E7%9A%84%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8Emips%E7%9A%84%E4%B8%80%E7%A7%8D%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B3%A8%E9%87%8A/","title":"基于vivado的基于FPGA的一种基于MIPS的一种五级流水线CPU实现的注释"},{"content":"// 笑死，根本赢不了。受不鸟，直接投降~\n0x01 | 拖延症的生理基础\n0x02 | 对拖延症的方法论综述\n0x03 | 西西弗斯计划\n","date":"2021-04-15T23:01:29Z","image":"https://lonelyuan.github.io/p/%E6%88%91%E5%92%8C%E6%8B%96%E5%BB%B6%E7%97%87%E7%9A%84%E6%88%98%E4%BA%89/ProcrastinationWar_hu0b75bf0afc945e74174c5a743bf06a5b_26480_120x120_fill_q75_box_smart1.jfif","permalink":"https://lonelyuan.github.io/p/%E6%88%91%E5%92%8C%E6%8B%96%E5%BB%B6%E7%97%87%E7%9A%84%E6%88%98%E4%BA%89/","title":"我和拖延症的战争"},{"content":"CSAPP：Bomblab 逆向的传统艺能拆炸弹，👴的青春回来了。\n文件结构：\n1 2 3 4  bomb ├── README ├── bomb └── bomb.c   只有一个程序，给的源码基本没用，我们要用逆向工程的方法理解程序，找到正确的字符串。\n讲反汇编器的结果导出：objdump -d bomb \u0026gt; bomb.txt\n可以看到有6关，每一关接受一个字符串，若跳转到explode_bomb函数，则答案错误。\n第一关：字符串比较 1 2 3 4  0000000000400ee0 \u0026lt;phase_1\u0026gt;: 400ee0:\t48 83 ec 08 sub $0x8,%rsp 400ee4:\tbe 00 24 40 00 mov $0x402400,%esi 400ee9:\te8 4a 04 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt;   逻辑是直接比较字符串是否相等，不过$0x402400不是程序内地址，说明答案被藏在了我们看不到的内存位置。\n于是上GDB，在\u0026lt;phase_1\u0026gt;下断点，stepi单步执行到callq之前，查看寄存器:x\\s $esi，得到答案。（每台电脑的答案都不一样）\n第二关：循环 1 2 3 4 5 6  0000000000400efc \u0026lt;phase_2\u0026gt;: 400efc:\t55 push %rbp //压栈 400efd:\t53 push %rbx 400efe:\t48 83 ec 28 sub $0x28,%rsp //开辟栈帧 400f02:\t48 89 e6 mov %rsp,%rsi//栈顶地址→rsi参数二 400f05:\te8 52 05 00 00 callq 40145c \u0026lt;read_six_numbers\u0026gt;   如函数名所示，读6个数字，为什么是6呢，大概是因为存放参数的寄存器总共有6个吧。（然而并不）\n可以看到调用前开辟了0x28的栈上空间，足够存放6个整数。栈顶地址被存入%rsi，以此传递该地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  000000000040145c \u0026lt;read_six_numbers\u0026gt;: //%rsi:父进程\u0026lt;phase_2\u0026gt;的栈顶地址 40145c:\t48 83 ec 18 sub $0x18,%rsp //栈帧长24 401460:\t48 89 f2 mov %rsi,%rdx //rsi→参数三：num1 401463:\t48 8d 4e 04 lea 0x4(%rsi),%rcx //rsi+4→参数四：num2 401467:\t48 8d 46 14 lea 0x14(%rsi),%rax //rsi+20→rax 40146b:\t48 89 44 24 08 mov %rax,0x8(%rsp) //rax→栈顶+8：num6 401470:\t48 8d 46 10 lea 0x10(%rsi),%rax //rsi+16→rax 401474:\t48 89 04 24 mov %rax,(%rsp) //rax→栈顶：num5 401478:\t4c 8d 4e 0c lea 0xc(%rsi),%r9 //rsi+12→参数六：num4 40147c:\t4c 8d 46 08 lea 0x8(%rsi),%r8 //rsi+8→参数五：num3 401480:\tbe c3 25 40 00 mov $0x4025c3,%esi//0x4025c3:\u0026#34;%d %d %d %d %d %d\u0026#34; 401485:\tb8 00 00 00 00 mov $0x0,%eax //返回值赋0 40148a:\te8 61 f7 ff ff callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; //sscanf() 40148f:\t83 f8 05 cmp $0x5,%eax //返回值和5比较，即输入6个值才能通过 401492:\t7f 05 jg 401499 \u0026lt;read_six_numbers+0x3d\u0026gt; 401494:\te8 a1 ff ff ff callq 40143a \u0026lt;explode_bomb\u0026gt; 401499:\t48 83 c4 18 add $0x18,%rsp //出栈 40149d:\tc3 retq   看\u0026lt;read_six_numbers\u0026gt;，%rsi中的地址以4为步长被分别储存。猜测sscanf函数的返回值中，第一个表示输入参数的个数；程序要求6个输入，加上rsi被占用，于是多的两个存入栈中。且sscanf函数的返回值按参数寄存器（多的地址在栈上）存放的地址传输，即输入值被按顺序存入phase_2的栈帧中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  400f0a:\t83 3c 24 01 cmpl $0x1,(%rsp) //栈顶位置取双字和1比较 400f0e:\t74 20 je 400f30 \u0026lt;phase_2+0x34\u0026gt; 400f10:\te8 25 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 400f17:\t8b 43 fc mov -0x4(%rbx),%eax //循环头：num1→eax 400f1a:\t01 c0 add %eax,%eax // eax*2 400f1c:\t39 03 cmp %eax,(%rbx) //和num2比较 400f1e:\t74 05 je 400f25 \u0026lt;phase_2+0x29\u0026gt; //相等才通过 400f20:\te8 15 05 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 400f25:\t48 83 c3 04 add $0x4,%rbx //rbx增4 400f29:\t48 39 eb cmp %rbp,%rbx //rbx和rsp+24比较，相等则跳出 400f2c:\t75 e9 jne 400f17 \u0026lt;phase_2+0x1b\u0026gt; //循环尾，循环共6轮 400f2e:\teb 0c jmp 400f3c \u0026lt;phase_2+0x40\u0026gt; 400f30:\t48 8d 5c 24 04 lea 0x4(%rsp),%rbx //num2地址→rbx 400f35:\t48 8d 6c 24 18 lea 0x18(%rsp),%rbp//rbx地址→rbp 400f3a:\teb db jmp 400f17 \u0026lt;phase_2+0x1b\u0026gt; //开始循环   跳出\u0026lt;read_six_numbers\u0026gt;后，首先检查栈顶地址指向的值是否为1，即第一个数字是1。\n之后进入循环，循环体每次都会把当前数字*2和下一个数字比较，即每个数字都是前一个的二倍；%rbx作计数变量，共循环6次。答案呼之欲出。\n第三关：分支 1 2 3 4 5 6 7 8 9 10 11 12 13 14  0000000000400f43 \u0026lt;phase_3\u0026gt;: 400f43:\t48 83 ec 18 sub $0x18,%rsp 400f47:\t48 8d 4c 24 0c lea 0xc(%rsp),%rcx //rsp+12→rcx: mun2 400f4c:\t48 8d 54 24 08 lea 0x8(%rsp),%rdx //rsp+8→rdx: mun1 400f51:\tbe cf 25 40 00 mov $0x4025cf,%esi //0x4025cf: \u0026#34;%d %d\u0026#34; 400f56:\tb8 00 00 00 00 mov $0x0,%eax 400f5b:\te8 90 fc ff ff callq 400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 400f60:\t83 f8 01 cmp $0x1,%eax //不少于一个输入 400f63:\t7f 05 jg 400f6a \u0026lt;phase_3+0x27\u0026gt; 400f65:\te8 d0 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 400f6a:\t83 7c 24 08 07 cmpl $0x7,0x8(%rsp) // 400f6f:\t77 3c ja 400fad \u0026lt;phase_3+0x6a\u0026gt; //超过7则爆炸 400f71:\t8b 44 24 08 mov 0x8(%rsp),%eax //取num1 400f75:\tff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8)   此处*相当于c中的取地址符\u0026amp;，\n1 2 3  400f7c:\tb8 cf 00 00 00 mov $0xcf,%eax 400f81:\teb 3b jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; ······   这里有7段形式重复的代码，结合第一个数字不能大于7，猜测这里是switch型结构。\n1 2 3 4 5 6 7 8 9  400fad:\te8 88 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 400fb2:\tb8 00 00 00 00 mov $0x0,%eax 400fb7:\teb 05 jmp 400fbe \u0026lt;phase_3+0x7b\u0026gt; 400fb9:\tb8 37 01 00 00 mov $0x137,%eax 400fbe:\t3b 44 24 0c cmp 0xc(%rsp),%eax //比较num2和eax 400fc2:\t74 05 je 400fc9 \u0026lt;phase_3+0x86\u0026gt; 400fc4:\te8 71 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 400fc9:\t48 83 c4 18 add $0x18,%rsp 400fcd:\tc3 retq   第二个数字是%eax的值，由第一个数决定。故答案有7个。\n第四关：递归 1 2 3 4 5 6 7 8 9 10 11  000000000040100c \u0026lt;phase_4\u0026gt;: ...... 401029:\t83 f8 02 cmp $0x2,%eax //只能有2参数 40102c:\t75 07 jne 401035 \u0026lt;phase_4+0x29\u0026gt; 40102e:\t83 7c 24 08 0e cmpl $0xe,0x8(%rsp) //0 \u0026lt;= num1 \u0026lt;= 14 401033:\t76 05 jbe 40103a \u0026lt;phase_4+0x2e\u0026gt; 401035:\te8 00 04 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 40103a:\tba 0e 00 00 00 mov $0xe,%edx 40103f:\tbe 00 00 00 00 mov $0x0,%esi 401044:\t8b 7c 24 08 mov 0x8(%rsp),%edi //num1→edi 401048:\te8 81 ff ff ff callq 400fce \u0026lt;func4\u0026gt; //   输入规则和上一关一样，第一个数需在0到14之间（cmpl只能用于无符号数？）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  0000000000400fce \u0026lt;func4\u0026gt;: //首次调用时：%eax:0x2 %ebx:0 %ecx:0 %edx:0xe %esi:0x0 %edi:num1 400fce:\t48 83 ec 08 sub $0x8,%rsp 400fd2:\t89 d0 mov %edx,%eax //eax:14 400fd4:\t29 f0 sub %esi,%eax //eax:14-0 400fd6:\t89 c1 mov %eax,%ecx //ecx:14 400fd8:\tc1 e9 1f shr $0x1f,%ecx //ecx:0 //逻辑右移31，即取符号位。 400fdb:\t01 c8 add %ecx,%eax //eax:14+0 400fdd:\td1 f8 sar %eax //算术右移1位？eax:14/2=7 400fdf:\t8d 0c 30 lea (%rax,%rsi,1),%ecx //ecx:7+0 400fe2:\t39 f9 cmp %edi,%ecx //比较num1和7 400fe4:\t7e 0c jle 400ff2 \u0026lt;func4+0x24\u0026gt; //不大于→r17 400fe6:\t8d 51 ff lea -0x1(%rcx),%edx //edx:ecx-1=6 400fe9:\te8 e0 ff ff ff callq 400fce \u0026lt;func4\u0026gt; //递归→r3 400fee:\t01 c0 add %eax,%eax 400ff0:\teb 15 jmp 401007 \u0026lt;func4+0x39\u0026gt; //跳出 400ff2:\tb8 00 00 00 00 mov $0x0,%eax 400ff7:\t39 f9 cmp %edi,%ecx //比较num1和7 400ff9:\t7d 0c jge 401007 \u0026lt;func4+0x39\u0026gt; //不小于 400ffb:\t8d 71 01 lea 0x1(%rcx),%esi //esi:ecx+1=8 400ffe:\te8 cb ff ff ff callq 400fce \u0026lt;func4\u0026gt; //递归→r3 401003:\t8d 44 00 01 lea 0x1(%rax,%rax,1),%eax //eax=2*eax+1 401007:\t48 83 c4 08 add $0x8,%rsp 40100b:\tc3 retq   前面一通算术操作，后面设计了递归。\n这里一步移位操作看起来像是取符号位，但是输入一定大于0，符号位是0，所以这个操作意义何在？\n人肉IDA走起：\n1 2 3 4 5 6 7 8 9  int fun4(int num1,int x,int y){ int s,a; s=(x-y)/2+y; if(num1\u0026gt;s)\treturn 2*fun4(num1,s-1,y); a=0; if(num1\u0026lt;s)\treturn 2*fun4(num1,x,s+1)+1; return a; } fun4(num1,14,0);   第一个数设为7可避免递归调用，但返回值不是0，不符合。\n1 2 3 4 5 6 7  40104d:\t85 c0 test %eax,%eax //eax=0 40104f:\t75 07 jne 401058 \u0026lt;phase_4+0x4c\u0026gt;//不等于0爆炸 401051:\t83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) //mun2和0比较？ 401056:\t74 05 je 40105d \u0026lt;phase_4+0x51\u0026gt;//不等于0爆炸 401058:\te8 dd 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 40105d:\t48 83 c4 18 add $0x18,%rsp 401061:\tc3 retq   看到的返回值和num2皆需为0，则num2确定。\n大不了爆破呗，索性试了1次就成了。emm\n第五关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  0000000000401062 \u0026lt;phase_5\u0026gt;: 401062:\t53 push %rbx 401063:\t48 83 ec 20 sub $0x20,%rsp 401067:\t48 89 fb mov %rdi,%rbx 40106a:\t64 48 8b 04 25 28 00 mov %fs:0x28,%rax //??? 401073:\t48 89 44 24 18 mov %rax,0x18(%rsp) 401078:\t31 c0 xor %eax,%eax //eax:0 40107a:\te8 9c 02 00 00 callq 40131b \u0026lt;string_length\u0026gt; 40107f:\t83 f8 06 cmp $0x6,%eax //输入长度为6 401082:\t74 4e je 4010d2 \u0026lt;phase_5+0x70\u0026gt; 401084:\te8 b1 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 401089:\teb 47 jmp 4010d2 \u0026lt;phase_5+0x70\u0026gt; 40108b:\t0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //循环头。新指令 40108f:\t88 0c 24 mov %cl,(%rsp) 401092:\t48 8b 14 24 mov (%rsp),%rdx 401096:\t83 e2 0f and $0xf,%edx 401099:\t0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //？？？ 4010a0:\t88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4:\t48 83 c0 01 add $0x1,%rax //计数变量rax 4010a8:\t48 83 f8 06 cmp $0x6,%rax //循环6轮 4010ac:\t75 dd jne 40108b \u0026lt;phase_5+0x29\u0026gt; //循环尾 4010ae:\tc6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3:\tbe 5e 24 40 00 mov $0x40245e,%esi //？？ 4010b8:\t48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd:\te8 76 02 00 00 callq 401338 \u0026lt;strings_not_equal\u0026gt; 4010c2:\t85 c0 test %eax,%eax 4010c4:\t74 13 je 4010d9 \u0026lt;phase_5+0x77\u0026gt; 4010c6:\te8 6f 03 00 00 callq 40143a \u0026lt;explode_bomb\u0026gt; 4010cb:\t0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) //？？？ 4010d0:\teb 07 jmp 4010d9 \u0026lt;phase_5+0x77\u0026gt;//跳出 4010d2:\tb8 00 00 00 00 mov $0x0,%eax 4010d7:\teb b2 jmp 40108b \u0026lt;phase_5+0x29\u0026gt; 4010d9:\t48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de:\t64 48 33 04 25 28 00 xor %fs:0x28,%rax //？？？ 4010e7:\t74 05 je 4010ee \u0026lt;phase_5+0x8c\u0026gt; 4010e9:\te8 42 fa ff ff callq 400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 4010ee:\t48 83 c4 20 add $0x20,%rsp 4010f2:\t5b pop %rbx 4010f3:\tc3 retq   第六关 隐藏关 隐藏关藏在每一关的后面，\nGDB使用： 基础：\n1 2 3 4 5  q : quit h : help file prog//加载程序，也可作为gdb命令的参数 r : run k : kill   断点：\n1 2 3 4 5 6 7 8 9 10  b : breakpoints break - func_name - *0x400522 - \u0026amp;var - main.c:100//源代码断点，运行前即可 - if con//条件断点 w : watch //观察对象变化时断点 d : delete - b n disable b n   执行：\n1 2 3 4 5 6  c : continue f : finish stepi n nexti set args ./a.txt //从文件读取输入   检查代码：\n1 2 3 4 5 6  disas //展示汇编 - funcname - 0x400000 - list edit   检查数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  x : examine p : print 格式控制：/[n][f][u] - n:内存单元个数 - f:显示格式： - x(hex) 按十六进制格式显示变量。 - d(decimal) 按十进制格式显示变量。 - u(unsigned decimal) 按十进制格式显示无符号整型。 - o(octal) 按八进制格式显示变量。 - t(binary) 按二进制格式显示变量。 - a(address) 按十六进制格式显示变量。 - c(char) 按字符格式显示变量。 - f(float) 按浮点数格式显示变量 - u:单元长度（按字节） i : info - r : registers - b [n] - $rsp   表达式：\n1    堆栈：\n1  bt : backtrace//显示堆栈   ","date":"2020-02-27T22:43:31Z","permalink":"https://lonelyuan.github.io/p/csapp-bomblab/","title":"CSAPP - Bomblab"},{"content":"CSAPP：datalab 读，就硬读。光读没用，得做练习。这个系列记录思路不写答案。\n拿到文件夹先读README。\n第一个lab，关于位运算。通过受限制的c语言编程实现函数功能。\n直接读bits.c，里面有全部信息。每次测试程序都要先make一下。\n  1：只用按位与和非实现异或   1 2 3 4 5 6 7  /* * bitXor - x^y using only ~ and \u0026amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026amp; * Max ops: 14 * Rating: 1 */   \u0026amp;=全为1\n~\u0026amp;=不全为1\n异或=不全为0且不全为1，按此逻辑组合即可。\n你让我用括号了？？？\n反思：浪费时间，与和或傻傻分不清楚\n  2：位运算取补码的最小值   英语时间：补码（two\u0026rsquo;s complement）反码：（one\u0026rsquo;s complement）。结合公式很好理解\n1 2 3 4 5 6  /* * tmin - return minimum two\u0026#39;s complement integer * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 4 * Rating: 1 */   补码公式： $$ B2T_w(\\vec{x})=-x_{w-1}+\\sum^{w-2}_{i=0}x_i2^i $$ 最高位是符号位，要求最小值，则最高位为负1，其他位为0。\n由于题目限制，只能使用最大为0xff的数字和位运算符，又int长度为4*8=32，故对0x1左移31即得。\n  3：判断一个数是否为补码的最大值   1 2 3 4 5 6 7  /* * isTmax - returns 1 if x is the maximum, two\u0026#39;s complement number, * and 0 otherwise //0=1111 1111=0000 0000 * Legal ops: ! ~ \u0026amp; ^ | + * Max ops: 10 * Rating: 1 */   最大值：符号位0，其他位1，即max=011111\u0026hellip;=0x7fffffff。\n!0=1，故应使每一位化为0，再取非即为1；其他任何数取非都为0。\n注意到max+1=~max，补码max加一得到其反码。反码相加得11111111，取反即得0。\n特例：-1 = 0x1111 1111也有这个性质，故须排除。\n寻找另一性质：!(max+1)=0，而!(-1+1)=1，结合上一步结果即可。\n反思：逻辑非！和按位非~\n  4：判断所有奇数位为1   1 2 3 4 5 6 7 8  /* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 12 * Rating: 2 */   要取奇数位，首先构造掩码：0xaaaaaaaa，用\u0026amp;取出奇数位，再异或，取反即得。\n错误示范： m=0xaa;m+=m\u0026lt;\u0026lt;8;m+=m\u0026lt;\u0026lt;8;m+=m\u0026lt;\u0026lt;8;算出来个啥？\n  5：取相反数   1 2 3 4 5 6 7  /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 5 * Rating: 2 */   常识？？？反码加1\n大佬题解：https://wdxtub.com/csapp/thick-csapp-lab-1/2016/04/16/\nhttps://zhuanlan.zhihu.com/p/59534845题不一样？？？\n","date":"2020-01-21T00:00:03Z","permalink":"https://lonelyuan.github.io/p/csapp-datalab/","title":"CSAPP - datalab"},{"content":"那个男孩不想玩人工智能呢？在玄学修bug之后，我终于跑通了jetbot自带的深度学习demo。\n怎样才能让ai程序发挥好的效果呢？众所周知，所谓人工智能，有多少人工就有多智能。\nAI的发展离不开三个要素：算力，算法和算材。根据摩尔定律，算力的发展是不会停滞的（虽然定律快失效了）；进几年来的AI热正是算法的突破，即深度学习相关算法的突飞猛进；而算材就是用来训练模型的数据，未来几年AI应用的进一步落地离不开算材的进一步开发（中国在AI方面的最大优势正在于此）。数据集的丰富程度和有效程度直接影响了AI应用的效果，我将在下文详细说明。\n在jetbot项目中，我们也能体验到用“人工”换“智能”的快乐。作为视觉识别类的AI应用，我们要在预设环境里创建数据集，并为其标注。有了数据集，jetbot搭载的NVIDIA牌GPU在方寸之间就能完成海量计算，仅用一颗摄像头就能实现自动避障，目标追踪，自动巡线等等炫酷功能！不要1999，也不要999，只要99！99刀NVIDIA计算卡带回家！（妮维雅打钱）\n 给萌新理清几个概念：\n人工智能，机器学习，深度学习的关系：\n 深度学习：一种实现机器学习的技术；机器学习：一种实现人工智能的方法 【包含关系图】  AI的发展路径：\n 弱AI：单独领域工作效率超过人类→ 通用AI：可以广泛应用于大部分领域→ 强AI：有自主意识，即将灭绝人类（不是）→  现在AI发展到什么地步了：弱AI，有生之年可能见到通用AI\n 推荐一波汉化的很好的wiki，也有自己原创的内容：http://www.waveshare.net/wiki/JetBot_AI_Kit\n本篇详细介绍两个demo的代码和可能遇到的问题，最后附上神经网络的入门笔记。同样是初次接触，大佬请绕道。\ndemo1：自动避障 小车如何实现自动避障的呢？用通俗的不能再通俗的说法，AI程序通过学习你给他的数据集，知道了什么样的图像是死路，什么样的图像是通路。得到新图像时就能判断是死路的概率有多少，在程序里可以很简单的看出，当这个概率大于0.5的时候就触发小车转向。\n具体而言，你要在你的环境里拍至少200张照片，100张标记为通路（free），100张标记为死路（blocked）。这便是你的数据集（dataset）。构建数据集的时候尽量分散在环境的各个位置和各个方向，可以沿边界环绕一圈，走一段距离停下，转一圈，收集8-10张图片。反正你的数据越多，标记的越准确，模型效果越好。\n下一步就开始训练模型了，从代码里看出，这个demo使用AlexNet模型，用pytorch实现（废话）。第一次运行你会下载一个244M左右的大文件，在/home/jetbot/.torch/models目录下会看到这个.pth文件。这便是AlexNet了。\n继续运行程序，完整的输出结果有三十行，每行后面的小数代表当前模型的准确度（？），程序最后会从这30个模型中选取准确度最高的作为最终模型，也是一个pth文件：best_model.pth\n下载文件和训练模型都需要花挺长时间，看到kernel busy，也就是右上角的大黑点不要轻易打断。\n什么是模型呢？稍微解释一下机器学习的概念。\n模型就是函数，其要素为输入，输出，和变换关系。举例说明：\n   模型 输入 输出     细菌向养分移动 外界环境的化学信号 催动鞭毛的电信号   学生参加高考 试卷反射的光信号 试卷上问题的答案   小车自动避障 摄像头传输图像信号 前方被堵塞的概率    实际上，知识的本质也是函数，生命延续的关键就在于该生命的模型是否适应环境。这里不深入解释了，觉得惊奇请参阅Yjango的频道https://space.bilibili.com/344849038他用机器学习的角度解释生物进化，非常颠覆三观。\n总之训练出来的模型就是这样一个函数。其输入为经过处理的摄像头的图形信号，输出一个0-1的数，越接近1越意味着模型认为小车要撞墙了。但是当他大于0.5的时候就会触发转向，也就实现了自动避障。\n AlexNet是2012年提出的一种卷积神经网络（即CNN）算法。首次实现gpu加速。\n主流深度学习框架：TensorFlow；PyTorch；Keras\n 还挺好玩的😀\ndemo2：目标追踪 基于上一个demo，我们还要下载一个模型，coco数据集神经网络，可以检测90种不同的物体。按教程把.engine文件下载到指定位置，顺着跑就完事了。（引入模型也要花挺长时间）\n如果有数据集里的物品，从输出里能看到蓝框标出，小车会自动转向物体，同时还保留了自动避障的程序。\n遇到bug：程序仅能读取一张图像进行识别，摄像头更新的功能无法执行。\n修bug：摄像头问题 描述：摄像头只要调用了一次，后面就无法在其他地方调用。直接在jupyter上关闭输出并没有作用。而且只要在一个notebook里就能重复调用，换一个就不行。而且并没有报错信息，程序一直处在busy状态。\n找到源码，在jetbot/jetbot/camera.py，但是所有样例里面调用摄像头都是用的Camera.instance()方法，而这个instance是在traitlets库里的，于是找到trailets官方文档\n Traitlets是一个纯 python 库，支持：\n 对 python 对象属性的强类型实施( 类型属性称为 \u0026ldquo;特征\u0026rdquo; ) ； 动态计算的默认值； 当尝试改变时，自动验证和强制特征属性； 当特征值改变时注册接收通知； 从文件或者 命令行 参数中读取值- 在traitlets上不同层，因这里可以在没有配置机器的情况下使用 traitlets。  Traitlets支持IPython和Jupyter的配置系统，以及IPython交互小部件的声明性 API。\nipython是一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。其中就包括traitlets库。\n https://traitlets.readthedocs.io/en/stable/config.html 在这里找到instance的功能：返回现有的类，如果没有就新建一个。\n下面是样例中调用摄像头的代码：\n1 2 3 4 5 6 7 8  import ipywidgets.widgets as widgets #图像模块 from IPython.display import display #ipy的显示模块 import traitlets from jetbot import Camera, bgr8_to_jpeg #摄像头驱动，图像格式转换 camera = Camera.instance(width=500, height=500)#初始化摄像头对象 image = widgets.Image(format=\u0026#39;jpeg\u0026#39;, width=400, height=400)#创建图像 camera_link = traitlets.dlink((camera, \u0026#39;value\u0026#39;), (image, \u0026#39;value\u0026#39;), transform=bgr8_to_jpeg) #连接摄像头到图像 display(image) #显示图像   尝试从camera.py里调用原始api。得到报错：Each object must be HasTraits, not \u0026lt;class 'NoneType'\u0026gt;，是说必须为对象指定类型。那么HasTraits这个类型是啥？文档说:任何具有trait属性的类都必须从 HasTraits 继承。\n再次梳理调用摄像头的流程：\n 引入模型：model.load_state_dict(torch.load('best_model.pth')) 连接摄像头：见上文 模型执行：  1 2 3 4  def update(): ...#此处为模型执行函数，将输入图像预处理后，执行模型 update({\u0026#39;new\u0026#39;: camera.value}) #初始化该函数 camera.observe(update, names=\u0026#39;value\u0026#39;) #将update函数设为camera.value的observer   研究一下observe用法：当对象发生变化时调用函数。\nhttps://traitlets.readthedocs.io/en/stable/using_traitlets.html#validation\n执行如下代码：\n1 2 3 4 5 6 7 8 9 10  import ipywidgets.widgets as widgets #图像模块 from IPython.display import display #ipy的显示模块 import traitlets from jetbot import Camera, bgr8_to_jpeg #摄像头驱动，图像格式转换 camera = Camera.instance(width=500, height=500)#初始化摄像头对象 def update(change): x = change[\u0026#39;new\u0026#39;] display(x) #显示图像 update({\u0026#39;new\u0026#39;: camera.value}) camera.observe(update, names=\u0026#39;value\u0026#39;)   输出一大堆数组，说明camera.value是这一大堆像素。而且observe正常运行，数据一直冒出。\n1 2 3 4 5 6 7 8 9 10 11 12  array([[[122, 116, 130], [126, 113, 127], [125, 117, 129], ..., [ 84, 96, 107], [ 82, 96, 113], [ 93, 93, 113]], [[120, 119, 130], [122, 120, 119], [118, 123, 130], ...,   然而就是不实时更新数据，卒。\n👴佛了。\n神经网络笔记 AlexNet——CNN 2012年由Hinton学生Alex提出，是Lenet加宽版。其采用了一系列的新技术：成功的引用了relu、dropout和lrn等trick，首次采用gpu加速。其包含65万神经元，5个卷积层，三个后面带有池化层，最后用了三个全链接。\n","date":"2019-10-01T00:26:38Z","permalink":"https://lonelyuan.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8jetbot%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6%E5%B0%9D%E9%B2%9C%E4%BA%8C/","title":"深度学习入门——jetbot智能小车尝鲜（二）"},{"content":"那个男孩不想玩树莓派呢？机缘巧合之下，我得到了一台价值上百美元的智能小车的使用权。\n小车的核心是NVIDIA家的jetson-nano开发板，这款19年三月才发布的微型AI计算机可谓是平民级核弹，四核A57的CPU，128核心Maxwell架构的GPU，4g内存，支持4k视频解码，而且这只五脏俱全的麻雀只需要5W的电源支持，任何一支充电宝都可以胜任。而它的定位是用它简单的搭建人工智能应用，非常的amazing。\n本文的目的,不完全是新手教程,还有自己学习过程的记录和分享.初次接触,多有疏漏,欢迎指教.\n【图片：主板证件照】\n 给萌新理清几个概念：\n单片机：Single-Chip Microcomputer。\n树莓派：一款著名的微型电脑品牌（本文介绍的jetson-nano可以理解为是树莓派的竞品，相比树莓派，这款单片机价格更高，性能更好，主打AI应用）\njetbot：以jetson-nano为平台搭建的ai机器人应用，也就是所谓智能小车\n 硬件组装:积木和电工 本人拿到的是零件状态的小车，所以首先讲一讲组装的问题。有关具体步骤，官网教程十分详细，贴个连接给懒人吧：https://www.ncnynl.com/archives/201904/2927.html\n这里只讲一讲我作为初学者的一些理解。首先，玩单片机和玩积木的区别就在于编程。当然，入门单片机还需要其他技能。比如，电工技能：你需要进行线材的简单加工，引脚的焊接，准备基本的工具就好，毕竟那个男孩没有一根热热的棒子呢（指电烙铁）。然后，各个部件的拼接固定需要一些做手工的技巧，这个也不用怕，赫鲁晓夫曾经说过：热熔胶可以让我们创造奇迹。\n在这个层面上，初学者会浪费许多耗材，这是必要的练习手段，所以初学者也可以从最简单的芯片入手。同时你还要学习诊断硬件方面的问题，万用表会很有帮助。关于更详细的工具和耗材的需要，请自行查阅单片机入门有关资料。\n在本项目中，焊接工作已经完成，剩下的连接都是可插拔式的。我们只需要两把螺丝刀即可完成组装。即便如此，本人还是花了一晚上才把小车点亮，原因是我得到的线材损坏近半，只得自己寻找和修理。\n下面分析一下小车的结构:\n jetson-nano开发板:即本机的主板,可以看到有两层芯片,上层为核心层,包括cpu,gpu和内存可以像笔记本内存条一样拆卸;下层为主板,用于连接各种设备 intel无线网卡:将上层拆下即可安装.令连出两根天线,缠绕机身即可. PiOLED显示器和拓展版:连接在I2C主线上 相机模块:官方样例展示了只用一个摄像头通过深度学习进行自动避障的demo. 马达和其驱动板:下文重点讲解  开发板就可以运行一个完整的Ubuntu系统,其余设备是为其拓展功能的.\n硬件架构：驱动芯片和I2C主线 我在玩小车的过程中耽误最长时间的就是电机（即马达）驱动了，借此讲一讲系统架构的事。\n让轮子前进要靠马达，给马达供电不能直接让主板来做，要让主板给另一块小芯片发送指令，这块小芯片连接着独立的电源，收到指令才会给马达通电。这块小芯片即是电机驱动板。\n驱动芯片是从硬件走向软件的第一道桥梁，可以类比PC的IO设备来理解。和物理世界交互的各种功能，都需要有专门的驱动芯片。包括马达，摄像头，扬声器，机械臂等等，只不过有的可以集成在一起，如：小车上的摄像头，PiOLED显示器等；有的出于体积，安全性，模块化的考虑需要分开，如电机和驱动板。\n电机驱动板 官方给出的电机驱动板型号为:DC-Stepper-Motor PCA9685+TB6612.可以驱动两个步进电机或四个直流电机。（四轴飞行器gkd）本项目只用到了两个直流电机。\n各个引脚的讲解：https://learn.adafruit.com/adafruit-stepper-dc-motor-featherwing/pinouts\n电机驱动板上共连接有10根跳线。一对电源输入，两对为马达输出。还需四根母-母杜邦线来连接至主板的I2C总线,具体来说,是在LED屏旁边的拓展板。分别是：\n   驱动板引脚 主板I2C引脚 功能     3V3 3V3 为驱动板供电,即电源正极   GND GND 接地,即电源负极   SDA 3 串行数据线，传输数据   SCL 5 串行时钟线，传输控制信号    【图片：驱动板引脚】\n接错了有可能烧坏板子哦\nI2C总线 所谓总线,可以理解为一条街道,每个设备就是街道两旁的房子,房内的住户出门走亲访友就是数据在不同设备间的传输。\nI2C总线是常用于嵌入式系统的一种简易串行总线.他有简洁的双线结构(SCL+SDA),每个设备都有一个地址码,以此实现多个设备相互通讯。设备有主从之分，主设备/主端必须是带有CPU的逻辑模块，在同一总线上同一时刻使能有一个主端，可以有多个从端，从端的数量受地址空间和总线的最大电容 400pF的限制。\n可以使用i2c-tools调试i2c总线:\n 检测有几组i2c总线在系统上i2cdetect -l 检测挂载在i2c-1上的设备i2cdetect -r -y 1  1 2 3 4 5 6 7 8 9  0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- -- -- -- -- -- 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- --（led） 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: 60 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --（电机驱动） 70: 70 -- -- -- -- -- -- --     查看设备(地址为0x20)上所有寄存器的值i2cdump -f -y 1 0x20\n  对单个寄存器进行读写:\ni2cset -f -y 1 0x20 0x77 0x3f （设置i2c-1上0x20器件的0x77寄存器值为0x3f）\ni2cget -f -y 1 0x20 0x77  （读取i2c-1上0x20器件的0x77寄存器值）\n  jetson-nano开发板提供了6条I2C主线,以及其他丰富的接口。理解这些接口是拓展各种设备的前提。\n软件连接:ssh远程桌面 从头开始的话，我们还需要往sd卡里烧写系统镜像，不过我拿到的已经完成了这一步骤，故不再赘述。\n在官方教程中,需要hdmi线连接显示屏,usb连接鼠标键盘,来进入jetson-nano的Ubuntu系统.其目的在于首次连接一个无线网络(手机热点),之后只要电脑和nano在同一网络,即可用电脑访问nano的IP(8888端口),直接操纵jetbot.\n由于我并没有hdmi线,只有一根网线,反正都能插,插谁不一样?所以用网线把小车和笔记本连接起来组成局域网.用ssh的方式进入nano的系统.具体步骤如下:\n  ip发现:在插入网线前后执行两次:arp -a,比较不同,会发现多出一个地址,类型为动态,此即为小车的内网IP.小车的led屏也会自动显示其ip.如eth0:192.168.x.x\n  (如此,我们可以直接从浏览器访问这个ip的8888端口,并能运行jupyter notebook了.但我们不能让小车拖着网线跑啊,所以还是要配置无线网络.)\n  将笔记本的wifi连接设为对以太网可共享,这一步是为了让小车能通过笔记本联网\n  端口扫描:nmap -sT 192.168.x.x发现22端口开放,故连接之:ssh jetbot@192.168.x.x,就用官方教程给的账户密码.\n  连接成功后,就可以用命令行工具连接WiFi了,但还是安装一下远程桌面吧.\n  配置远程桌面:执行以下命令:\n1 2 3  sudo apt-get install tightvncserver sudo apt-get install xrdp sudo apt-get install vnc4server tightvncserver     之后在你的主机win+R，输入mstsc,进入远程登录桌面，输入小车的ip地址，点击连接\n  在xrdp的登陆界面输入用户名密码即可打开远程桌面\n(这里我用jetbot用户登陆遭遇闪退,用root就可以,不清楚原因)(另外开了远程桌面内存疯涨,就很离谱)\n  连接上wifi后,你能在小车的led板上看到另一个ip:wlan0:192.168.x.x\n  不管怎样,连接上wifi之后的操作就很简单了.跟着教程,跑一跑demo,还是很有成就感的.\n排查bug 然而demo并没有让我跑出来,且指向同一个错误:\n1  OSError: [Errno 121] Remote I/O error   沿着jupyter notebook的报错一直走,一直到了最底层,向设备写入数据报错,remote IO error.\n看起来像是硬件的问题。一步一步排查呗\n  怀疑跳线错误\n 更换跳线——无果 用万用表测量线两端的信号——正常，排除连接问题  时钟线保持3.3v每隔几秒跳到2.2v又回来，结合i2c的原理应该是正常现象？ 数据线同样保持3.3v，间断跳至2.3，2.0      软件方法检验设备连接性\n 用i2ctools可以检测到设备，拔下4根接线，在0x60,0x70处的设备消失（一个是i2c线，一个是逻辑供电？）  1 2 3 4 5 6 7 8 9  0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- -- -- -- -- -- 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- --     然而，在通电状态下，把连线拔下又插上之后，i2c又能检测到设备，然后示例代码就能运行了？？？\n迷惑。所以开机时机器并没能正确载入设备，反倒是重新连接后能识别了？？？本来我都要换驱动板了，orz。\n又或者是和驱动板上的reset按钮有关？等下次遇到问题再说吧。\n拾遗 linux内存占用 led屏会显示内存占用，然鹅时间长了总会到90%以上，可我并没有运行什么程序。\n经查阅此处显示的是实际占有的加上buffer和cached mem部分，可以理解为缓存的，随时清理，并不占用实际内存。\n可用top命令查看内存详情。\n供电问题 用充电宝供电方便，但是只要一断电系统就会重启，这对linux系统而言伤害很大。\n而在充电宝电量不满时，经常发生开不了机的问题，大概是因为电量不足导致电压不稳。\n关机命令： sudo shutdown -h now\n重启： shutdown -h now -r\n下一篇：操纵小车和AI初探\n参考链接 https://github.com/NVIDIA-AI-IOT/jetbot/wiki/Hardware-Setup\nhttps://robocarstore.cn/\nhttp://www.gpus.cn/gpus_list_page_techno_support_content?id=50\nhttps://www.jianshu.com/p/789944463fd7\n","date":"2019-09-20T00:25:55Z","permalink":"https://lonelyuan.github.io/p/%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8jetbot%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6%E5%B0%9D%E9%B2%9C%E4%B8%80/","title":"单片机入门——jetbot智能小车尝鲜(一)"}]