{"posts":[{"title":"闲来无事，倒腾博客——记博客主题的二次开发","content":"倒腾过 Hexo, Wordpress 等，👴最终选用Gridea做博客。因为👴不再年轻了，👴开始追求简单安逸，像挨了锤的牛一样。一个还算说得过去的GUI，还是比发一篇博客敲好几条命令要来的舒服。 当然，舒服的代价就是定制化程度低，总有许多不称心如意的地方。👴目前看中的 Pure 主题，功能较简单，但还是有些不足之处。于是本文记录一下博客主题的二次开发，学习一点前端的东西。以下是需求： 文章详情页的目录，位于侧边 移动端菜单按钮失灵 | BUG 开发文档 Gridea的作者还给出了开发文档，还是蛮贴心的 https://github.com/getgridea/gridea-theme-starter https://gridea.dev/theme/ 【如标题所示，如果这里还空着，就说明最近并不是闲来无事，这很合理】 ","link":"https://lonelyuan.github.io/post/blog-refit/"},{"title":"MOSPI-ChCore lab (1)","content":"由于👴觉得👴学校的操作系统讲了个🔨，慕名而来学习上交的 MOSPI 课程。银杏书看完之后👴发现👴学校的OS确实讲了个🔨。我直接当场来一段圣经吟唱： 那个额西电操作系统嗷，不会写教材可以不写，害特么在弄你那个管程，来我教你啊，看好了啊。首先 M.A.L.H. 原则，看懂了吗，然后开讲虚拟内存，哎我就不虚拟，我就讲那个空闲链表。哎，再扎个多线程，看到没，线程上下文切换了。我特么直接三段系统调度（短期，中期，长期），然后我直接~就一个多核调度，我就调度到IPC，进程现在已经可以通信了啊！别怪我没有教好你，进程通信了之后干什么，憋特么讲你那破几把处理机了。看好啊，讲出锁（嬉皮笑脸），讲出信号量直接就扔到互斥资源身上，就疯狂的进入他的临界区。然后我再一个，文件系统！加三段系统虚拟化（CPU虚拟化、内存虚拟化、IO虚拟化），全部吃满，完成强杀，你唛璧你懂个der，讲寄吧OS，我爱你。 圣经原文：拖更云的鹰佐教学 本系列为 ChCore lab 实验报告。 Lab源码：https://gitee.com/ipads-lab/chcore-lab MOSPI在线网站：https://ipads.se.sjtu.edu.cn/mospi/ 实验环境 需要docker和qemu，docker不赘述。linux下安装qemu： sudo apt-get install qemu-system-arm 安装完成之后查看版本号： $ qemu-system-aarch64 --version QEMU emulator version 4.2.0 Copyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers 5个实验在源码仓库分别以5个分支存在。 git clone -b即可。 内核构建和调试： 用docker交叉编译内核：make build 启动qemu：make qemu 这里遇到报错：Unable to init server: Could not connect: Connection refused gtk initialization failed 解决方法：修改 Makefile ，在QEMUOPTS参数后加-nographic 启动qemu：make qemu-gdb 将监听1234端口以供gdb远程调用 退出：ctrl+a，然后按x。 如果意外退出，要杀死进程：kill $(ps -ef | grep qemu | grep 1234 | awk '{print $2}') 在另一个终端启动gdb调试：make gdb 这里可能需要安装gdb-multiarch：sudo apt-get install gdb-multiarch 可以看到，本项目中 Makefile 主要是封装了一些命令。 Lab1 练习3-加载入口定义 root@lastyear:~/chcore-lab# readelf -S build/kernel.img There are 9 section headers, starting at offset 0x20cd8: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] init PROGBITS 0000000000080000 00010000 000000000000b5b0 0000000000000008 WAX 0 0 4096 [ 2] .text PROGBITS ffffff000008c000 0001c000 00000000000011dc 0000000000000000 AX 0 0 8 [ 3] .rodata PROGBITS ffffff0000090000 00020000 00000000000000f8 0000000000000001 AMS 0 0 8 [ 4] .bss NOBITS ffffff0000090100 000200f8 0000000000008000 0000000000000000 WA 0 0 16 [ 5] .comment PROGBITS 0000000000000000 000200f8 0000000000000032 0000000000000001 MS 0 0 1 [ 6] .symtab SYMTAB 0000000000000000 00020130 0000000000000858 0000000000000018 7 46 8 [ 7] .strtab STRTAB 0000000000000000 00020988 000000000000030f 0000000000000000 0 0 1 [ 8] .shstrtab STRTAB 0000000000000000 00020c97 000000000000003c 0000000000000000 0 0 1 看到init段的起始地址是0x80000，和readelf -h中的 Entry point address 一致，也和 GDB 刚进入时where的输出一致。 0x0000000000080000 in ?? () (gdb) where #0 0x0000000000080000 in _start () 下面寻找_start的定义，在CMakeLists.txt中找到_start， set_property( TARGET kernel.img APPEND_STRING PROPERTY LINK_FLAGS &quot;-T ${CMAKE_CURRENT_BINARY_DIR}/${link_script} -e _start&quot; ) 这里为kernel.img指定了链接器脚本(-T)和入口函数(-e)。 于是跟随link_script： set(link_script &quot;linker.lds&quot;) configure_file(&quot;./scripts/linker-aarch64.lds.in&quot; &quot;linker.lds.S&quot;) 进入脚本linker-aarch64.lds.in： #include &quot;../boot/image.h&quot; SECTIONS { . = TEXT_OFFSET; img_start = .; init : { ${init_object} } // ... 其中init段指定了加载init_object，它表示bootloader的所有目标文件集合。其定义回到CmakeLists.txt： set(init_object &quot;${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/start.S.o ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/mmu.c.o ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/tools.S.o ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/init_c.c.o ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/uart.c.o&quot; ) 可发现/boot/start.S定义了_start。 下面继续寻找地址，在链接器脚本引用了image.h，其中有TEXT_OFFSET的定义： #pragma once #define SZ_16K 0x4000 #define SZ_64K 0x10000 #define KERNEL_VADDR 0xffffff0000000000 #define TEXT_OFFSET 0x80000 一切终于串起来了： CMakeLists.txt：学名：组态档。 CMake 是 make 工具的升级版，CMakeLists.txt就是 CMake 的 Makefile 。 为编译器指定脚本；为ids定义变量；指定了入口函数_start linker-aarch64.lds.in：lds是链接器脚本文件，负责控制输出的ELF文件的细节。 指定了起始地址0x80000 练习3-多处理器挂起 start.S中注释的很明白了，通过检查mpidr_el1寄存器来判断 cpuid ，如果不是0则进入死循环。 BEGIN_FUNC(_start) mrs x8, mpidr_el1 and x8, x8, #0xFF cbz x8, primary /* hang all secondary processors before we intorduce multi-processors */ secondary_hang: bl secondary_hang primary: /* Turn to el1 from other exception levels. */ bl arm64_elX_to_el1 /* Prepare stack pointer and jump to C. */ adr x0, boot_cpu_stack add x0, x0, #0x1000 mov sp, x0 bl init_c /* Should never be here */ b . END_FUNC(_start) 练习4-LMA和VMA root@lastyear:~/chcore-lab# objdump -h build/kernel.img build/kernel.img: file format elf64-little Sections: Idx Name Size VMA LMA File off Algn 0 init 0000b5b0 0000000000080000 0000000000080000 00010000 2**12 CONTENTS, ALLOC, LOAD, CODE 1 .text 000011dc ffffff000008c000 000000000008c000 0001c000 2**3 CONTENTS, ALLOC, LOAD, READONLY, CODE 2 .rodata 000000f8 ffffff0000090000 0000000000090000 00020000 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 3 .bss 00008000 ffffff0000090100 0000000000090100 000200f8 2**4 ALLOC 4 .comment 00000032 0000000000000000 0000000000000000 000200f8 2**0 CONTENTS, READONLY 可以发现只有init段的VMA和LMA相同。其赋值还是回到lds脚本： SECTIONS { . = TEXT_OFFSET; img_start = .; init : { //init段VMA==VMA ${init_object} } . = ALIGN(SZ_16K); // 对齐16k init_end = ABSOLUTE(.); // init段结束 // KERNEL_VADDR在image.h定义为0xffffff0000000000 .text KERNEL_VADDR + init_end : AT(init_end) { // AT指定LMA *(.text*) } // .text段：VMA = KERNEL_VADDR + init_end; LMA = init_end // 后面的段，全部按顺序对齐并递增，此时VMA和LMA已经不同，故后面的段也全都不同 . = ALIGN(SZ_64K); .data : { *(.data*) } . = ALIGN(SZ_64K); .rodata : { *(.rodata*) } _edata = . - KERNEL_VADDR; // 这些外部变量指的是LMA，则减去虚拟地址头 _bss_start = . - KERNEL_VADDR; .bss : { *(.bss*) } _bss_end = . - KERNEL_VADDR; . = ALIGN(SZ_64K); img_end = . - KERNEL_VADDR; } 回答问题： 为什么LMA和VMA不同 VMA是对应虚拟内存的地址，但在内核启动时还处于物理地址模式，VMA可能超出物理内存范围。所以只能先加载，再映射到虚拟地址。 为什么内核段的VMA要映射到高位，应该是一种惯例。 为什么bootloader不用VMA，因为他负责初始化页表，他不能用，也没有必要。 LMA到VMA在何时转换 由上一问可知，页表初始化之后便可转换为VMA。 练习5-c语言进制转换 从后往前取余即可。 练习6-函数栈 start.S中赋值了sp： /* Prepare stack pointer and jump to C. */ adr x0, boot_cpu_stack add x0, x0, #0x1000 mov sp, x0 /* sp = boot_cpu_stack + 0x1000 */ boot_cpu_stack在init.c #define INIT_STACK_SIZE 0x1000 char boot_cpu_stack[PLAT_CPU_NUMBER][INIT_STACK_SIZE] ALIGN(16); 由于PLAT_CPU_NUMBER被定义为4，故boot_cpu_stack大小为4*4096，可供四个CPU使用。sp初始化后指向第一个4069，也就是第一个cpu内核栈的最高位。初始化时，fp=sp。 但这是bootloader的栈。后续进入内核后，会重新分配内核栈，参见head.S： BEGIN_FUNC(start_kernel) mov x3, #0 msr TPIDR_EL1, x3 ldr x2, =kernel_stack add x2, x2, KERNEL_STACK_SIZE mov sp, x2 bl main END_FUNC(start_kernel) 于是内核栈的定义在start_kernel函数。 有关内核栈的位置，因为kernel_stack是全局数组，且未初始化，因而位于.bss。同时没有其他未初始化变量，因此首地址在.bss + KERNEL_STACK_SIZE。 通过readelf得到.bss的VMA为0xffffff0000090100，KERNEL_STACK_SIZE为0x2000，进入gdb调试可以验证 gef➤ x/g $sp 0xffffff0000092100 &lt;kernel_stack+8192&gt;: 0x0 练习7-调用惯例 先看stack_test函数。这里gdb安装了gef插件： gef➤ b stack_test Breakpoint 1 at 0xffffff000008c020 gef➤ disas Dump of assembler code for function stack_test: =&gt; 0xffffff000008c020 &lt;+0&gt;: stp x29, x30, [sp, #-32]! /* FP、LR 入栈 */ 0xffffff000008c024 &lt;+4&gt;: mov x29, sp 0xffffff000008c028 &lt;+8&gt;: str x19, [sp, #16] /* x 入栈 */ 0xffffff000008c02c &lt;+12&gt;: mov x19, x0 0xffffff000008c030 &lt;+16&gt;: mov x1, x0 0xffffff000008c034 &lt;+20&gt;: adrp x0, 0xffffff0000090000 # 计算偏移 0xffffff000008c038 &lt;+24&gt;: add x0, x0, #0x0 0xffffff000008c03c &lt;+28&gt;: bl 0xffffff000008c620 &lt;printk&gt; 0xffffff000008c040 &lt;+32&gt;: cmp x19, #0x0 0xffffff000008c044 &lt;+36&gt;: b.gt 0xffffff000008c068 &lt;stack_test+72&gt; # greater than /* 递归 */ 0xffffff000008c048 &lt;+40&gt;: bl 0xffffff000008c0dc &lt;stack_backtrace&gt; 0xffffff000008c04c &lt;+44&gt;: mov x1, x19 0xffffff000008c050 &lt;+48&gt;: adrp x0, 0xffffff0000090000 0xffffff000008c054 &lt;+52&gt;: add x0, x0, #0x20 0xffffff000008c058 &lt;+56&gt;: bl 0xffffff000008c620 &lt;printk&gt; 0xffffff000008c05c &lt;+60&gt;: ldr x19, [sp, #16] # x19 = sp + 16 /* x 出栈 */ 0xffffff000008c060 &lt;+64&gt;: ldp x29, x30, [sp], #32 # load pair /* FP、LR 出栈 */ 0xffffff000008c064 &lt;+68&gt;: ret 0xffffff000008c068 &lt;+72&gt;: sub x0, x19, #0x1 0xffffff000008c06c &lt;+76&gt;: bl 0xffffff000008c020 &lt;stack_test&gt; 0xffffff000008c070 &lt;+80&gt;: mov x1, x19 0xffffff000008c074 &lt;+84&gt;: adrp x0, 0xffffff0000090000 0xffffff000008c078 &lt;+88&gt;: add x0, x0, #0x20 0xffffff000008c07c &lt;+92&gt;: bl 0xffffff000008c620 &lt;printk&gt; 0xffffff000008c080 &lt;+96&gt;: ldr x19, [sp, #16] 0xffffff000008c084 &lt;+100&gt;: ldp x29, x30, [sp], #32 0xffffff000008c088 &lt;+104&gt;: ret End of assembler dump. 运行，观察栈的变化，这里省略部分输出： gef➤ c ───────────────────────────────────────── registers ──── $x0 : 0x0000000000000005 # 这一层函数的输入值 $x19 : 0x0000000000000000 # 上一层函数的返回值 $x29 : 0xffffff00000920f0 # FP $x30 : 0xffffff000008c0d4 → &lt;main+72&gt; # LR $sp : 0xffffff00000920f0 ───────────────────────────────────────────── stack ──── 0xffffff00000920f0│+0x0000: 0x0000000000000000 0xffffff00000920f8│+0x0008: 0xffffff000008c018 # 栈头，可能是栈初始化的数据结构 ──────────────────────────────────────────── trace ──── [#0] 0xffffff000008c020 → stack_test() [#1] 0xffffff000008c0d4 → main() ─────────────────────────────────────────────────────── gef➤ c ───────────────────────────────────────── registers ──── $x0 : 0x0000000000000004 $x19 : 0x0000000000000005 $x29 : 0xffffff00000920d0 $x30 : 0xffffff000008c070 #→ &lt;stack_test+80&gt; $sp : 0xffffff00000920d0 → 0xffffff00000920f0 ───────────────────────────────────────────── stack ──── 0xffffff00000920d0│+0x0000: 0xffffff00000920f0 ─┐ # FP 0xffffff00000920d8│+0x0008: 0xffffff000008c0d4 │ # LR 0xffffff00000920e0│+0x0010: 0x0000000000000000 │ 0xffffff00000920e8│+0x0018: 0x00000000ffffffc0 │ 0xffffff00000920f0│+0x0020: 0x0000000000000000 ◄┘ 0xffffff00000920f8│+0x0028: 0xffffff000008c018 ───────────────────────────────────────────── trace ──── [#0] 0xffffff000008c020 → stack_test() [#1] 0xffffff000008c070 → stack_test() [#2] 0xffffff000008c0d4 → main() ──────────────────────────────────────────────────────── gef➤ c ───────────────────────────────────────── registers ──── $x0 : 0x0000000000000003 $x19 : 0x0000000000000004 $x29 : 0xffffff00000920b0 → 0xffffff00000920d0 → 0xffffff00000920f0 $x30 : 0xffffff000008c070 $sp : 0xffffff00000920b0 → 0xffffff00000920d0 → 0xffffff00000920f0 ──────────────────────────────────────────── stack ──── 0xffffff00000920b0│+0x0000: 0xffffff00000920d0 ─┐ # [#1] 0xffffff00000920b8│+0x0008: 0xffffff000008c070 │ 0xffffff00000920c0│+0x0010: 0x0000000000000005 │ 0xffffff00000920c8│+0x0018: 0x00000000ffffffc0 │ 0xffffff00000920d0│+0x0020: 0xffffff00000920f0 ◄┘ # [#2] 0xffffff00000920d8│+0x0028: 0xffffff000008c0d4 │ 0xffffff00000920e0│+0x0010: 0x0000000000000000 │ 0xffffff00000920e8│+0x0018: 0x00000000ffffffc0 │ 0xffffff00000920f0│+0x0020: 0x0000000000000000 ◄┘ # [#3] 0xffffff00000920f8│+0x0028: 0xffffff000008c018 ─────────────────────────────────────────── trace ──── [#0] 0xffffff000008c020 → stack_test() [#1] 0xffffff000008c070 → stack_test() [#2] 0xffffff000008c070 → stack_test() [#3] 0xffffff000008c0d4 → main() ────────────────────────────────────────────────────── 可以看到每次递归调用压栈4个64位字，分别是：上一层FP，LR，参数x和0x00000000ffffffc0。最后一个64位字用途未知。 练习9-backtrace 提供read_fp()接口，我们知道fp永远指向父函数的fp，故递归调用即可。 u64* fp = (u64*) *((u64*)read_fp()); // 双层指针，因为第一层是本函数 while(fp != 0) { printk(&quot;LR %lx FP %lx Args %d %d %d %d %d\\n&quot;, *(fp + 1), fp, *(fp - 2), *(fp - 1), *(fp), *(fp + 1), *(fp + 2)); //为什么5个参数是fp-2到fp+2？样例只包括一个参数，只要出现fp+2就能测试通过 fp = (u64*) *fp; //下一层 } 满分通过，懒得贴图了。 看到大佬写的，瞬间不想写了，寄。 https://www.cnblogs.com/kangyupl/p/chcore_lab1.html ","link":"https://lonelyuan.github.io/post/mospi-lab-1/"},{"title":"从scapy和wireshark学计算机网络","content":"众所周知，计网被评为最困的计算机专业课，俗称计算机中的语文。👴看了《计算机网络－自顶向下方法》（后文简称CNTDA）之后，觉得翻译就像汤姆叔叔的烂苹果派一样糟糕，上帝啊，我真的想狠狠踢他的屁股。建议带🔥去看英文原版。但是👴最近接触的许多实验还是很好玩的，于是本文试图完全通过动手实操学习计网。 实验来源有： 👴自己 SEEDLab，雪城大学的信息安全课配套实验，网络安全部分。国内知名度不高所以值得一做。官方网站 CNTDA 实验：GIthub上抄的作业 本系列实验主要用到俩工具： wireshark是坠nb的网络封包分析软件。就是用来抓包的。 下载：https://www.wireshark.org/download.html 教程：https://www.javatpoint.com/wireshark scapy库是python的网络编程库，可以让你细致入微的操纵网络流量。就是用来发包的。 //不要和爬虫库scrapy混淆 scapy文档：https://scapy.readthedocs.io/en/latest/ 中文版：https://www.osgeo.cn/scapy/introduction.html //有些翻译错误 💣包 等等，啥是“抓包”？啥是“发包”？啥是“包”？ 当然，包不仅仅是一个 CSGO 术语，在计算机网络中，包（package）有多个近义词，包括：报文(Datagram)，分组(Packet)，流量包(Data package)……根据语境不同而区分，但大致指的是同一件事情：即网络中真正流动着的东西，我们希望网络来传递的东西。 那么抓包和发包就不难理解了。本文的主要内容，就是用上述两工具把计算机网络从上到下玩个遍。 不过在开玩之前，还需要理解一件事。 🍰复杂系统方法——分层(layering) CNTDA 中用邮政系统类比计算机网络，这是最常用的例子，这里我们用快递物流网来举例。随便打开你的网购记录，你会发现快递物流大概经过以下过程： 客户发货：把货物和地址交给快递点 快递网点揽件：包装货物而变成包裹；包裹被送往最近的中转中心 中转中心运输：根据包裹目的地不同，分拣并装车运输给不同的中转中心；若收到本片区的包裹，卸车并分拣给不同的网点 快递网点派送：按包裹的地址，快递员送货上门 客户取件：拆箱，拿到货物，确认无误签收 //上述流程不严谨，地址泛指地址电话重量等信息；不考虑菜鸟驿站等自取点情况 你知道发一个快递要经历怎样的困难吗？你不知道，你只关心你自己。这里的重点是，客户不需要关心中转中心如何指挥重型货车或飞机，网点也只需要关心如何包装好客户的货物。快递网络明显的呈现出三层的分层架构，每一层之间只需要关心自己的工作，并和相邻的层交互。这就是应对复杂系统的组织方法——分层。 课本上会提到OSI七层模型或者TCP/IP五层模型，这里的模型全称是协议分层模型，又来新词了，别急，后面还有： 协议(Protocal)：同一层级内的交互规则。//横向 接口(Interface)：不同层级间的交互规则。//纵向 服务(Service)：每一层的工作，就是调用下层的接口，并为上层提供服务。 接口和服务的区别是，服务作为实体，由本层负责实现，暴露出接口供上层调用；而接口则是抽象的，本层并不知道下一层的可靠性。由此你能否看出分层思想的优越性？每一层只关注自己的实现，于是大问题被分解成了小问题。好比一个总工作量100的问题，不了解分层思想的你只能10+10+10+……=100；而分层思想提供了乘法法则，于是你可以通过10*10=100，只需要完成20工作量。 上述类比中特意标注了一些对应关系： 载荷(Payload)：要运输的货物。每一层都有自己的“货物”，比如中转中心的载荷是满载包裹的长途货车而不是单个包裹。 封包(Packaging)：信息在层次间传递的过程就是封包/解封的过程。比如对报文拆分成段，每段再加上首部/包头(header)，最终形成分组的过程；恰如对货物的包装并贴上标签，成为包裹的过程。 路由(Routing)：对应快递的分拣过程。根据包裹上的标签，决定包装的去向。尤其是网络层，需要大量复杂的路由操作。 协议栈(Protocol stack)：报文在每一层都被封装并交给下一层，要想得到原始报文只能一层一层解开，操作模式类似栈。由此协议分层模型被简称为协议栈。 实际上不管5层还是7层，他们都可以简化成三层，正如上述快递网络体现的那样（自底向上顺序）： 通信层：负责物理通信。 本层负责对接各种物理介质，向上提供点对点的通信服务 对应五层模型的物理层、链路层 网络层：建立网络连接。 本层负责将点对点的通信组织成网状结构，将物理的通信转化为逻辑的通信服务 对应五层模型的网络层、运输层 端层：发出原始报文。 本层负责实现用户需求，向用户提供透明可靠的网络服务 对应五层模型的应用层 偶剋！你已经了解了分层思想，下面来设计互联网吧！（迫真） ⌚️开始实验 有关计网的学习顺序自古就有自顶向下还是自底向上的分歧，自底向上就像搭积木，学的明白但较枯燥；自顶向下则有趣但总像雾里看花。可以看到，本系列实验从应用层出发，逐步深入到链路层，再逐步返回应用层，同时难度不断加大。 //【想看哪个没更新的可以催👴】 应用层: Web服务器 | ⭐ | TODO 术语： Server：一般语境下的服务器(Server)，指的是为用户提供服务的机器。 CS结构 HTTP协议 实验： 用scapy/socket做一个静态服务器。 效果是浏览器能访问。wireshark抓http包 拓展： 常用服务器：apache/nginx 计网并不关心应用层以上的东西 那么，网络如何保证网页被完整的交到你手里？ 传输层: TCP观察 | ⭐ | TODO 术语： 传输层：负责可靠运输 帧，报文 TCP/UDP 实验： 用wireshark观察TCP连接的建立和结束。 尝试用scapy建立TCP连接 https://www.cnblogs.com/darkpig/p/7629854.html 拓展： TCP核心：滑动窗口，重传策略，阻塞控制 那么，网络如何寻找一个人/机器？ 网络层: 路由追踪 | ⭐ 术语： IP层：IP协议，ICMP协议，路由协议 路由追踪：请求某地址经过了那些路由器？ scapy实现了路由追踪函数，你可以钻研一下源码（很短），写一个自己的traceroute。 其实现大致如下： 下面详细讲解： ans,unans=sr(IP(dst=target,ttl=(1,30),id=RandShort())/TCP(flags=0x2)) sr()：send and receive，返回的两个参数分别是得到应答的数据包列表和未应答的包列表。 IP()/TCP()：scapy重载了“/”表示协议栈的合成，可以链式的链接不同协议层实例，每层内部都可携带自己的参数 ttl=(4,30)：ttl参数在IP层表示ICMP包的转发次数（跳数）。此外，传入tuple表示一个范围，sr函数将会为这个范围内的每个值生成一个发包。（如果有多个tuple参数，则会按笛卡尔积规则生成发包列表） TCP(flags=0x2)：在TCP头部设定flag字段的值，0x2对应ACK，即确认收到包。 综合起来，这条代码将发送47个包，其ttl从1到50。并筛选返回ACK的包。 这样根据IP层路由算法，到达ttl的包无论是否找到目标都会返回，直到找到目标，TCP层返回ACK。遍历ttl形成的列表即是经过的所有路由。 网络层: 欺骗ping | ⭐ | TODO https://seedsecuritylabs.org/Labs_20.04/Files/ICMP_Redirect/ICMP_Redirect.pdf 链路层: ARP缓存投毒 | ⭐⭐ | TODO https://seedsecuritylabs.org/Labs_20.04/Files/ARP_Attack/ARP_Attack.pdf 传输层: TCP攻击 | ⭐⭐ | TODO https://seedsecuritylabs.org/Labs_20.04/Files/TCP_Attacks/TCP_Attacks.pdf TCP协议 SYN泛洪 TCP reset TCP session hijacking反弹shell （重点） 网络层: NAT，DHCP和虚拟机 | ⭐⭐ | TODO 相信折腾过虚拟机的同学都绕不过这个问题：我的虚拟机怎么连不上网？本实验基于wmware虚拟机平台，讲解几种虚拟机网络模式及其原理。 应用层: DNS本地攻击 | ⭐⭐⭐ | TODO https://seedsecuritylabs.org/Labs_20.04/Files/DNS_Local/DNS_Local.pdf 应用层: SSL协议和HTTPS | ⭐⭐⭐⭐ | TODO 应用层: 多线程Web代理服务器 | ⭐⭐⭐⭐⭐ | TODO 应用层: VPN | ⭐⭐⭐⭐⭐ | TODO 探究VPN原理 应用层: V2Ray协议学习 | ？？？ | TODO 有生之年研究一下Vmess等协议 ","link":"https://lonelyuan.github.io/post/Computer_Network_Exp/"},{"title":"年轻人的第二个网站（二） - flask-supreme-tutorial","content":" 上回书说到，网站初具雏形，但经高人指点，还是有很多不足。 本文将大胆扩充网站结构，目标是将网站拓展成一个 CMS 。 所以，不要停下来啊！👆（指开发 0x00 蓝图与重构 与之前相比，网站将增加以下功能： 图库：文件上传模块 评论：楼中楼功能 后台：权限模块，后台模块 优化：更健壮的数据库接口，更细致的权限控制 plus功能：用 redis 实现热搜 在开发这些功能之前，首先重整项目结构。如： 完全蓝图化。参考 模板也放入独立子目录里，蓝图注册时使用template_folder参数，不过这样容易产生bug，flask 官方推荐使用硬编码，汗。 清理依赖，不使用维护状态差的库。 开发新功能的时候，去哪里找最佳实践，找好用的库呢？有一个 Github 搜索小技巧，名为 &quot;awesome-xxx&quot; 的仓库通常是某技术的优质资源列表。如：https://github.com/humiaozuzu/awesome-flask 0x01 文件系统 本部分参考了李辉大佬的系列文章， https://zhuanlan.zhihu.com/p/23731819?refer=flask 头像，照片……文件上传是绕不开的话题。在上一篇参考的教程中，头像的实现是由托管网站生成随机的图片。遗憾的是并没有像 ORM 一样方便数据库处理的文件处理框架可供使用，还是自己把他啃下来吧。 注意踩坑！大部份资料推荐使用Flask_uploads插件，然而使用该插件时出现如下报错： ImportError: cannot import name 'secure_filename' from 'werkzeug' 查阅Stackoverflow得知是PYPI源上的Flask_uploads插件不再维护了，于是和 werkzeug 库的api不兼容，是插件内在的bug。网上的解决方法有二： 一是修改库源码 二是换另一个库，维护良好且可无缝迁移，名为Flask-Reuploaded 前者不利于后续部署，本人倾向于后者。然而，使用新库也遇到了诸多麻烦，使用UploadSet.url()方法时，报错如下： werkzeug.routing.BuildError: Could not build url for endpoint '_uploads.uploaded_file' with values ['filename', 'setname']. UploadSet.url()方法返回对应文件的可访问url，返回的url默认带有_upload/前缀，这是 Flask-Uploads 自带的路由，也被称为 autoserve 。 然而官方文档里有这样一句话 autoserve of uploaded images now has been deactivated; this was a poorly documented “feature”, which even could have lead to unwanted data disclosure; if you want to activate the feature again, you need to set UPLOADS_AUTOSERVE=True 看来 Flask-Reuploaded 的作者似乎认为文件读取功能与我无瓜。好吧，这部分我们自己实现。 // 浪费了一晚上debug，结果只是因为文档没看明白，再次证明读文档的重要性。 Flask-Reuploaded: 文件上传 插件将上传的一类文件抽象成集合UploadSet。对每个 Set 有如下操作： 配置文件类型：photos = UploadSet('photos', IMAGES) //类型包括：IMAGES、TEXT、AUDIO…… 配置存贮路径：app.config['UPLOADED_PHOTOS_DEST'] // Photos 为 Set 的变量名 保存文件：filename = photos.save(request.files['photo']) 返回链接：photos.url(filename) 最后，注册 Set 和插件注册类似：configure_uploads(app, [avatars, photos]) //可一次性全部注册 实现头像上传的步骤如下： 模型层： User 添加 avatar 字段，储存头像的文件名。原avatar()方法作为默认头像。 表单层： edit_profile 表单增加FileField字段 视图层： 储存文件，向数据库提交文件名。 模板层： 改用硬路由获取url。// 最终 .url() 还是有bug，再次说明不要乱用不知名的插件 图库模块 本模块包括如下路由： /index：主页显示瀑布流 /upload：上传接口：参考头像上传 /detail：详情，显示评论 /delete：删除接口：同时删除文件 由于本项目前端框架是 Bootstrap ，👴不想写Jquery，所以直接刷新页面，也不弄无限滚动了，按钮了事。另外为了不同列长度尽量均匀，故采用取巧的方法，平均分配。根据大数定理，只要随机图片足够多肯定会差不多均匀。。。。 0x02 评论系统 数据库设计 评论包含了两个一对多关系，既是评论和文章的一对多关系，也是评论和用户的一对多。为此，只需要给User和Post添加关系即可。 然而，我们希望设计统一的Comment模型，评论的对象既可以是文章，也可以是图片，也可以是其他评论。为此，添加一个枚举类型的字段指示评论类型，从而采用不同的处理逻辑。 楼中楼 而主流网站不光支持对文章评论，还支持楼中楼。对楼中楼的实现有以下几种方案： 按时间平铺：以原百度贴吧为例 添加 reply_id 字段，指示要回复的人 套娃式缩进：以某些老式bbs为例 添加 parent_id 字段，指示父评论（顶层评论则为本身id），在实体类中保存子评论列表 弹窗式查看：以知乎，b站为例 在按时间平铺的基础上，若 reply_id存在添加“查看对话”按钮，递归的构建对话并弹窗。 其中，第一种实现简单，用户不友好；第二种实现复杂，对多层级对话无法胜任；第三种是最主流的实现方式。 通过以reply_id作为指针，所有评论连接成了一棵树，在任意一个节点进行“查看对话”操作，就是执行树的寻根。“查看对话”函数如下： @staticmethod def view_dialogue(c_id): dialogue = [c_id] while Comment.query.get(c_id).type == 'comment': c_id = Comment.query.get(c_id).reply_id if Comment.query.get(c_id) is None: break dialogue.append(c_id) return dialogue 0x03 网站后台 网站的后台通常给管理员提供统一监管数据库的界面。有以下插件帮助实现： Flask-admin：一键生成后台页面，并可以自定义视图和模型。 Flask-Security： 比admin层次更高，封装了常用视图和模板。但是文档少，且很多功能我们已经实现了，再使用它就要推翻重做。遂弃用。 本教程中使用了 RBAC（Role-Based Access Control) 基于角色的访问控制，简单说就是设计一个角色表，用户表和角色表用关联表实现多对多关联。这样做的好处是，针对角色的权限分配，修改权限时无需修改每个用户。 0x04 热搜 本节再加入一个重量级内容，利用 redis 实现浏览量排行榜，也就是热搜。当然，真正的热搜榜单排名规则更加复杂，这里只通过简单的浏览量计数来练习 redis 的使用。 【👴有时间再做】 不要让开发停下来 可以加的功能还有很多：时间线，emoji支持，多媒体，前后端分离(Vue)，， 除了功能，当面对更高量级的流量时，网站性能便更加重要，这时候消息队列，PRC，微服务/分布式，，，更让人头秃。 Web开发之路，道阻且长。但是，只要开发不停下来，道路就会不断延申。。。（希望之花.mp3） ","link":"https://lonelyuan.github.io/post/flask-supreme-tutorial/"},{"title":"年轻人的第二个网站 - The Flask Mega Tutorial","content":" 本文为 Flask 框架学习笔记，主要参考了 The-Flask-Mega-Tutorial 和 《Flask Web开发：基于Python的Web应用开发实战》两本书，并在原项目的基础上拓展。（下文统称这两个资源为“本教程”） 不熟悉 Flask 框架请先阅读快速上手 - flask 中文文档 。 这两本书的作者是同一个人，就内容上说后者算是前者的豪华版。本教程的优点是内容全面，从入门到部署一站式服务；缺点是不够深入，且有些过时，书中举例的诸多插件均为作者为了此书而开发的，已经许久不再维护，导致很难在其示例项目上拓展。一看扉页，2015年出版，那没事了。 至于第一个网站？参见#TODO:年轻人的第一个网站 0x00 大型项目结构 在大部分面向初学者的 demo 中，应用以简单的项目结构甚至单文件表示。在大型项目中，网站的不同功能被拆分成独立的模块，以方便拓展和维护。一个更通用的 Flask 项目代码架构如下：（仅考虑业务代码） microblog/ # 根目录 app/ # 项目源码 __init__.py # 项目初始化，当该包被import，首先执行__init__.py routes.py forms.py ... main.py # 框架入口 config.py # Config配置类 .flaskenv ... 根目录下的文件有： app/所有网站源代码统一归到app目录下。 在app/内部，不同的功能可进一步划分成独立模块，详见[模块化应用](#0x05 模块化应用：功能解耦)一章。 main.py: 入口脚本，通过该文件引入app中的代码并生成应用实例（命名随意） .flaskenv: flask环境变量，以配合flask命令。入口脚本被定义为FLASK_APP，执行flask run时将启动该脚本。 config.py: 配置脚本，整个项目的配置信息都写在Config类里。与环境变量的区别在于，因为是python脚本，功能更强大，可被任何地方的代码引用。 0x01 Hello world：模板和视图 最基本的 web 功能，无非接受请求、返回数据。其中，路由 (route) 用来区分不同的请求，模板 (templates) 用来生成不同的数据。 路由/视图 在非前后端分离的项目中，视图函数直接返回渲染好的网页，由@app.route()修饰后，视图和路由便绑定在一起。 在mvc模型中更像controller控制器的角色，然而在flask生态中更喜欢称为视图函数。 url_for() 使用URL到视图函数的内部映射关系来生成URL，用来替换硬链接。在业务功能解耦后必须使用这种方式。 NOTE：当路由和视图函数名不一致，访问该路由可以正确响应，但是使用url_for()调用该视图时会报错 {{% extends &quot;base.html&quot; %}} and {{% include &quot;_post.html&quot; %}} 使用子模板来实现网页公用的部分。如：页眉，页脚，列表项等。 模板和 Python 代码的关系有些类似与 JSP 和 Java 代码的关系，但模板语法并不是完整的脚本语言，相较而言限制更多，安全性更好。 表单 几乎所有成功的框架都有丰富的插件生态。下面引入新功能时，大多借助插件来方便的实现。大多数Flask插件使用flask_&lt;name&gt; 命名约定。 Flask-WTF插件提供了对Web表单的抽象，只需定义表单类以及设置类属性即可。 模板语法： {{ form.&lt;name&gt;.label }}渲染标签 {{ form.&lt;name&gt;() }}获取属性值 form.hidden_tag()模板参数生成了一个隐藏字段，其中包含一个用于保护表单免受CSRF攻击的token 将表单引入模板 form = LoginForm() # 生成了一个实例传入模板 return render_template('login.html', title='Sign In', form=form) flash 闪现消息 flash 通过 session 储存，用于显示只出现一次的提示消息。用法： 在路由中使用flash()，触发时消息便写入 session 中的 message 列表 在模板中使用get_flashed_messages()，从 session 中读取 0x02 数据库 ORM 很久很久以前，web网站和数据库交互还需要写很多很硬的 SQL 语句，效率低且容易出现注入漏洞(SQLi)。现代web开发都使用 ORM 框架简化数据库交互，且基本杜绝了 SQLi 漏洞。 本项目使用如下插件打通数据库： Flask-SQLAlchemy: Python生态最知名的ORM框架 Flask-Migrate: 本教程作者编写的数据库迁移框架 插件首先要注册。统一流程: 初始化app实例，传入插件类作为插件实例的参数 # app/__init__.py app = Flask(__name__) # flask基类 app.config.from_object(Config) db = SQLAlchemy(app) migrate = Migrate(app, db) SQLalchemy：model层 模型定义 使用类和类属性代表 table 和 colunm ，便可轻松编写数据模型。SQLalchemy 的概念抽象如下图： Flask-SQLAlchemy 自动设置类名为小写来作为对应表的名称，也可以用__tablename__类属性来定义。 class Post(db.Model): # 表 id = db.Column(db.Integer, primary_key=True) # 列 .... CURD基本操作 ORM 框架通常集成了常用操作，但也支持更底层的数据库接口。 在 Springboot Jpa 中，根据方法名的拼写来写自定义查询，而在 SQLalchemy 中，提供的接口通过链式调用拼接。 在 SQLalchemy 中，基本操作大都有基于事务 (session) 的和基于查询 (query) 的两种方式。 查 session.query(User) query方法只有构造一个查询，只有在Query.get()、Query.all()、Query.one()等结束符之后才会执行查询 增： db.session.add(user) db.session.commit() 删 session.query(User).delete() # or session.delete(session.query(User).get(1)) session.commit() 改 query = (session .query(User) .filter_by(id=1) .update({&quot;username&quot;: User.username + &quot;a&quot;}, synchronize_session=False) ) # or user = (session.query(User).get(1)) user.password = &quot;zxcv&quot; session.commit() Flask-Migrate: 数据库迁移 配置数据库的初始数据框架，一般写成SQL脚本形式。 migrate 框架直接根据 model 层生成迁移脚本，可以方便的跟踪数据模型的修改和数据库的切换。（这个框架还是本教程作者自己开发的，强） flask db子命令 flask db init：初始化，生成migrations目录 flask db migrate：生成迁移脚本，修改model后使其生效 flask db migrate -m &quot;posts table&quot; flask db upgrade：应用数据库修改（开发阶段默认使用sqlite数据库 flask db downgrade：回滚上次的迁移 0x03 开发范式：用户系统 mixin：混入，多重继承的一种形式 表单和数据库支持分别解决了前端和后端的基本需求，下面可以上线一个基本功能了，用户登录。 所需插件：Flask-Login。 UserMixin类 UserMixin类集成了login插件要求的用户模型属性，将其混入到 User 模型中，即可用@login_required实现权限控制。 @app.route('/result/', methods=['POST']) # NOTE：有顺序关系，反之则不生效 @login_required 用户系统，包括登录、登出、注册几个功能。编写这些功能的步骤其实很类似： 设计数据库，在model.py中 设计表单对象，在form.py中 设计页面，在模板.html中 设计视图函数，在routes.py中 也对应了mvc框架的设计理念，比如设计表单就有些像 javaweb 中的 DAO 层。但也有区别， Flask 框架更希望业务逻辑写在数据库模型中，而视图函数尽量保持简洁，以方便单元测试。 PRG 模式 即为 Post/Redirect/Get，其格式大概如下： @bp.route('/some_form', methods=['GET', 'POST']) def some_form(): # prepare forms if form.validate_on_submit(): # submit modification return redirect(url_for('main.some_form')) elif request.method == 'GET': # GET data return render_template('some_form.html', form=form) 默认情况，提交 POST 请求后，如果直接刷新浏览器，会重新在 POST 一次。使用PRG模式即可解决重复提交表单的问题。 0x04 深入数据库：粉丝机制 数据库关系 要关注别人，就要让数据库记住我关注的人的名字，当然，只记住名字肯定不够，万一改名了呢。因此每个用户都需要有唯一有效的标识（其实更重要的是性能因素）。正因如此，数据库中每个表都要有一个唯一的列，称为主键(primary key)。当不同表之间存在关系，一个表要通过主键寻找其他表项，其他表的主键储存在本表中，称为外键(foreign key)。外键关联既可以表示一对一的关系，也可以一对多(1-&gt;n)。 SQLalchemy 对关系的定义如下： 外键：db.ForeignKey('user.id') 关系：db.relationship('Post', backref='author', lazy='dynamic') 参数1：所关联的表(n in 1-&gt;n)，这里是模型的变量名 参数2：由 &quot;n&quot; 回调 &quot;1&quot; 的虚拟字段，用法：post.author 粉丝机制 然而，粉丝机制包括关注和被关注。这是一种多对多的关系，于是需要用含有两个外键的关联表表示。又因为关注者和被关注者在一个表里（User），这种关系又称为自引用。 模型 关联表只有引用类型，故不需要派生模型类 followers = db.Table( 'followers', db.Column('follower_id', db.Integer, db.ForeignKey('user.id')), db.Column('followed_id', db.Integer, db.ForeignKey('user.id')) ) 为User添加关系 followed = db.relationship('User', # 右侧实体 secondary=followers, # 指定关联表 primaryjoin=(followers.c.follower_id == id), # 指定左关系 secondaryjoin=(followers.c.followed_id == id), # 指定右关系 backref=db.backref('followers', lazy='dynamic'), lazy='dynamic') # 指定回调 复杂查询 查询粉丝列表 SQL 语句：SELECT * FROM user, followers WHERE followers.follower_id = 3 AND followers.followed_id = user.id SQLalchemy 接口：user.followers.all() 实际执行的 SQL 语句：（打印 query 对象得到） SELECT ,,, FROM user, followers WHERE followers.followed_id = ? AND followers.follower_id = user.id NOTE：如果方法集成在model里，方法名不要和字段名相同，自己定义的方法会覆盖该字段。 查看已关注用户的动态 SQL 语句：SELECT * FROM post JOIN followers on followers.followed_id = post.user_id where followers.follower_id = 2 SQLalchemy 接口： Post.query.join( followers, (followers.c.followed_id == Post.user_id)).filter( followers.c.follower_id == self.id).order_by( Post.timestamp.desc()) 实际执行的SQL语句： SELECT ,,, FROM (SELECT ,,, FROM post JOIN followers ON followers.followed_id = post.user_id WHERE followers.follower_id = ? UNION SELECT * FROM post WHERE post.user_id = ? ) AS anon_1 ORDER BY anon_1.post_timestamp DESC 由于python的弱类型特征，有时候很难明白函数之间传递的是什么对象。我们从上往下梳理一遍： 请求到达路由函数，开始执行查询Post.query.....，此时只是在构造查询，并未取得数据，此时的对象类型：&lt;class 'sqlalchemy.orm.query.Query'&gt; 直到get(),all(),paginate().items结束符等出现，查询才被执行，返回数据类型实例，如User。 数据类实例传入模板，并由__str__等方法参与渲染。 0x05 网站美化 本教程提供的flask-bootstrap插件，较为简陋，且该插件年久失修，遂替换之。在此之前，先搞明白目前项目前端的架构 /templates auth/ errors/ base.html _posts.html index.html ... 所有模板都有一个父模版：base.html，其结构如下： {% extends 'bootstrap/base.html' %} {% block title %}Hallo Wolrd{% endblock %} {% block head %} ... {% endblock %} {% block scripts %} ... {% endblock %} {% block navbar %} ... {% endblock %} {% block content %} ... {% block app_content %}{% endblock %} {% endblock %} app_content留空，即其余模板均在app_content内填充。 进一步追溯bootstrap/base.html的源码，发现其它 block 诸如navbar也都留空或仅仅配置了 Bootstrap 的 cdn。 由此，只需将base.html迁移即可。 在网上寻找新的UI模板，不要在中文互联网搜索，basically garbage。找到一个 Meterial 模板 还算顺眼，遂用之。 不熟悉 Bootstrap 布局的可以使用可视化工具来设计前端，如：http://www.ibootstrap.cn/ 对照模板，将base.html掏空，效果如下： 遇到的bug有： 下拉菜单失效：查询得知有可能是bootstrap版本冲突 //结果并不是，只是忘记引入js文件而已，我是傻逼。 文件上传按钮消失：本教程中，表单渲染采用wtf.quick_form()，这玩意还是来自bootstrap/wtf.html 最后决定整个🐏了 Flask-Bootstrap 插件。 富文本编辑器 在《Flask Web开发：基于Python的Web应用开发实战》中提到了markdown编辑器的实现。 需要的包： PageDown: JS 版 Markdown 渲染器，用于客户端预览。 Flask-PageDown: flask 集成插件。该插件需要注册 Markdown: Python 版 Markdown 渲染器，用于服务端渲染。 Bleach: HTML 清理器，保证安全性 为了兼顾安全和效率，做法是同时保存 markdown 源文本和 HTML 文件。步骤如下： 表单改为 PageDownField 模板引入 PageDown 宏，以实现即时预览 为 Post 模型增加字段，并添加 markdown 渲染方法，该方法为类方法，需要@staticmethod修饰 在模型外部监听数据库事件，仅当 markdown 文本出现变动时调用渲染方法。 修改模板以显示服务端返回的 html 文本 然而预览器过于简陋，也很难修改。在github仓库上发现该插件也是本教程作者写的，已经很久没有维护。顿时对本书作者有些不满。 0x06 模块化应用：功能解耦 保持 app 作为全局变量的模式，可能会给后续引入新功能和单元测试带来麻烦。 要适应大型项目需求，需要把网站功能拆分成独立的模块。 Blueprint化 要实现解耦，一种功能的相关代码可以借助Blueprint归类到一个包里。其文件结构大致如下： app/ some_fuction/ &lt;-- blueprint package __init__.py &lt;-- blueprint creation ... other code ... templates/ some_fuction/ &lt;-- templates __init__.py &lt;-- blueprint registration 创建blueprint与创建应用非常相似。 from flask import Blueprint bp = Blueprint('func', __name__) from app.func import Func 而消灭了app，蓝图内部的引用统一变成了蓝图名。而外部诸如url_for的参数则需要加上包名.做前缀。 应用工厂模式 工厂函数是一个外部函数，在这个函数内部执行插件注册和配置工作，并通过他返回应用实例。 # app/__init__.py db = SQLAlchemy() # ... def create_app(config_class=Config): app = Flask(__name__) app.config.from_object(config_class) db.init_app(app) # ... 返回后，flask提供的上下文对象current_app将指向应用实例。详见官方文档：应用上下文 多线程 current_app是线程绑定的，若要在诸如邮件服务的位于其他线程的功能调用他，则会发现没有赋值。 需要使用current_app._get_current_object()表达式。 Python概念辨析：包，库，插件 包 (package) 是指一种代码结构，只要有文件夹和 __init__.py 都是包。 库 (library) 和插件 (plugin) 都是从外部引入的包，区别在于，插件要集成进应用，所以需要注册等步骤；而库更独立，可以随时随地调用 0x07 开发帮手 本节讲解一些杂项。 调试 flask shell命令：为避免每次调试都要重新import app，使用上下文调用解释器，用@app.shell_context_processor装饰上下文函数 单元测试 unittest 库，详见下一篇。 记录日志到文件 logger 库 if not app.debug: if not os.path.exists('logs'): os.mkdir('logs') file_handler = RotatingFileHandler('logs/microblog.log', maxBytes=10240, backupCount=10) file_handler.setFormatter(logging.Formatter( '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]')) file_handler.setLevel(logging.INFO) app.logger.addHandler(file_handler) app.logger.setLevel(logging.INFO) app.logger.info('Microblog startup') requirement.txt 装的库太多怎么办？只需要两条命令： pip freeze &gt; requirements.txt pip install -r requirements.txt 0x08 网站上线 最后简单列出几种网站部署的方法，详情参考本教程或自行搜索。 native模式 买主机 连主机：ssh 买域名 配域名 配环境 数据库 服务器 其他依赖 持续运维 容器化技术：docker 写dockerfile docker-compose up --build -d 云技术：PaaS 注册云平台账户 写Procfile git push ","link":"https://lonelyuan.github.io/post/flask-mega-tutorial/"},{"title":"CISCN2021华东百赛区分区选拔赛AWD复盘","content":"🛁 这是👴第一次打高达80支队伍的大型AWD，👴此行的目标就是称霸酒店的游泳池。后来发现游泳池要钱，👴只能遗憾败北。（后来发现情报出了问题，根本不要钱，血亏）总的来说，酒店浴缸很带，主办方态度很好，赛场很清真，参赛体验很爽，赚了。 “终端越炫，嗨客越带；嗨客越带，帽子越带” 🐐AWD复盘 首先根据参赛手册，进行一个规则的复制： 1、 采用线下赛的方式，参赛团队通过有线连接到局域网，并进行网络连通性的测试。请自备连接网络所需要的设备如usb转RJ45转换器等工具。 2、 攻防赛部署若干道赛题，初始分值为10500分。 3、 使用xctf用户通过ssh连接GameBox，GameBox的ip地址和登录密码通过赛事页面下载获取。 4、 比赛10分钟/回合，每个回合会更新GameBox上的flag。 5、 每个回合内，一个战队的一个服务被渗透攻击成功（被获取到flag并提交），则扣除10分，攻击成功的战队平分这些分数。 6、 每个回合内，服务宕机或无法通过check则会被扣除10分，服务正常的战队平分这些分数。 7、 参赛战队在修复漏洞时，请保持服务的正常功能和打印字符、界面样式，否则将无法通过系统check。 8、 每个回合内，服务异常和被拿flag可以同时发生，即战队在一个回合内单个服务可能会被扣除两者叠加的分数，最多扣除20分。 。。。 7、 请参赛战队在比赛开始时对所有服务进行备份，主办方仅提供2次重置机会，2次机会使用后不予重置。申请重置时请提供战队名称。 8、 禁止使用通用防御方法如waf等工具，违规者第一次被发现扣除当前分值的10%，第二次被发现扣除当前分值的50%，第三次被发现取消参赛资格并向其学校发文进行通报批评。 比赛全程收手机，断外网，不能用waf，不准用不死马，大家都很清真，找回了ctf最初的快乐。 然后按照AWD开局的任务清单，进行一个盘的复： 准备阶段 ssh连接： 主办方提供了ssh密钥，和靶机ip 于是省略ssh-copy-id -i ~/.ssh/id_rsa.pub root@xx.xx.xx.xx环节。 但是万能的Windows Terminal连不上去（依然不知道为啥），👴只能用图形化ssh客户端添加私钥连接。 IP扫描： 共有7道题，3道web，4道pwn，每道题目一个独立靶机，有独立的ip地址。不同靶机d段不同，不同队伍c段不同，按初赛排名分配。平台上告知了全部的ip列表。 于是省略nmap -sn xx.xx.xx.0/24环节。 选手机和靶机池在一个局域网内。不同队伍c段不同，一个队伍内的不同电脑d段不同。 流量监控： 主办方贴心的提供了被打流量(但是只有下行流量)，直接在~/package目录下给出.pcap文件。 于是省略tcpdump tcp -i eth0 -t -s 0 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap环节。 (不过用户名叫xctf，权限卡的很死。不给流量的话估计也只能在站里上流量监控脚本) 更新速度很快，被打之后几乎可以立刻找到流量。于是手速很重要。 开局阶段 备份源码：tar -zcvf w.tar.gz /var/www/html 结果&gt; Permission Denied，遂跳过 扫马删马：D盾 👴直接在图形化shell里下载代码，然后崩屎了几次，手速慢了。 每个web题都有一个不明小文件，显然是小马，删除之。 备份数据库：mysqldump -uctf -p --databases [dbname] &gt; /tmp/db.sql 结果&gt; Permission Denied，遂跳过 改数据库密码：mysql&gt;SET PASSWORD FOR ctf@localhost=PASSWORD('newpass'); 结果&gt; Permission Denied，(╯▔皿▔)╯玩nm 然后开始源码审计(❌) 然后等待被打之后翻流量(✔️) 攻防阶段 👴只看得懂web题目。三道web题全是cms，是经典lamp环境。可是👴看不懂cms，👴是five。 web1：safecms 比赛一开始，啪的一下很快啊，全场被打，翻流量抓到payload，是一个模板文件的任意读漏洞。直接批量拿flag。 定位到路由，注释之，不好使，还是被打；删除这个.class.php，不好使；👴怀疑是运行时缓存不更新，直接service restart apache2 结果&gt;Permission Denied，👴佛了 就这样被打了好一会，才发现直接修改index.php，能直接生效，血亏。 web2：eyou 这道题被打的很少，被宕机的很多。抓流量，发现很多混淆流量。（日志写shell？） 👴跟着流量尝试用过滤的方法修复，但是还是被宕。 若干轮后，👴没办法，只好申请重置，并在下一轮被宕。 若干轮后，👴没办法，只好申请重置，并在这一轮被宕。 若干轮后，👴没办法，只好白给，并在某一轮恢复正常并坚持到最后。我？？？ 该不会是某队或者裁判看我们太可怜帮我们重置了吧，世界上还有这么温柔的人，我真的哭死 这道题无了。（赛后才知道，有队伍找到sqli并登录后台，在后台关闭了站点并羊了管理员账号。修nm。 web3：lol 这道题是最后三小时放的，👴这时候已经自闭了几个小时。于是👴痛定思痛，开局直接把admin.php羊了，然后奇迹般的守到了最后。坏了，好起来了。 全场被打，翻流量找到payload，某路径下有白给shell，直接删马并反打。 某队使用了在网页输出中塞随机字符串的防御方法，但是没破坏flag，且填充的字符是固定的，被我肉眼识破，我直接进行一个if ip == xx: flag = flag[12:]。虽然没什么卵用，但是很快乐。 pwn： 一看到4个pwn👴直接傻掉。👴觉得👴不会做，因此也没去看，但听大佬说，直接抓流量进行一个转发就能拿分，👴下次一定准备好pwntools。 🔒自动化攻防框架 AWD中，手交flag实在是很浪费时间的行为。虽然有时候自动化不太好写只能手交，像这次十分钟一轮，有72支队伍，就算你手速惊奇，也没有时间审计源码了。因此打AWD重点就在一个自动化。网上能找到各种框架，但是用的时候总是不顺手，遇到bug也不会修。只有自己写的才最好用。 先说说用处最大的工具，就是批量攻击框架/自动化攻击脚本。这个框架主要有以下要素： 输入： 待攻击ip列表：通常写在ip.txt里 攻击函数：即封装好的payload请求 交flag函数：根据平台接口封装 输出： 批量攻击，输出攻击结果 攻击成功则提交 反馈得分结果 框架的核心无非以下逻辑： while True: for j in challenge_list: # 攻击函数索引 for i in ip_list: # 首先生成ip列表 flag = get_flag(i,j) # 根据j找到相应攻击函数 if flag!='Attacked failed': submit_flag(flag) print_result(j) time.sleep(round) 比赛时，找到漏洞或者抓到流量，立刻写好相应的攻击函数，重启脚本即可。 为了提高稳定性和易用性，这套框架可以写的很复杂。比如： 加入多线程，让框架非阻塞的持续运行 加入面向对象，写成类库 自带一些trick，比如流量混淆器等。 当然，还可以写一个网站来可视化管理 这里就涉及框架编程了，能深挖的地方还有很多。 除了批量攻击脚本，用到的脚本还有： 权限维持/批量shell脚本：用于管理多个shell 但是不死马被禁用，因此本次比赛中shell出现的不是很多。 （👴还准备了拿到白给shell之后持久化的脚本，结果一个shell都没拿到，准备个🔨。 文件监控脚本：用于监控flag等重要文件被读取和修改的准确时间，可以帮助确定payload 再牛逼一点还可以提供系统备份和回复功能。 上述都是系统脚本，大多在本机用python写的。下面说几种网页脚本，即直接用require/include包含的php脚本 流量监控脚本：区别于系统级流量监控，用于监控敏感流量以抓取payload 通防脚本：也就是waf，可以进行很充分的过滤 本次比赛中被禁用，因为确实破坏游戏体验 这些脚本，用好了才是趁手的兵器。这次比赛中👴的手速远不够快，延误了很多战机。 🌊快进到《考试周破防》 回顾整场比赛，相比正经的漏洞挖掘，随机应变的能力对分数也有很大影响。总结几个因素： awd的得分是随时间积累的，因此要掌控全局，时刻盯紧每道题有无薄弱环节和突破口。本次比赛题目数量多达7道，👴队有大佬没来，还带了一个萌新，约等于二打四，出现了看不过来题的情况。 还有就是手速，由于流量很及时，payload一被抓到，甚至可以在一轮check之内丢进批量攻击脚本，直接和首先挖掘到漏洞的队伍平分分数。这要求自动化脚本的熟练运用，尽量避免手交flag。 最后还有一点策略问题。分析三种题目状态，列个表定性分析一波最优解： 能反打 不能反打 场上大多数Attacked 先反打再修洞 不能修洞则down自己 场上大多数CheckDown 打他喵的 尽量别down 出现漏洞大部分人会被打，这时如果你不能立刻修补而能立刻反打，相当程度上是不亏的。如果你修不好也可以选择宕机，因为这样分摊了丢掉的分数。 尽量避免被打+被宕，扣双倍分数属实是血亏。如果决定宕机，先摸清check的时间和结算的时间，最好在新一轮结算后立即删站down自己。 当然，如果您能挖到洞，宁就是垂直上分的👴。 从8点半到6点半，打10个小时的AWD，要全程保持敏感和机智，确实对身体素质有些要求。👴坐高铁到合肥坐了6小时，打比赛坐了10小时，好悬没给我痔疮坐出来。晚上回到青岛并进行最后一次夜店，快进到《考试周破防》。 ","link":"https://lonelyuan.github.io/post/awd-da-pian/"},{"title":"基于vivado的基于FPGA的一种基于MIPS的一种五级流水线CPU实现的注释","content":" 本文所述为计算机组成原理课拓展实验的相关记录，基于“龙芯体系结构与CPU设计教学实验系统” 项目官网： http://www.loongson.cn/business/general/teach/356.html； 相关资料代码：#TODO:: github仓库 PS：标题可简记为《基于基于的一种基于的一种实现》 🤓吐槽时间 快考试了，👴发觉👴计组学了个🔨，👴去年也学了个🔨，但是去年可以归因于晦气的晦气，今年只能说自己晦气。难道还要重蹈去年的晦气吗？👴本应该回去背课本，刷考研题，但是👴一看ppt就想起我们敬爱的《计算机组成原理》课的任课老师，丐哥老师反复强调的至理名言：“听不懂的举手（无停顿）都没举手，都听懂了，非常好。”本人十分钦佩丐哥老师对幽默感的独特理解。 （但是特此声明：本人不了解、不认同其关于&quot;5G是个几把&quot;，&quot;高晓松很nb这个人&quot;，&quot;钱=浪漫&quot;等议题的看法） 而且👴这人很怪，课本上的重点，不好玩；选做的实验，好玩！哎就是玩，怪不得卷不过别人，你也配卷？滚去考研吧。 众所周知，计算机学生的本科生涯，如果能做到在自己设计的CPU上运行自己写的操作系统并用自己写的编译器跑代码，那就非常成功了。👴差不多，👴能在自己搜的代码上写自己的注释并用自己的电脑截图，都是三个&quot;自己&quot;。那么今天给大家爆个啥捏，流水线奥。 🔧 “用”计算机→“造”计算机 上回书说到（#TODO:: CSAPP大篇），汇编器(as)让我们得到了机器能看懂的比特流，最后一步只需要连接器(ld)将其和其他调用一起载入内存。这回答了程序如何在CPU这个平台上运行的问题，然而一个更基本的问题是，这个现有的平台是如何实现的？一个粗略的认识是，我们知道这些足以实现CPU的复杂的逻辑，其最小单元总对应到简单的诸如逻辑门上面，但是落实到真正的物理实现之上，如何使效率最高？功耗最小？这些问题所跨越的复杂度的量级依然是一片巨大的迷雾。照亮这片迷雾的知识，大概隶属于IC学科。 However，作为CS专业而不是IC专业，我们的目标仅在于理解所谓“组成原理”。在IC产业的复杂度规模数轴上，向下是专有芯片（又称嵌入式？），功能专用，规模较小；向上是通用芯片，即手机电脑等的核心，其难度不言而喻。位于中间的FPGA则既兼顾了自由度也考虑了速度，因此，这玩意能满足CS本科教学的需要（主要是便宜耐操）。 🔮高贵的IC工程师都用啥轮子 Vivado是一个FPGA集成设计平台（也算一个EDA？），他主界面左侧的工作流窗口很好的概括了利用FPGA开发的基本流程。即 编写设计源码(Source)：使用Verilog语言编写逻辑或引入IP 设计仿真模拟(Simulation)：通过观察仿真波形图和编写testbench来对设计进行debug 综合(Systhesis)门级网表：从RTL级描述降维到门级网表 生成(Implementation)布局布线：根据管脚约束，将依然是虚拟的门级连线落实为实际的线路 进行硬件编程(program)：生成比特流并写入目标设备 名词解释： IC：集成电路 FPGA：现场可编程门阵列 Verilog：一种硬件描述语言，语法涵盖了自顶向下五个抽象层面：系统级、算法级、RTL级、门级、开关级。 RTL：寄存器传输级。一般使用最多的就是RTL级。 IP：Intellectual Property内核模块，可以理解为将代码封装为函数。分为，软IP内核(soft IP core)，固IP内核(firm IP core)和硬IP内核(hard IP core)3个层次，相当于集成电路的毛坯、半成品和成品。 SoC：片上系统，大概是芯片及其装载的第一层软件接口的集合，很宽泛的概念。 EDA：电子设计自动化。 由此，我们可以大致探清了这片迷雾，CPU的设计如何从高抽象层次的逻辑，梳理成最底层的逻辑门，再实现为小小的芯片。那么我们有了轮子，要造一个CPU，还要确定目标指令集。由于本项目由龙芯公司赞助，那必然要选MIPS了。 📌MIPS指令集格式 啥叫指令集呢，学过几种语言就不难理解。高级程序语言规定每个ascii码的组合所对应的含义，指令集规定0和1的组合所对应的寄存器，ALU的各种信号。MIPS指令集从属于RISC系列，最基本的指令有31条。 //讲到这里本应该打个表展示31条指令，但是👴懒得打了。 Vivado中，.coe文件用于初始化IP核，本实验给出的.coe文件中存放了几条指令，不过是16进制数字，写个小脚本打印成可读的形式。 # mips_dump.py with open(path,'r') as f: hex_list = f.read().split('\\n') bin_list = list(map(lambda x:bin(int(x,16)),hex_list)) # bin_code_list = [&quot;{:0&gt;32}&quot;.format(i[2:],'b') for i in bin_list] bin_code_list = [i[2:].zfill(32) for i in bin_list] IType_op_dict = { '001000':'addi', '001001':'addiu', '001100':'ori', '001101':'xori', '001111':'lui', '100011':'lw', '101011':'sw', '000100':'beq', '000101':'bne', '001010':'slti', '001011':'sltiu' } RType_func_dict = { '100000':'add', '100001':'addu', '100010':'sub', '100011':'subu', '100100':'and', '100101':'or', '100110':'xor', '100111':'nor', '101010':'slt', '101011':'sltu', '000000':'sll', '000010':'srl', '000011':'sra', '000100':'sllv', '000110':'srlv', '000111':'srav', '001000':'jr', } def f_hex(ori, width): # bin-&gt;hex return &quot;0x&quot;+hex(int(ori,2))[2:].zfill(width) def f_reg(ori): # print register num return &quot;$&quot;+str(int(ori,2)).zfill(2) def code_dump(type:str,inst:str,params:list): if type == 'R': s = inst.ljust(6) + &quot;, &quot;.join([f_reg(params[0]),f_reg(params[1]),f_reg(params[2]),f_hex(params[3],2)]) elif type == 'I': s = inst.ljust(6) + &quot;, &quot;.join([f_reg(params[0]),f_reg(params[1]),f_hex(params[2],8)]) else: s = inst.ljust(6) +'0x'+ hex(int(params[0],2))[2:].zfill(8) return s assembly_list = [] for _ in bin_code_list: op = _[:6] # public field try: if op == '000000': # R-Type rs = _[6:11] rt = _[11:16] rd = _[16:21] shamt = _[21:26] func = _[26:] assembly_list.append(code_dump('R',RType_func_dict[func],[rs,rt,rd,shamt])) elif op in ['000010', '000011']: # J-Type target = _[6:] assembly_list.append(code_dump('J','j',[target])) else: # I-Type rs = _[6:12] rt = _[12:18] imm = _[18:] assembly_list.append(code_dump('I',IType_op_dict[op],[rs, rt, imm])) except Exception as e: assembly_list.append(&quot;***** decode error! *****&quot;) head = &quot;+---hexdump----|--------- assembly ---------+&quot; print(head) addr = 0 for i in range(len(bin_code_list)): print(&quot;|&quot;+ f_hex(bin(addr),2) +&quot; &quot;+ hex_list[i] +&quot; | &quot;+ assembly_list[i].ljust(26) + &quot; |&quot;) addr += 4 tail = &quot;+&quot;+&quot;-&quot;*43+&quot;+&quot; print(tail) 打印出来👴傻了，怎么还有不在31条范围里的。 +---hexdump----|--------- assembly ---------+ |0x00 24010001 | addiu $00, $04, 0x00000001 | |0x04 00011100 | sll $00, $01, $02, 0x04 | |0x08 00411821 | addu $02, $01, $03, 0x00 | |0x0c 00022082 | srl $00, $02, $04, 0x02 | |0x10 28990005 | slti $09, $36, 0x00000005 | |0x14 07210010 | ***** decode error! ***** | |0x18 00642823 | subu $03, $04, $05, 0x00 | |0x1c AC050014 | sw $00, $20, 0x00000014 | |0x20 00A23027 | nor $05, $02, $06, 0x00 | |0x24 00C33825 | or $06, $03, $07, 0x00 | |0x28 00E64026 | xor $07, $06, $08, 0x00 | |0x2c AC08001C | sw $00, $32, 0x0000001c | |0x30 11030002 | beq $16, $12, 0x00000002 | |0x34 00C7482A | slt $06, $07, $09, 0x00 | |0x38 24010008 | addiu $00, $04, 0x00000008 | |0x3c 8C2A0014 | lw $02, $40, 0x00000014 | |0x40 15450004 | bne $20, $20, 0x00000004 | |0x44 00415824 | and $02, $01, $11, 0x00 | |0x48 AC2B001C | sw $02, $44, 0x0000001c | |0x4c AC240010 | sw $02, $16, 0x00000010 | |0x50 0C000019 | j 0x00000019 | |0x54 3C0C000C | lui $00, $48, 0x0000000c | |0x58 004CD007 | srav $02, $12, $26, 0x00 | |0x5c 003AD804 | sllv $01, $26, $27, 0x00 | |0x60 0360F809 | ***** decode error! ***** | |0x64 A07A0005 | ***** decode error! ***** | |0x68 0063682B | sltu $03, $03, $13, 0x00 | |0x6c 1DA00003 | ***** decode error! ***** | |0x70 00867004 | sllv $04, $06, $14, 0x00 | |0x74 000E7883 | sra $00, $14, $15, 0x02 | |0x78 002F8006 | srlv $01, $15, $16, 0x00 | |0x7c 1A000008 | ***** decode error! ***** | |0x80 002F8007 | srav $01, $15, $16, 0x00 | |0x84 240B008C | addiu $00, $44, 0x0000008c | |0x88 06000006 | ***** decode error! ***** | |0x8c 8D5C0003 | lw $21, $48, 0x00000003 | |0x90 179D0007 | bne $57, $52, 0x00000007 | |0x94 A0AF0008 | ***** decode error! ***** | |0x98 80B20008 | ***** decode error! ***** | |0x9c 90B30008 | ***** decode error! ***** | |0xa0 2DF8FFFF | sltiu $31, $35, 0x00003fff | |0xa4 0185E825 | or $12, $05, $29, 0x00 | |0xa8 01600008 | jr $11, $00, $00, 0x00 | |0xac 31F4FFFF | ori $31, $19, 0x00003fff | |0xb0 35F5FFFF | xori $31, $23, 0x00003fff | |0xb4 39F6FFFF | ***** decode error! ***** | |0xb8 08000000 | j 0x00000000 | +-------------------------------------------+ 总之，代码都给你了，下面给出一个vivado实验的完整流程，不全面，但是都是踩坑经验。 🆒Vivado使用 本流程环境：Vivado 2020.2 开发板型号：LS-CPU-EXB-1 创建项目 下一步，下一步，下一步，，，确认。 这一步只需要注意选器件，一定要选对。否则有可能在Implementation遇到“端口电平不匹配”“端口数量不足”等硬件问题。当然，有可能型号相近的性能规格也差不多，这属于玄学问题了。实验书上选择的的型号应该是“xc7a200tfbg676-2”，但是👴用的是“xc7a200tfbv676-2”也能成功写入比特流。 编写代码并仿真 本实验的代码大多来自“2016-04-14”，那就是龙芯公司给的源代码。在该系列代码中有一处bug，位于“单周期CPU实验”的single_cycle_cpu.v中。214行，resetn应该为{4{resetn}}，写使能位宽应为为4。 下面讲解一下项目结构，所有实验都是类似的： 三个顶层文件夹分别对应Add Source里的三类源文件：添加设计，添加仿真，添加约束。如果不需要上板，只完成仿真，那么只需要添加设计（几个.v），添加仿真（testbench.v/tb.v）就足够了，xxx_display.v也是上板需要的故而可以忽略。（实际上，图中我用箭头标记的都用不到）。 编写tb，无非是给tb里声明为input的信号赋值，还可以使用#xx，让tb等待一段时间。 点击Run Simulation，等一会就能看到波形图。波形图有三种颜色： 绿色代表信号正常正常； 红色的X代表信号不确定； 蓝色的Z代表信号休眠。 一般遇到红X，都是未初始化问题。蓝Z大概是没有模块调用这些信号。Vivado波形图的操作极其难用，这里介绍一个相对好用的操作：左键从左向右水平划，会直接缩放到鼠标滑过的这一段。右键选择进制等操作略。 仿真需要注意的问题： 如果文件没问题，模块调用层次会被自动解析从而呈现成一棵树，而不是好几个顶层文件。 注意set as top，应该设为根部模块（调用其他模块的）和tb //如果设错了可能在Implementation会出现“端口未赋初值”的报错。 中文乱码是经典字符集问题，有可能在换行处导致语法错误。建议统一换成utf-8。 简单解决方法：从vscode里复制。 引入IP核 对于流水线CPU，data_ram和inst_rom需要同步写，自己实现比较复杂，故直接实例化封装好的内存块IP。如何引入？首先说明几种文件格式： .dcp 原意为checkpoints文件，是一种加密压缩文件。用于封装模块方便调用，但对版本要求极其敏感。 .xci/.xcix IP核配置文件，本质是一个xml。是Vivado在新版本提倡使用xci而不是dcp。 .xdc 管脚约束文件。在Implementation用到，此处按下不表。 这几种文件格式都是可以直接Add Source添加进来的。实验老师同时提供dcp和xci文件，添加dcp崩屎了，原因估计如上。添加xci之后，提示我将IP更新为core cointainer的形式 更新就完了。然后需要等一会，IP还要执行一步synth，这段时间里IP属于锁住的状态，不能修改配置。 注意更换器件后，IP核都会锁住。这表示IP的配置和当前环境不匹配。对所有IP锁住的问题，只需要点击菜单栏Reports→Reports IP Status，然后点upgrade即可解除锁定。 我直接上板 直接点生成比特流，会一步步的按工作流向下运行，等待几分钟就能愉快的收获你的报错了！ 在把上文提到的坑都踩过一遍之后，终于没有critical warning，泪目。 但是此时实验课已经结束了，👴偷溜到没人的实验室，并留下以下珍贵画面 然后👴发现data_ram写入失败。但是👴没时间搞了，👴还是滚去复习课本吧。 🗿多周期流水线CPU原理 最后，继续复习计组。 ","link":"https://lonelyuan.github.io/post/mips_pipeline_cpu/"},{"title":"我和拖延症的战争","content":"//这是一篇永远不会完结的文章。 //先准备目录 0x01 | 拖延症的生理基础 习惯的重要性 习惯行为学 生理基础：多巴胺 演化论证据 0x02 | 对拖延症的方法论综述 可行的计划 积极的环境 正向的反馈 能战胜拖延症的，是爱 0x03 | 高级作战录像 拖延循环 拖延症不是你失败的唯一原因 此身不灭，壮志不渝 0x04 | 西西弗斯计划 模型比方法更重要 对话机制 提示机制 这场战争，我们还没输，但也只能说还没输 ","link":"https://lonelyuan.github.io/post/ProcrastinationWar/"},{"title":"CSAPP - Bomblab","content":"CSAPP：Bomblab 逆向的传统艺能拆炸弹，👴的青春回来了。 文件结构： bomb ├── README ├── bomb └── bomb.c 只有一个程序，给的源码基本没用，我们要用逆向工程的方法理解程序，找到正确的字符串。 讲反汇编器的结果导出：objdump -d bomb &gt; bomb.txt 可以看到有6关，每一关接受一个字符串，若跳转到explode_bomb函数，则答案错误。 第一关：字符串比较 0000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; 逻辑是直接比较字符串是否相等，不过$0x402400不是程序内地址，说明答案被藏在了我们看不到的内存位置。 于是上GDB，在&lt;phase_1&gt;下断点，stepi单步执行到callq之前，查看寄存器:x\\s $esi，得到答案。（每台电脑的答案都不一样） 第二关：循环 0000000000400efc &lt;phase_2&gt;: 400efc: 55 push %rbp //压栈 400efd: 53 push %rbx 400efe: 48 83 ec 28 sub $0x28,%rsp //开辟栈帧 400f02: 48 89 e6 mov %rsp,%rsi//栈顶地址→rsi参数二 400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt; 如函数名所示，读6个数字，为什么是6呢，大概是因为存放参数的寄存器总共有6个吧。（然而并不） 可以看到调用前开辟了0x28的栈上空间，足够存放6个整数。栈顶地址被存入%rsi，以此传递该地址。 000000000040145c &lt;read_six_numbers&gt;: //%rsi:父进程&lt;phase_2&gt;的栈顶地址 40145c: 48 83 ec 18 sub $0x18,%rsp //栈帧长24 401460: 48 89 f2 mov %rsi,%rdx //rsi→参数三：num1 401463: 48 8d 4e 04 lea 0x4(%rsi),%rcx //rsi+4→参数四：num2 401467: 48 8d 46 14 lea 0x14(%rsi),%rax //rsi+20→rax 40146b: 48 89 44 24 08 mov %rax,0x8(%rsp) //rax→栈顶+8：num6 401470: 48 8d 46 10 lea 0x10(%rsi),%rax //rsi+16→rax 401474: 48 89 04 24 mov %rax,(%rsp) //rax→栈顶：num5 401478: 4c 8d 4e 0c lea 0xc(%rsi),%r9 //rsi+12→参数六：num4 40147c: 4c 8d 46 08 lea 0x8(%rsi),%r8 //rsi+8→参数五：num3 401480: be c3 25 40 00 mov $0x4025c3,%esi//0x4025c3:&quot;%d %d %d %d %d %d&quot; 401485: b8 00 00 00 00 mov $0x0,%eax //返回值赋0 40148a: e8 61 f7 ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; //sscanf() 40148f: 83 f8 05 cmp $0x5,%eax //返回值和5比较，即输入6个值才能通过 401492: 7f 05 jg 401499 &lt;read_six_numbers+0x3d&gt; 401494: e8 a1 ff ff ff callq 40143a &lt;explode_bomb&gt; 401499: 48 83 c4 18 add $0x18,%rsp //出栈 40149d: c3 retq 看&lt;read_six_numbers&gt;，%rsi中的地址以4为步长被分别储存。猜测sscanf函数的返回值中，第一个表示输入参数的个数；程序要求6个输入，加上rsi被占用，于是多的两个存入栈中。且sscanf函数的返回值按参数寄存器（多的地址在栈上）存放的地址传输，即输入值被按顺序存入phase_2的栈帧中。 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) //栈顶位置取双字和1比较 400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt; 400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt; 400f17: 8b 43 fc mov -0x4(%rbx),%eax //循环头：num1→eax 400f1a: 01 c0 add %eax,%eax // eax*2 400f1c: 39 03 cmp %eax,(%rbx) //和num2比较 400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt; //相等才通过 400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt; 400f25: 48 83 c3 04 add $0x4,%rbx //rbx增4 400f29: 48 39 eb cmp %rbp,%rbx //rbx和rsp+24比较，相等则跳出 400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt; //循环尾，循环共6轮 400f2e: eb 0c jmp 400f3c &lt;phase_2+0x40&gt; 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx //num2地址→rbx 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp//rbx地址→rbp 400f3a: eb db jmp 400f17 &lt;phase_2+0x1b&gt; //开始循环 跳出&lt;read_six_numbers&gt;后，首先检查栈顶地址指向的值是否为1，即第一个数字是1。 之后进入循环，循环体每次都会把当前数字*2和下一个数字比较，即每个数字都是前一个的二倍；%rbx作计数变量，共循环6次。答案呼之欲出。 第三关：分支 0000000000400f43 &lt;phase_3&gt;: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx //rsp+12→rcx: mun2 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx //rsp+8→rdx: mun1 400f51: be cf 25 40 00 mov $0x4025cf,%esi //0x4025cf: &quot;%d %d&quot; 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 400f60: 83 f8 01 cmp $0x1,%eax //不少于一个输入 400f63: 7f 05 jg 400f6a &lt;phase_3+0x27&gt; 400f65: e8 d0 04 00 00 callq 40143a &lt;explode_bomb&gt; 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) // 400f6f: 77 3c ja 400fad &lt;phase_3+0x6a&gt; //超过7则爆炸 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax //取num1 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) 此处*相当于c中的取地址符&amp;， 400f7c: b8 cf 00 00 00 mov $0xcf,%eax 400f81: eb 3b jmp 400fbe &lt;phase_3+0x7b&gt; ······ 这里有7段形式重复的代码，结合第一个数字不能大于7，猜测这里是switch型结构。 400fad: e8 88 04 00 00 callq 40143a &lt;explode_bomb&gt; 400fb2: b8 00 00 00 00 mov $0x0,%eax 400fb7: eb 05 jmp 400fbe &lt;phase_3+0x7b&gt; 400fb9: b8 37 01 00 00 mov $0x137,%eax 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax //比较num2和eax 400fc2: 74 05 je 400fc9 &lt;phase_3+0x86&gt; 400fc4: e8 71 04 00 00 callq 40143a &lt;explode_bomb&gt; 400fc9: 48 83 c4 18 add $0x18,%rsp 400fcd: c3 retq 第二个数字是%eax的值，由第一个数决定。故答案有7个。 第四关：递归 000000000040100c &lt;phase_4&gt;: ...... 401029: 83 f8 02 cmp $0x2,%eax //只能有2参数 40102c: 75 07 jne 401035 &lt;phase_4+0x29&gt; 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) //0 &lt;= num1 &lt;= 14 401033: 76 05 jbe 40103a &lt;phase_4+0x2e&gt; 401035: e8 00 04 00 00 callq 40143a &lt;explode_bomb&gt; 40103a: ba 0e 00 00 00 mov $0xe,%edx 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi //num1→edi 401048: e8 81 ff ff ff callq 400fce &lt;func4&gt; // 输入规则和上一关一样，第一个数需在0到14之间（cmpl只能用于无符号数？） 0000000000400fce &lt;func4&gt;: //首次调用时：%eax:0x2 %ebx:0 %ecx:0 %edx:0xe %esi:0x0 %edi:num1 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax //eax:14 400fd4: 29 f0 sub %esi,%eax //eax:14-0 400fd6: 89 c1 mov %eax,%ecx //ecx:14 400fd8: c1 e9 1f shr $0x1f,%ecx //ecx:0 //逻辑右移31，即取符号位。 400fdb: 01 c8 add %ecx,%eax //eax:14+0 400fdd: d1 f8 sar %eax //算术右移1位？eax:14/2=7 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx //ecx:7+0 400fe2: 39 f9 cmp %edi,%ecx //比较num1和7 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; //不大于→r17 400fe6: 8d 51 ff lea -0x1(%rcx),%edx //edx:ecx-1=6 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; //递归→r3 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; //跳出 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx //比较num1和7 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; //不小于 400ffb: 8d 71 01 lea 0x1(%rcx),%esi //esi:ecx+1=8 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; //递归→r3 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax //eax=2*eax+1 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq 前面一通算术操作，后面设计了递归。 这里一步移位操作看起来像是取符号位，但是输入一定大于0，符号位是0，所以这个操作意义何在？ 人肉IDA走起： int fun4(int num1,int x,int y){ int s,a; s=(x-y)/2+y; if(num1&gt;s) return 2*fun4(num1,s-1,y); a=0; if(num1&lt;s) return 2*fun4(num1,x,s+1)+1; return a; } fun4(num1,14,0); 第一个数设为7可避免递归调用，但返回值不是0，不符合。 40104d: 85 c0 test %eax,%eax //eax=0 40104f: 75 07 jne 401058 &lt;phase_4+0x4c&gt;//不等于0爆炸 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) //mun2和0比较？ 401056: 74 05 je 40105d &lt;phase_4+0x51&gt;//不等于0爆炸 401058: e8 dd 03 00 00 callq 40143a &lt;explode_bomb&gt; 40105d: 48 83 c4 18 add $0x18,%rsp 401061: c3 retq 看到的返回值和num2皆需为0，则num2确定。 大不了爆破呗，索性试了1次就成了。emm 第五关 0000000000401062 &lt;phase_5&gt;: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax //??? 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 401078: 31 c0 xor %eax,%eax //eax:0 40107a: e8 9c 02 00 00 callq 40131b &lt;string_length&gt; 40107f: 83 f8 06 cmp $0x6,%eax //输入长度为6 401082: 74 4e je 4010d2 &lt;phase_5+0x70&gt; 401084: e8 b1 03 00 00 callq 40143a &lt;explode_bomb&gt; 401089: eb 47 jmp 4010d2 &lt;phase_5+0x70&gt; 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx //循环头。新指令 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx //？？？ 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax //计数变量rax 4010a8: 48 83 f8 06 cmp $0x6,%rax //循环6轮 4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; //循环尾 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3: be 5e 24 40 00 mov $0x40245e,%esi //？？ 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd: e8 76 02 00 00 callq 401338 &lt;strings_not_equal&gt; 4010c2: 85 c0 test %eax,%eax 4010c4: 74 13 je 4010d9 &lt;phase_5+0x77&gt; 4010c6: e8 6f 03 00 00 callq 40143a &lt;explode_bomb&gt; 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) //？？？ 4010d0: eb 07 jmp 4010d9 &lt;phase_5+0x77&gt;//跳出 4010d2: b8 00 00 00 00 mov $0x0,%eax 4010d7: eb b2 jmp 40108b &lt;phase_5+0x29&gt; 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax //？？？ 4010e7: 74 05 je 4010ee &lt;phase_5+0x8c&gt; 4010e9: e8 42 fa ff ff callq 400b30 &lt;__stack_chk_fail@plt&gt; 4010ee: 48 83 c4 20 add $0x20,%rsp 4010f2: 5b pop %rbx 4010f3: c3 retq 第六关 隐藏关 隐藏关藏在每一关的后面， GDB使用： 基础： q : quit h : help file prog//加载程序，也可作为gdb命令的参数 r : run k : kill 断点： b : breakpoints break - func_name - *0x400522 - &amp;var - main.c:100//源代码断点，运行前即可 - if con//条件断点 w : watch //观察对象变化时断点 d : delete - b n disable b n 执行： c : continue f : finish stepi n nexti set args ./a.txt //从文件读取输入 检查代码： disas //展示汇编 - funcname - 0x400000 - list edit 检查数据： x : examine p : print 格式控制：/[n][f][u] - n:内存单元个数 - f:显示格式： - x(hex) 按十六进制格式显示变量。 - d(decimal) 按十进制格式显示变量。 - u(unsigned decimal) 按十进制格式显示无符号整型。 - o(octal) 按八进制格式显示变量。 - t(binary) 按二进制格式显示变量。 - a(address) 按十六进制格式显示变量。 - c(char) 按字符格式显示变量。 - f(float) 按浮点数格式显示变量 - u:单元长度（按字节） i : info - r : registers - b [n] - $rsp 表达式： 堆栈： bt : backtrace//显示堆栈 ","link":"https://lonelyuan.github.io/post/CSAPP-Bomblab/"},{"title":"CSAPP - datalab","content":"CSAPP：datalab 读，就硬读。光读没用，得做练习。这个系列记录思路不写答案。 拿到文件夹先读README。 第一个lab，关于位运算。通过受限制的c语言编程实现函数功能。 直接读bits.c，里面有全部信息。每次测试程序都要先make一下。 1：只用按位与和非实现异或 /* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */ &amp;=全为1 ~&amp;=不全为1 异或=不全为0且不全为1，按此逻辑组合即可。 你让我用括号了？？？ 反思：浪费时间，与和或傻傻分不清楚 2：位运算取补码的最小值 英语时间：补码（two's complement）反码：（one's complement）。结合公式很好理解 /* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */ 补码公式： B2Tw(x⃗)=−xw−1+∑i=0w−2xi2iB2T_w(\\vec{x})=-x_{w-1}+\\sum^{w-2}_{i=0}x_i2^i B2Tw​(x)=−xw−1​+i=0∑w−2​xi​2i 最高位是符号位，要求最小值，则最高位为负1，其他位为0。 由于题目限制，只能使用最大为0xff的数字和位运算符，又int长度为4*8=32，故对0x1左移31即得。 3：判断一个数是否为补码的最大值 /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise //0=1111 1111=0000 0000 * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */ 最大值：符号位0，其他位1，即max=011111...=0x7fffffff。 !0=1，故应使每一位化为0，再取非即为1；其他任何数取非都为0。 注意到max+1=~max，补码max加一得到其反码。反码相加得11111111，取反即得0。 特例：-1 = 0x1111 1111也有这个性质，故须排除。 寻找另一性质：!(max+1)=0，而!(-1+1)=1，结合上一步结果即可。 反思：逻辑非！和按位非~ 4：判断所有奇数位为1 /* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */ 要取奇数位，首先构造掩码：0xaaaaaaaa，用&amp;取出奇数位，再异或，取反即得。 错误示范：m=0xaa;m+=m&lt;&lt;8;m+=m&lt;&lt;8;m+=m&lt;&lt;8;算出来个啥？ 5：取相反数 /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */ 常识？？？反码加1 大佬题解：https://wdxtub.com/csapp/thick-csapp-lab-1/2016/04/16/ https://zhuanlan.zhihu.com/p/59534845题不一样？？？ ","link":"https://lonelyuan.github.io/post/CSAPP-datalab/"},{"title":"深度学习入门——jetbot智能小车尝鲜（二）","content":"那个男孩不想玩人工智能呢？在玄学修bug之后，我终于跑通了jetbot自带的深度学习demo。 怎样才能让ai程序发挥好的效果呢？众所周知，所谓人工智能，有多少人工就有多智能。 AI的发展离不开三个要素：算力，算法和算材。根据摩尔定律，算力的发展是不会停滞的（虽然定律快失效了）；进几年来的AI热正是算法的突破，即深度学习相关算法的突飞猛进；而算材就是用来训练模型的数据，未来几年AI应用的进一步落地离不开算材的进一步开发（中国在AI方面的最大优势正在于此）。数据集的丰富程度和有效程度直接影响了AI应用的效果，我将在下文详细说明。 在jetbot项目中，我们也能体验到用“人工”换“智能”的快乐。作为视觉识别类的AI应用，我们要在预设环境里创建数据集，并为其标注。有了数据集，jetbot搭载的NVIDIA牌GPU在方寸之间就能完成海量计算，仅用一颗摄像头就能实现自动避障，目标追踪，自动巡线等等炫酷功能！不要1999，也不要999，只要99！99刀NVIDIA计算卡带回家！（妮维雅打钱） 给萌新理清几个概念： 人工智能，机器学习，深度学习的关系： 深度学习：一种实现机器学习的技术；机器学习：一种实现人工智能的方法 【包含关系图】 AI的发展路径： 弱AI：单独领域工作效率超过人类→ 通用AI：可以广泛应用于大部分领域→ 强AI：有自主意识，即将灭绝人类（不是）→ 现在AI发展到什么地步了：弱AI，有生之年可能见到通用AI 推荐一波汉化的很好的wiki，也有自己原创的内容：http://www.waveshare.net/wiki/JetBot_AI_Kit 本篇详细介绍两个demo的代码和可能遇到的问题，最后附上神经网络的入门笔记。同样是初次接触，大佬请绕道。 demo1：自动避障 小车如何实现自动避障的呢？用通俗的不能再通俗的说法，AI程序通过学习你给他的数据集，知道了什么样的图像是死路，什么样的图像是通路。得到新图像时就能判断是死路的概率有多少，在程序里可以很简单的看出，当这个概率大于0.5的时候就触发小车转向。 具体而言，你要在你的环境里拍至少200张照片，100张标记为通路（free），100张标记为死路（blocked）。这便是你的数据集（dataset）。构建数据集的时候尽量分散在环境的各个位置和各个方向，可以沿边界环绕一圈，走一段距离停下，转一圈，收集8-10张图片。反正你的数据越多，标记的越准确，模型效果越好。 下一步就开始训练模型了，从代码里看出，这个demo使用AlexNet模型，用pytorch实现（废话）。第一次运行你会下载一个244M左右的大文件，在/home/jetbot/.torch/models目录下会看到这个.pth文件。这便是AlexNet了。 继续运行程序，完整的输出结果有三十行，每行后面的小数代表当前模型的准确度（？），程序最后会从这30个模型中选取准确度最高的作为最终模型，也是一个pth文件：best_model.pth 下载文件和训练模型都需要花挺长时间，看到kernel busy，也就是右上角的大黑点不要轻易打断。 什么是模型呢？稍微解释一下机器学习的概念。 模型就是函数，其要素为输入，输出，和变换关系。举例说明： 模型 输入 输出 细菌向养分移动 外界环境的化学信号 催动鞭毛的电信号 学生参加高考 试卷反射的光信号 试卷上问题的答案 小车自动避障 摄像头传输图像信号 前方被堵塞的概率 实际上，知识的本质也是函数，生命延续的关键就在于该生命的模型是否适应环境。这里不深入解释了，觉得惊奇请参阅Yjango的频道https://space.bilibili.com/344849038他用机器学习的角度解释生物进化，非常颠覆三观。 总之训练出来的模型就是这样一个函数。其输入为经过处理的摄像头的图形信号，输出一个0-1的数，越接近1越意味着模型认为小车要撞墙了。但是当他大于0.5的时候就会触发转向，也就实现了自动避障。 AlexNet是2012年提出的一种卷积神经网络（即CNN）算法。首次实现gpu加速。 主流深度学习框架：TensorFlow；PyTorch；Keras 还挺好玩的😀 demo2：目标追踪 基于上一个demo，我们还要下载一个模型，coco数据集神经网络，可以检测90种不同的物体。按教程把.engine文件下载到指定位置，顺着跑就完事了。（引入模型也要花挺长时间） 如果有数据集里的物品，从输出里能看到蓝框标出，小车会自动转向物体，同时还保留了自动避障的程序。 遇到bug：程序仅能读取一张图像进行识别，摄像头更新的功能无法执行。 修bug：摄像头问题 描述：摄像头只要调用了一次，后面就无法在其他地方调用。直接在jupyter上关闭输出并没有作用。而且只要在一个notebook里就能重复调用，换一个就不行。而且并没有报错信息，程序一直处在busy状态。 找到源码，在jetbot/jetbot/camera.py，但是所有样例里面调用摄像头都是用的Camera.instance()方法，而这个instance是在traitlets库里的，于是找到trailets官方文档 Traitlets是一个纯 python 库，支持： 对 python 对象属性的强类型实施( 类型属性称为 &quot;特征&quot; ) ； 动态计算的默认值； 当尝试改变时，自动验证和强制特征属性； 当特征值改变时注册接收通知； 从文件或者 命令行 参数中读取值- 在traitlets上不同层，因这里可以在没有配置机器的情况下使用 traitlets。 Traitlets支持IPython和Jupyter的配置系统，以及IPython交互小部件的声明性 API。 ipython是一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。其中就包括traitlets库。 https://traitlets.readthedocs.io/en/stable/config.html 在这里找到instance的功能：返回现有的类，如果没有就新建一个。 下面是样例中调用摄像头的代码： import ipywidgets.widgets as widgets #图像模块 from IPython.display import display #ipy的显示模块 import traitlets from jetbot import Camera, bgr8_to_jpeg #摄像头驱动，图像格式转换 camera = Camera.instance(width=500, height=500)#初始化摄像头对象 image = widgets.Image(format='jpeg', width=400, height=400)#创建图像 camera_link = traitlets.dlink((camera, 'value'), (image, 'value'), transform=bgr8_to_jpeg) #连接摄像头到图像 display(image) #显示图像 尝试从camera.py里调用原始api。得到报错：Each object must be HasTraits, not &lt;class 'NoneType'&gt;，是说必须为对象指定类型。那么HasTraits这个类型是啥？文档说:任何具有trait属性的类都必须从 HasTraits 继承。 再次梳理调用摄像头的流程： 引入模型：model.load_state_dict(torch.load('best_model.pth')) 连接摄像头：见上文 模型执行： def update(): ...#此处为模型执行函数，将输入图像预处理后，执行模型 update({'new': camera.value}) #初始化该函数 camera.observe(update, names='value') #将update函数设为camera.value的observer 研究一下observe用法：当对象发生变化时调用函数。 https://traitlets.readthedocs.io/en/stable/using_traitlets.html#validation 执行如下代码： import ipywidgets.widgets as widgets #图像模块 from IPython.display import display #ipy的显示模块 import traitlets from jetbot import Camera, bgr8_to_jpeg #摄像头驱动，图像格式转换 camera = Camera.instance(width=500, height=500)#初始化摄像头对象 def update(change): x = change['new'] display(x) #显示图像 update({'new': camera.value}) camera.observe(update, names='value') 输出一大堆数组，说明camera.value是这一大堆像素。而且observe正常运行，数据一直冒出。 array([[[122, 116, 130], [126, 113, 127], [125, 117, 129], ..., [ 84, 96, 107], [ 82, 96, 113], [ 93, 93, 113]], [[120, 119, 130], [122, 120, 119], [118, 123, 130], ..., 然而就是不实时更新数据，卒。 👴佛了。 神经网络笔记 AlexNet——CNN 2012年由Hinton学生Alex提出，是Lenet加宽版。其采用了一系列的新技术：成功的引用了relu、dropout和lrn等trick，首次采用gpu加速。其包含65万神经元，5个卷积层，三个后面带有池化层，最后用了三个全链接。 ","link":"https://lonelyuan.github.io/post/jetbot-2/"},{"title":"单片机入门——jetbot智能小车尝鲜(一)","content":"那个男孩不想玩树莓派呢？机缘巧合之下，我得到了一台价值上百美元的智能小车的使用权。 小车的核心是NVIDIA家的jetson-nano开发板，这款19年三月才发布的微型AI计算机可谓是平民级核弹，四核A57的CPU，128核心Maxwell架构的GPU，4g内存，支持4k视频解码，而且这只五脏俱全的麻雀只需要5W的电源支持，任何一支充电宝都可以胜任。而它的定位是用它简单的搭建人工智能应用，非常的amazing。 本文的目的,不完全是新手教程,还有自己学习过程的记录和分享.初次接触,多有疏漏,欢迎指教. 【图片：主板证件照】 给萌新理清几个概念： 单片机：Single-Chip Microcomputer。 树莓派：一款著名的微型电脑品牌（本文介绍的jetson-nano可以理解为是树莓派的竞品，相比树莓派，这款单片机价格更高，性能更好，主打AI应用） jetbot：以jetson-nano为平台搭建的ai机器人应用，也就是所谓智能小车 硬件组装:积木和电工 本人拿到的是零件状态的小车，所以首先讲一讲组装的问题。有关具体步骤，官网教程十分详细，贴个连接给懒人吧：https://www.ncnynl.com/archives/201904/2927.html 这里只讲一讲我作为初学者的一些理解。首先，玩单片机和玩积木的区别就在于编程。当然，入门单片机还需要其他技能。比如，电工技能：你需要进行线材的简单加工，引脚的焊接，准备基本的工具就好，毕竟那个男孩没有一根热热的棒子呢（指电烙铁）。然后，各个部件的拼接固定需要一些做手工的技巧，这个也不用怕，赫鲁晓夫曾经说过：热熔胶可以让我们创造奇迹。 在这个层面上，初学者会浪费许多耗材，这是必要的练习手段，所以初学者也可以从最简单的芯片入手。同时你还要学习诊断硬件方面的问题，万用表会很有帮助。关于更详细的工具和耗材的需要，请自行查阅单片机入门有关资料。 在本项目中，焊接工作已经完成，剩下的连接都是可插拔式的。我们只需要两把螺丝刀即可完成组装。即便如此，本人还是花了一晚上才把小车点亮，原因是我得到的线材损坏近半，只得自己寻找和修理。 下面分析一下小车的结构: jetson-nano开发板:即本机的主板,可以看到有两层芯片,上层为核心层,包括cpu,gpu和内存可以像笔记本内存条一样拆卸;下层为主板,用于连接各种设备 intel无线网卡:将上层拆下即可安装.令连出两根天线,缠绕机身即可. PiOLED显示器和拓展版:连接在I2C主线上 相机模块:官方样例展示了只用一个摄像头通过深度学习进行自动避障的demo. 马达和其驱动板:下文重点讲解 开发板就可以运行一个完整的Ubuntu系统,其余设备是为其拓展功能的. 硬件架构：驱动芯片和I2C主线 我在玩小车的过程中耽误最长时间的就是电机（即马达）驱动了，借此讲一讲系统架构的事。 让轮子前进要靠马达，给马达供电不能直接让主板来做，要让主板给另一块小芯片发送指令，这块小芯片连接着独立的电源，收到指令才会给马达通电。这块小芯片即是电机驱动板。 驱动芯片是从硬件走向软件的第一道桥梁，可以类比PC的IO设备来理解。和物理世界交互的各种功能，都需要有专门的驱动芯片。包括马达，摄像头，扬声器，机械臂等等，只不过有的可以集成在一起，如：小车上的摄像头，PiOLED显示器等；有的出于体积，安全性，模块化的考虑需要分开，如电机和驱动板。 电机驱动板 官方给出的电机驱动板型号为:DC-Stepper-Motor PCA9685+TB6612.可以驱动两个步进电机或四个直流电机。（四轴飞行器gkd）本项目只用到了两个直流电机。 各个引脚的讲解：https://learn.adafruit.com/adafruit-stepper-dc-motor-featherwing/pinouts 电机驱动板上共连接有10根跳线。一对电源输入，两对为马达输出。还需四根母-母杜邦线来连接至主板的I2C总线,具体来说,是在LED屏旁边的拓展板。分别是： 驱动板引脚 主板I2C引脚 功能 3V3 3V3 为驱动板供电,即电源正极 GND GND 接地,即电源负极 SDA 3 串行数据线，传输数据 SCL 5 串行时钟线，传输控制信号 【图片：驱动板引脚】 接错了有可能烧坏板子哦 I2C总线 所谓总线,可以理解为一条街道,每个设备就是街道两旁的房子,房内的住户出门走亲访友就是数据在不同设备间的传输。 I2C总线是常用于嵌入式系统的一种简易串行总线.他有简洁的双线结构(SCL+SDA),每个设备都有一个地址码,以此实现多个设备相互通讯。设备有主从之分，主设备/主端必须是带有CPU的逻辑模块，在同一总线上同一时刻使能有一个主端，可以有多个从端，从端的数量受地址空间和总线的最大电容 400pF的限制。 可以使用i2c-tools调试i2c总线: 检测有几组i2c总线在系统上i2cdetect -l 检测挂载在i2c-1上的设备i2cdetect -r -y 1 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- -- -- -- -- -- 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- --（led） 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: 60 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --（电机驱动） 70: 70 -- -- -- -- -- -- -- 查看设备(地址为0x20)上所有寄存器的值i2cdump -f -y 1 0x20 对单个寄存器进行读写: i2cset -f -y 1 0x20 0x77 0x3f（设置i2c-1上0x20器件的0x77寄存器值为0x3f） i2cget -f -y 1 0x20 0x77 （读取i2c-1上0x20器件的0x77寄存器值） jetson-nano开发板提供了6条I2C主线,以及其他丰富的接口。理解这些接口是拓展各种设备的前提。 软件连接:ssh远程桌面 从头开始的话，我们还需要往sd卡里烧写系统镜像，不过我拿到的已经完成了这一步骤，故不再赘述。 在官方教程中,需要hdmi线连接显示屏,usb连接鼠标键盘,来进入jetson-nano的Ubuntu系统.其目的在于首次连接一个无线网络(手机热点),之后只要电脑和nano在同一网络,即可用电脑访问nano的IP(8888端口),直接操纵jetbot. 由于我并没有hdmi线,只有一根网线,反正都能插,插谁不一样?所以用网线把小车和笔记本连接起来组成局域网.用ssh的方式进入nano的系统.具体步骤如下: ip发现:在插入网线前后执行两次:arp -a,比较不同,会发现多出一个地址,类型为动态,此即为小车的内网IP.小车的led屏也会自动显示其ip.如eth0:192.168.x.x (如此,我们可以直接从浏览器访问这个ip的8888端口,并能运行jupyter notebook了.但我们不能让小车拖着网线跑啊,所以还是要配置无线网络.) 将笔记本的wifi连接设为对以太网可共享,这一步是为了让小车能通过笔记本联网 端口扫描:nmap -sT 192.168.x.x发现22端口开放,故连接之:ssh jetbot@192.168.x.x,就用官方教程给的账户密码. 连接成功后,就可以用命令行工具连接WiFi了,但还是安装一下远程桌面吧. 配置远程桌面:执行以下命令: sudo apt-get install tightvncserver sudo apt-get install xrdp sudo apt-get install vnc4server tightvncserver 之后在你的主机win+R，输入mstsc,进入远程登录桌面，输入小车的ip地址，点击连接 在xrdp的登陆界面输入用户名密码即可打开远程桌面 (这里我用jetbot用户登陆遭遇闪退,用root就可以,不清楚原因)(另外开了远程桌面内存疯涨,就很离谱) 连接上wifi后,你能在小车的led板上看到另一个ip:wlan0:192.168.x.x 不管怎样,连接上wifi之后的操作就很简单了.跟着教程,跑一跑demo,还是很有成就感的. 排查bug 然而demo并没有让我跑出来,且指向同一个错误: OSError: [Errno 121] Remote I/O error 沿着jupyter notebook的报错一直走,一直到了最底层,向设备写入数据报错,remote IO error. 看起来像是硬件的问题。一步一步排查呗 怀疑跳线错误 更换跳线——无果 用万用表测量线两端的信号——正常，排除连接问题 时钟线保持3.3v每隔几秒跳到2.2v又回来，结合i2c的原理应该是正常现象？ 数据线同样保持3.3v，间断跳至2.3，2.0 软件方法检验设备连接性 用i2ctools可以检测到设备，拔下4根接线，在0x60,0x70处的设备消失（一个是i2c线，一个是逻辑供电？） 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- -- -- -- -- -- 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- -- 然而，在通电状态下，把连线拔下又插上之后，i2c又能检测到设备，然后示例代码就能运行了？？？ 迷惑。所以开机时机器并没能正确载入设备，反倒是重新连接后能识别了？？？本来我都要换驱动板了，orz。 又或者是和驱动板上的reset按钮有关？等下次遇到问题再说吧。 拾遗 linux内存占用 led屏会显示内存占用，然鹅时间长了总会到90%以上，可我并没有运行什么程序。 经查阅此处显示的是实际占有的加上buffer和cached mem部分，可以理解为缓存的，随时清理，并不占用实际内存。 可用top命令查看内存详情。 供电问题 用充电宝供电方便，但是只要一断电系统就会重启，这对linux系统而言伤害很大。 而在充电宝电量不满时，经常发生开不了机的问题，大概是因为电量不足导致电压不稳。 关机命令： sudo shutdown -h now 重启： shutdown -h now -r 下一篇：操纵小车和AI初探 参考链接 https://github.com/NVIDIA-AI-IOT/jetbot/wiki/Hardware-Setup https://robocarstore.cn/ http://www.gpus.cn/gpus_list_page_techno_support_content?id=50 https://www.jianshu.com/p/789944463fd7 ","link":"https://lonelyuan.github.io/post/jetbot-1/"},{"title":"About Me","content":" Do not go gentle into that good night, Old age should burn and rave at close of day; Rage, rage against the dying of the light. 🐭我是谁 存在主义者。 性别男，爱好女。 本阶段人生目标：想理解计算机的一切。 目前还是Web狗一条。 🍌本博客宗旨 尽量不制造垃圾。 什么是垃圾：情绪的，傲慢的，重复的，信息熵低的 争取周更。 草稿也算周更！程序员的事，能叫拖更吗？ 🤺同好检测器 Masterpiece //排名按时间顺序 文： 大刘 王小波 《GEB》 《量子窃贼》三部曲 剧： Re:0 爱死机 Rick&Morty 黑镜 第九艺术： Minecraft Bioshock: Infinity Celeste 戴森球计划 oxigen not include 🌌三观 world view | 放眼寰宇 资本主义秩序下的世界无可避免地走到周期的末尾，而第四次工业革命依然前途渺茫，所谓百年未有之大变革，人类文明正走向混沌的路口。 outlook on life and value | 聚焦个人： 当赛博朋克悄然成为现实，当手机成为不可或缺的器官，当消费主义暴打了理想、蒙骗了爱情，当记录了你的喜怒哀乐的数据比你更值钱； 作为信息时代原住民的我们，作为被资本主义异化、被互联网原子化了的个体，作为在内卷或被内卷中焦虑挣扎的普通人—— 是否有勇气走出舒适区，向无处不在的信息茧房说不？ 是否愿意审视自我的成见，尝试理解他人？ 是否敢于走出自闭，建立真实深刻的社会关系？ 是否相信人类意志的成长性，不断逼近生理和心理的极限？ 是否敢于自我解构，而不放弃探求生活的真相？ 是否接受人生的无意义，并选择继续热爱这一切？ ","link":"https://lonelyuan.github.io/post/about/"}]}