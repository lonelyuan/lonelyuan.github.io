<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lonelyuan.github.io</id>
    <title>lonelyuan&apos;s Blog</title>
    <updated>2021-06-11T16:35:00.905Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lonelyuan.github.io"/>
    <link rel="self" href="https://lonelyuan.github.io/atom.xml"/>
    <subtitle> &gt;&gt; 不要恐慌 | Don&apos;t Panic </subtitle>
    <logo>https://lonelyuan.github.io/images/avatar.png</logo>
    <icon>https://lonelyuan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, lonelyuan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[基于vivado的基于FPGA的一种基于MIPS的一种五级流水线CPU实现的注释]]></title>
        <id>https://lonelyuan.github.io/post/mips_pipeline_cpu/</id>
        <link href="https://lonelyuan.github.io/post/mips_pipeline_cpu/">
        </link>
        <updated>2021-06-09T09:14:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文所述为计算机组成原理课拓展实验的相关记录，基于“龙芯体系结构与CPU设计教学实验系统”<br>
项目官网： http://www.loongson.cn/business/general/teach/356.html；<br>
相关资料代码：#TODO:: github仓库<br>
PS：标题可简记为《基于基于的一种基于的一种实现》</p>
</blockquote>
<h1 id="吐槽时间">吐槽时间</h1>
<p>快考试了，👴发觉👴计组学了个🔨，👴去年也学了个🔨，但是去年可以归因于晦气的晦气，今年只能说自己晦气。难道还要重蹈去年的晦气吗？👴本应该回去背课本，刷考研题，但是👴一看ppt就想起我们敬爱的《计算机组成原理》课的任课老师，丐哥老师反复强调的至理名言：“听不懂的举手（无停顿）都没举手，都听懂了，非常好。”本人十分钦佩丐哥老师对幽默感的独特理解。<br></p>
<p><em>（但是特此声明：本人不了解、不认同其关于&quot;5G是个几把&quot;，&quot;高晓松很nb这个人&quot;，&quot;钱=浪漫&quot;等议题的看法）</em><br></p>
<p>而且👴这人很怪，课本上的重点，不好玩；选做的实验，好玩！哎就是玩，怪不得卷不过别人，你也配卷？滚去考研吧。<br></p>
<p>众所周知，计算机学生的本科生涯，如果能做到在自己设计的CPU上运行自己写的操作系统并用自己写的编译器跑代码，那就非常成功了。👴差不多，👴能在自己搜的代码上写自己的注释并用自己的电脑截图，都是三个&quot;自己&quot;。那么今天给大家爆个啥捏，流水线奥。<br></p>
<h1 id="用计算机造计算机">“用”计算机→“造”计算机</h1>
<p>上回书说到（#TODO:: CSAPP大篇），汇编器(as)让我们得到了机器能看懂的比特流，最后一步只需要连接器(ld)将其和其他调用一起载入内存。这回答了程序如何在CPU这个平台上运行的问题，然而一个更基本的问题是，这个现有的平台是如何实现的？一个粗略的认识是，我们知道这些足以实现CPU的复杂的逻辑，其最小单元总对应到简单的诸如逻辑门上面，但是落实到真正的物理实现之上，如何使效率最高？功耗最小？这些问题所跨越的复杂度的量级依然是一片巨大的迷雾。照亮这片迷雾的知识，大概隶属于IC学科。<br></p>
<p>However，作为CS专业而不是IC专业，我们的目标仅在于理解所谓“组成原理”。在IC产业的复杂度规模数轴上，向下是专有芯片（又称嵌入式？），功能专用，规模较小；向上是通用芯片，即手机电脑等的核心，其难度不言而喻。位于中间的FPGA则既兼顾了自由度也考虑了速度，因此，这玩意能满足CS本科教学的需要（主要是便宜耐操）。<br></p>
<h1 id="高贵的ic工程师都用啥轮子">高贵的IC工程师都用啥轮子</h1>
<p>Vivado是一个FPGA集成设计平台（也算一个EDA？），他主界面左侧的工作流窗口很好的概括了利用FPGA开发的基本流程。即</p>
<ul>
<li>编写设计源码(Source)：使用Verilog语言编写逻辑或引入IP
<ul>
<li>设计仿真模拟(Simulation)：通过观察仿真波形图和编写testbench来对设计进行debug
<ul>
<li>综合(Systhesis)门级网表：从RTL级描述降维到门级网表
<ul>
<li>生成(Implementation)布局布线：根据管脚约束，将依然是虚拟的门级连线落实为实际的线路
<ul>
<li>进行硬件编程(program)：生成比特流并写入目标设备</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://lonelyuan.github.io/post-images/1623373911775.png" alt="" loading="lazy"></figure>
<blockquote>
<p>名词解释：<br>
IC：集成电路<br>
FPGA：现场可编程门阵列<br>
Verilog：一种硬件描述语言，语法涵盖了自顶向下五个抽象层面：系统级、算法级、RTL级、门级、开关级。<br>
RTL：寄存器传输级。一般使用最多的就是RTL级。<br>
IP：Intellectual Property内核模块，可以理解为将代码封装为函数。分为，软IP内核(soft IP core)，固IP内核(firm IP core)和硬IP内核(hard IP core)3个层次，相当于集成电路的毛坯、半成品和成品。<br>
SoC：片上系统，大概是芯片及其装载的第一层软件接口的集合，很宽泛的概念。<br>
EDA：电子设计自动化。</p>
</blockquote>
<p>由此，我们可以大致探清了这片迷雾，CPU的设计如何从高抽象层次的逻辑，梳理成最底层的逻辑门，再实现为小小的芯片。那么我们有了轮子，要造一个CPU，还要确定目标指令集。由于本项目由龙芯公司赞助，那必然要选MIPS了。</p>
<h1 id="mips指令集格式">MIPS指令集格式</h1>
<p>啥叫指令集呢，学过几种语言就不难理解。高级程序语言规定每个ascii码的组合所对应的含义，指令集规定0和1的组合所对应的寄存器，ALU的各种信号。MIPS指令集从属于RISC系列，最基本的指令有31条。<br></p>
<p>//讲到这里本应该打个表展示31条指令，但是👴懒得打了。<br></p>
<p>Vivado中，.coe文件用于初始化IP核，本实验给出的.coe文件中存放了几条指令，不过是16进制数字，写个小脚本打印成可读的形式。</p>
<pre><code class="language-python"># mips_dump.py
with open(path,'r') as f:
    hex_list = f.read().split('\n')
    bin_list = list(map(lambda x:bin(int(x,16)),hex_list))
    # bin_code_list = [&quot;{:0&gt;32}&quot;.format(i[2:],'b') for i in bin_list]
    bin_code_list = [i[2:].zfill(32) for i in bin_list]

IType_op_dict = {
    '001000':'addi',
    '001001':'addiu',
    '001100':'ori',
    '001101':'xori',
    '001111':'lui',
    '100011':'lw',
    '101011':'sw',
    '000100':'beq',
    '000101':'bne',
    '001010':'slti',
    '001011':'sltiu'
}

RType_func_dict = {
    '100000':'add',
    '100001':'addu',
    '100010':'sub',
    '100011':'subu',
    '100100':'and',
    '100101':'or',
    '100110':'xor',
    '100111':'nor',
    '101010':'slt',
    '101011':'sltu',
    '000000':'sll',
    '000010':'srl',
    '000011':'sra',
    '000100':'sllv',
    '000110':'srlv',
    '000111':'srav',
    '001000':'jr',
}

def f_hex(ori, width): # bin-&gt;hex
    return &quot;0x&quot;+hex(int(ori,2))[2:].zfill(width)
def f_reg(ori): # print register num
    return &quot;$&quot;+str(int(ori,2)).zfill(2)
def code_dump(type:str,inst:str,params:list):
    if type == 'R':
        s = inst.ljust(6) + &quot;, &quot;.join([f_reg(params[0]),f_reg(params[1]),f_reg(params[2]),f_hex(params[3],2)])
    elif type == 'I':
        s = inst.ljust(6) + &quot;, &quot;.join([f_reg(params[0]),f_reg(params[1]),f_hex(params[2],8)])
    else:
        s = inst.ljust(6) +'0x'+ hex(int(params[0],2))[2:].zfill(8)
    return s

assembly_list = []
for _ in bin_code_list:
    op = _[:6] # public field
    try:
        if op == '000000': # R-Type
            rs = _[6:11]
            rt = _[11:16]
            rd = _[16:21]
            shamt = _[21:26]
            func = _[26:]
            assembly_list.append(code_dump('R',RType_func_dict[func],[rs,rt,rd,shamt]))
        elif op in ['000010', '000011']:  # J-Type
            target = _[6:]
            assembly_list.append(code_dump('J','j',[target]))
        else: # I-Type
            rs = _[6:12]
            rt = _[12:18]
            imm = _[18:]
            assembly_list.append(code_dump('I',IType_op_dict[op],[rs, rt, imm]))
    except Exception as e:
        assembly_list.append(&quot;***** decode error! *****&quot;)

head = &quot;+---hexdump----|--------- assembly ---------+&quot;
print(head)
addr = 0
for i in range(len(bin_code_list)):
    print(&quot;|&quot;+ f_hex(bin(addr),2) +&quot; &quot;+ hex_list[i] +&quot; | &quot;+ assembly_list[i].ljust(26) + &quot; |&quot;)
    addr += 4
tail = &quot;+&quot;+&quot;-&quot;*43+&quot;+&quot;
print(tail)
</code></pre>
<p>打印出来👴傻了，怎么还有不在31条范围里的。</p>
<pre><code>+---hexdump----|--------- assembly ---------+
|0x00 24010001 | addiu $00, $04, 0x00000001 |
|0x04 00011100 | sll   $00, $01, $02, 0x04  |
|0x08 00411821 | addu  $02, $01, $03, 0x00  |
|0x0c 00022082 | srl   $00, $02, $04, 0x02  |
|0x10 28990005 | slti  $09, $36, 0x00000005 |
|0x14 07210010 | ***** decode error! *****  |
|0x18 00642823 | subu  $03, $04, $05, 0x00  |
|0x1c AC050014 | sw    $00, $20, 0x00000014 |
|0x20 00A23027 | nor   $05, $02, $06, 0x00  |
|0x24 00C33825 | or    $06, $03, $07, 0x00  |
|0x28 00E64026 | xor   $07, $06, $08, 0x00  |
|0x2c AC08001C | sw    $00, $32, 0x0000001c |
|0x30 11030002 | beq   $16, $12, 0x00000002 |
|0x34 00C7482A | slt   $06, $07, $09, 0x00  |
|0x38 24010008 | addiu $00, $04, 0x00000008 |
|0x3c 8C2A0014 | lw    $02, $40, 0x00000014 |
|0x40 15450004 | bne   $20, $20, 0x00000004 |
|0x44 00415824 | and   $02, $01, $11, 0x00  |
|0x48 AC2B001C | sw    $02, $44, 0x0000001c |
|0x4c AC240010 | sw    $02, $16, 0x00000010 |
|0x50 0C000019 | j     0x00000019           |
|0x54 3C0C000C | lui   $00, $48, 0x0000000c |
|0x58 004CD007 | srav  $02, $12, $26, 0x00  |
|0x5c 003AD804 | sllv  $01, $26, $27, 0x00  |
|0x60 0360F809 | ***** decode error! *****  |
|0x64 A07A0005 | ***** decode error! *****  |
|0x68 0063682B | sltu  $03, $03, $13, 0x00  |
|0x6c 1DA00003 | ***** decode error! *****  |
|0x70 00867004 | sllv  $04, $06, $14, 0x00  |
|0x74 000E7883 | sra   $00, $14, $15, 0x02  |
|0x78 002F8006 | srlv  $01, $15, $16, 0x00  |
|0x7c 1A000008 | ***** decode error! *****  |
|0x80 002F8007 | srav  $01, $15, $16, 0x00  |
|0x84 240B008C | addiu $00, $44, 0x0000008c |
|0x88 06000006 | ***** decode error! *****  |
|0x8c 8D5C0003 | lw    $21, $48, 0x00000003 |
|0x90 179D0007 | bne   $57, $52, 0x00000007 |
|0x94 A0AF0008 | ***** decode error! *****  |
|0x98 80B20008 | ***** decode error! *****  |
|0x9c 90B30008 | ***** decode error! *****  |
|0xa0 2DF8FFFF | sltiu $31, $35, 0x00003fff |
|0xa4 0185E825 | or    $12, $05, $29, 0x00  |
|0xa8 01600008 | jr    $11, $00, $00, 0x00  |
|0xac 31F4FFFF | ori   $31, $19, 0x00003fff |
|0xb0 35F5FFFF | xori  $31, $23, 0x00003fff |
|0xb4 39F6FFFF | ***** decode error! *****  |
|0xb8 08000000 | j     0x00000000           |
+-------------------------------------------+
</code></pre>
<p>总之，代码都给你了，下面给出一个vivado实验的完整流程，不全面，但是都是踩坑经验。</p>
<h2 id="vivado使用">Vivado使用</h2>
<p>本流程环境：Vivado 2020.2<br><br>
开发板型号：LS-CPU-EXB-1<br></p>
<h3 id="创建项目">创建项目</h3>
<p>下一步，下一步，下一步，，，确认。<br>
这一步只需要注意选器件，一定要选对。否则有可能在Implementation遇到“端口电平不匹配”“端口数量不足”等硬件问题。当然，有可能型号相近的性能规格也差不多，这属于玄学问题了。实验书上选择的的型号应该是“xc7a200tfbg676-2”，但是👴用的是“xc7a200tfbv676-2”也能成功写入比特流。</p>
<h3 id="编写代码并仿真">编写代码并仿真</h3>
<p>本实验的代码大多来自“2016-04-14”，那就是龙芯公司给的源代码。在该系列代码中有一处bug，位于“单周期CPU实验”的single_cycle_cpu.v中。214行，<code>resetn</code>应该为<code>{4{resetn}}</code>，写使能位宽应为为4。<br>
<img src="https://lonelyuan.github.io/post-images/1623379687932.png" alt="" loading="lazy"></p>
<p>下面讲解一下项目结构，所有实验都是类似的：<br>
<img src="https://lonelyuan.github.io/post-images/1623374928604.png" alt="" loading="lazy"><br>
三个顶层文件夹分别对应Add Source里的三类源文件：添加设计，添加仿真，添加约束。如果不需要上板，只完成仿真，那么只需要添加设计（几个.v），添加仿真（testbench.v/tb.v）就足够了，xxx_display.v也是上板需要的故而可以忽略。（实际上，图中我用箭头标记的都用不到）。</p>
<p>编写tb，无非是给tb里声明为input的信号赋值，还可以使用<code>#xx</code>，让tb等待一段时间。</p>
<p>点击Run Simulation，等一会就能看到波形图。波形图有三种颜色：</p>
<ul>
<li>绿色代表信号正常正常；</li>
<li>红色的X代表信号不确定；</li>
<li>蓝色的Z代表信号休眠。</li>
</ul>
<p>一般遇到红X，都是未初始化问题。蓝Z大概是没有模块调用这些信号。Vivado波形图的操作极其难用，这里介绍一个相对好用的操作：左键从左向右水平划，会直接缩放到鼠标滑过的这一段。右键选择进制等操作略。</p>
<figure data-type="image" tabindex="2"><img src="https://lonelyuan.github.io/post-images/1623378896380.png" alt="" loading="lazy"></figure>
<p>仿真需要注意的问题：</p>
<ul>
<li>如果文件没问题，模块调用层次会被自动解析从而呈现成一棵树，而不是好几个顶层文件。</li>
<li>注意set as top，应该设为根部模块（调用其他模块的）和tb
<ul>
<li>//如果设错了可能在Implementation会出现“端口未赋初值”的报错。</li>
</ul>
</li>
<li>中文乱码是经典字符集问题，有可能在换行处导致语法错误。建议统一换成utf-8。
<ul>
<li>简单解决方法：从vscode里复制。</li>
</ul>
</li>
</ul>
<h3 id="引入ip核">引入IP核</h3>
<p>对于流水线CPU，data_ram和inst_rom需要同步写，自己实现比较复杂，故直接实例化封装好的内存块IP。如何引入？首先说明几种文件格式：</p>
<ul>
<li>.dcp 原意为checkpoints文件，是一种加密压缩文件。用于封装模块方便调用，但对版本要求极其敏感。</li>
<li>.xci/.xcix IP核配置文件，本质是一个xml。是Vivado在新版本提倡使用xci而不是dcp。</li>
<li>.xdc 管脚约束文件。在Implementation用到，此处按下不表。</li>
</ul>
<p>这几种文件格式都是可以直接Add Source添加进来的。实验老师同时提供dcp和xci文件，添加dcp崩屎了，原因估计如上。添加xci之后，提示我将IP更新为core cointainer的形式</p>
<figure data-type="image" tabindex="3"><img src="https://lonelyuan.github.io/post-images/1623377228417.png" alt="" loading="lazy"></figure>
<p>更新就完了。然后需要等一会，IP还要执行一步synth，这段时间里IP属于锁住的状态，不能修改配置。</p>
<figure data-type="image" tabindex="4"><img src="https://lonelyuan.github.io/post-images/1623377562565.png" alt="" loading="lazy"></figure>
<p>注意更换器件后，IP核都会锁住。这表示IP的配置和当前环境不匹配。对所有IP锁住的问题，只需要点击菜单栏Reports→Reports IP  Status，然后点upgrade即可解除锁定。</p>
<h3 id="我直接上板">我直接上板</h3>
<p>直接点生成比特流，会一步步的按工作流向下运行，等待几分钟就能愉快的收获你的报错了！</p>
<figure data-type="image" tabindex="5"><img src="https://lonelyuan.github.io/post-images/1623379096063.jpg" alt="" loading="lazy"></figure>
<p>在把上文提到的坑都踩过一遍之后，终于没有critical warning，泪目。</p>
<p>但是此时实验课已经结束了，👴偷溜到没人的实验室，并留下以下珍贵画面</p>
<figure data-type="image" tabindex="6"><img src="https://lonelyuan.github.io/post-images/1623379266894.jpg" alt="" loading="lazy"></figure>
<p>然后👴发现data_ram写入失败。但是👴没时间搞了，👴还是滚去复习课本吧。</p>
<h2 id="多周期流水线cpu原理">多周期流水线CPU原理</h2>
<p>最后，继续复习计组。<br></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我和拖延症的战争]]></title>
        <id>https://lonelyuan.github.io/post/ProcrastinationWar/</id>
        <link href="https://lonelyuan.github.io/post/ProcrastinationWar/">
        </link>
        <updated>2021-04-15T15:01:29.000Z</updated>
        <content type="html"><![CDATA[<p>//这是一篇永远不会完结的文章。<br>
//先准备目录</p>
<p>0x01 | 拖延症的生理基础</p>
<ul>
<li>习惯的重要性</li>
<li>习惯行为学</li>
<li>生理基础：多巴胺</li>
<li>演化论证据</li>
</ul>
<p>0x02 | 对拖延症的方法论综述</p>
<ul>
<li>可行的计划</li>
<li>积极的环境</li>
<li>正向的反馈</li>
<li>能战胜拖延症的，是爱</li>
</ul>
<p>0x03 | 高级作战录像</p>
<ul>
<li>拖延循环</li>
<li>拖延症不是你失败的唯一原因</li>
<li>此身不灭，壮志不渝</li>
</ul>
<p>0x04 | 西西弗斯计划</p>
<ul>
<li>模型比方法更重要</li>
<li>对话机制</li>
<li>提示机制</li>
<li>这场战争，我们还没输，但也只能说还没输</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSAPP-Bomblab]]></title>
        <id>https://lonelyuan.github.io/post/CSAPP-Bomblab/</id>
        <link href="https://lonelyuan.github.io/post/CSAPP-Bomblab/">
        </link>
        <updated>2020-02-20T14:43:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="csappbomblab">CSAPP：Bomblab</h1>
<p>逆向的传统艺能拆炸弹，👴的青春回来了。</p>
<p>文件结构：</p>
<pre><code>bomb
   ├── README
   ├── bomb
   └── bomb.c
</code></pre>
<p>只有一个程序，给的源码基本没用，我们要用逆向工程的方法理解程序，找到正确的字符串。</p>
<p>讲反汇编器的结果导出：<code>objdump -d bomb &gt; bomb.txt</code></p>
<p>可以看到有6关，每一关接受一个字符串，若跳转到explode_bomb函数，则答案错误。</p>
<h3 id="第一关字符串比较">第一关：字符串比较</h3>
<pre><code class="language-assembly">0000000000400ee0 &lt;phase_1&gt;:
  400ee0:	48 83 ec 08          	sub    $0x8,%rsp
  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi
  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;
</code></pre>
<p>逻辑是直接比较字符串是否相等，不过<code>$0x402400</code>不是程序内地址，说明答案被藏在了我们看不到的内存位置。</p>
<p>于是上GDB，在&lt;phase_1&gt;下断点，<code>stepi</code>单步执行到callq之前，查看寄存器:<code>x\s $esi</code>，得到答案。（每台电脑的答案都不一样）</p>
<h3 id="第二关循环">第二关：循环</h3>
<pre><code class="language-assembly">0000000000400efc &lt;phase_2&gt;:
  400efc:	55                   	push   %rbp //压栈
  400efd:	53                   	push   %rbx
  400efe:	48 83 ec 28          	sub    $0x28,%rsp //开辟栈帧
  400f02:	48 89 e6             	mov    %rsp,%rsi//栈顶地址→rsi参数二
  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;
</code></pre>
<p>如函数名所示，读6个数字，为什么是6呢，大概是因为存放参数的寄存器总共有6个吧。（然而并不）</p>
<p>可以看到调用前开辟了0x28的栈上空间，足够存放6个整数。栈顶地址被存入%rsi，以此传递该地址。</p>
<pre><code class="language-assembly">000000000040145c &lt;read_six_numbers&gt;:
//%rsi:父进程&lt;phase_2&gt;的栈顶地址
  40145c:	48 83 ec 18          	sub    $0x18,%rsp //栈帧长24
  401460:	48 89 f2             	mov    %rsi,%rdx  //rsi→参数三：num1
  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx //rsi+4→参数四：num2
  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax  //rsi+20→rax
  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp) //rax→栈顶+8：num6
  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax //rsi+16→rax
  401474:	48 89 04 24          	mov    %rax,(%rsp) //rax→栈顶：num5
  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9 //rsi+12→参数六：num4
  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8 //rsi+8→参数五：num3
  401480:	be c3 25 40 00       	mov  $0x4025c3,%esi//0x4025c3:&quot;%d %d %d %d %d %d&quot;
  401485:	b8 00 00 00 00       	mov    $0x0,%eax //返回值赋0
  40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; //sscanf()
  40148f:	83 f8 05             	cmp    $0x5,%eax //返回值和5比较，即输入6个值才能通过
  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;
  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;
  401499:	48 83 c4 18          	add    $0x18,%rsp //出栈
  40149d:	c3                   	retq   
</code></pre>
<p>看&lt;read_six_numbers&gt;，%rsi中的地址以4为步长被分别储存。猜测sscanf函数的返回值中，第一个表示输入参数的个数；程序要求6个输入，加上rsi被占用，于是多的两个存入栈中。且sscanf函数的返回值按参数寄存器（多的地址在栈上）存放的地址传输，即输入值被按顺序存入phase_2的栈帧中。</p>
<pre><code class="language-assembly">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)  //栈顶位置取双字和1比较
  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;
  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;
  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax //循环头：num1→eax
  400f1a:	01 c0                	add    %eax,%eax   // eax*2
  400f1c:	39 03                	cmp    %eax,(%rbx) //和num2比较
  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt; //相等才通过
  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;
  400f25:	48 83 c3 04          	add    $0x4,%rbx //rbx增4
  400f29:	48 39 eb             	cmp    %rbp,%rbx //rbx和rsp+24比较，相等则跳出
  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt; //循环尾，循环共6轮
  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt; 
  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx //num2地址→rbx
  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp//rbx地址→rbp
  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt; //开始循环
</code></pre>
<p>跳出&lt;read_six_numbers&gt;后，首先检查栈顶地址指向的值是否为1，即第一个数字是1。</p>
<p>之后进入循环，循环体每次都会把当前数字*2和下一个数字比较，即每个数字都是前一个的二倍；%rbx作计数变量，共循环6次。答案呼之欲出。</p>
<h3 id="第三关分支">第三关：分支</h3>
<pre><code class="language-assembly">0000000000400f43 &lt;phase_3&gt;:
  400f43:	48 83 ec 18          	sub    $0x18,%rsp 
  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx //rsp+12→rcx: mun2
  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx //rsp+8→rdx: mun1
  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi //0x4025cf:  &quot;%d %d&quot;
  400f56:	b8 00 00 00 00       	mov    $0x0,%eax
  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;
  400f60:	83 f8 01             	cmp    $0x1,%eax  //不少于一个输入
  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;
  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;
  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp) //
  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt; //超过7则爆炸
  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax //取num1
  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8) 
</code></pre>
<p>此处<code>*</code>相当于c中的取地址符<code>&amp;</code>，</p>
<pre><code class="language-assembly">400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax
400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;
······
</code></pre>
<p>这里有7段形式重复的代码，结合第一个数字不能大于7，猜测这里是switch型结构。</p>
<pre><code class="language-assembly">400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;
400fb2:	b8 00 00 00 00       	mov    $0x0,%eax
400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;
400fb9:	b8 37 01 00 00       	mov    $0x137,%eax 
400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax //比较num2和eax
400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;
400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;
400fc9:	48 83 c4 18          	add    $0x18,%rsp
400fcd:	c3                   	retq   
</code></pre>
<p>第二个数字是%eax的值，由第一个数决定。故答案有7个。</p>
<h3 id="第四关递归">第四关：递归</h3>
<pre><code class="language-assembly">000000000040100c &lt;phase_4&gt;:
......
  401029:	83 f8 02             	cmp    $0x2,%eax //只能有2参数
  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;
  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp) //0 &lt;= num1 &lt;= 14
  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;
  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;
  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx
  40103f:	be 00 00 00 00       	mov    $0x0,%esi
  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi //num1→edi
  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt; //
</code></pre>
<p>输入规则和上一关一样，第一个数需在0到14之间（cmpl只能用于无符号数？）</p>
<pre><code class="language-assembly">0000000000400fce &lt;func4&gt;:
//首次调用时：%eax:0x2 %ebx:0 %ecx:0 %edx:0xe %esi:0x0 %edi:num1
  400fce:	48 83 ec 08          	sub    $0x8,%rsp
  400fd2:	89 d0                	mov    %edx,%eax //eax:14
  400fd4:	29 f0                	sub    %esi,%eax //eax:14-0
  400fd6:	89 c1                	mov    %eax,%ecx //ecx:14
  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx //ecx:0 //逻辑右移31，即取符号位。
  400fdb:	01 c8                	add    %ecx,%eax //eax:14+0
  400fdd:	d1 f8                	sar    %eax //算术右移1位？eax:14/2=7
  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx //ecx:7+0
  400fe2:	39 f9                	cmp    %edi,%ecx //比较num1和7
  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt; //不大于→r17
  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx //edx:ecx-1=6
  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt; //递归→r3
  400fee:	01 c0                	add    %eax,%eax 
  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt; //跳出
  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax 
  400ff7:	39 f9                	cmp    %edi,%ecx //比较num1和7
  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt; //不小于
  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi //esi:ecx+1=8
  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt; //递归→r3
  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax //eax=2*eax+1
  401007:	48 83 c4 08          	add    $0x8,%rsp
  40100b:	c3                   	retq   
</code></pre>
<p>前面一通算术操作，后面设计了递归。</p>
<p>这里一步移位操作看起来像是取符号位，但是输入一定大于0，符号位是0，所以这个操作意义何在？</p>
<p>人肉IDA走起：</p>
<pre><code class="language-c">int fun4(int num1,int x,int y){
    int s,a;
    s=(x-y)/2+y;
    if(num1&gt;s)	return 2*fun4(num1,s-1,y);
    a=0;
    if(num1&lt;s)	return 2*fun4(num1,x,s+1)+1;
   	return a;
}
fun4(num1,14,0);
</code></pre>
<p>第一个数设为7可避免递归调用，但返回值不是0，不符合。</p>
<pre><code class="language-assembly">40104d:	85 c0                	test   %eax,%eax //eax=0
40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;//不等于0爆炸
401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp) //mun2和0比较？
401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;//不等于0爆炸
401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;
40105d:	48 83 c4 18          	add    $0x18,%rsp
401061:	c3                   	retq   
</code></pre>
<p>看到<func4>的返回值和num2皆需为0，则num2确定。</p>
<p>大不了爆破呗，索性试了1次就成了。emm</p>
<h3 id="第五关">第五关</h3>
<pre><code class="language-assembly">0000000000401062 &lt;phase_5&gt;:
  401062:	53                   	push   %rbx
  401063:	48 83 ec 20          	sub    $0x20,%rsp
  401067:	48 89 fb             	mov    %rdi,%rbx
  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax //???
  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  401078:	31 c0                	xor    %eax,%eax //eax:0
  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt;
  40107f:	83 f8 06             	cmp    $0x6,%eax //输入长度为6
  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;
  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt;
  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;
  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx //循环头。新指令
  40108f:	88 0c 24             	mov    %cl,(%rsp)
  401092:	48 8b 14 24          	mov    (%rsp),%rdx
  401096:	83 e2 0f             	and    $0xf,%edx
  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx //？？？
  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1) 
  4010a4:	48 83 c0 01          	add    $0x1,%rax //计数变量rax
  4010a8:	48 83 f8 06          	cmp    $0x6,%rax //循环6轮
  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt; //循环尾
  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)
  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi //？？
  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt;
  4010c2:	85 c0                	test   %eax,%eax
  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;
  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt;
  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1) //？？？
  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;//跳出
  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax
  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;
  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax //？？？
  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;
  4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;
  4010ee:	48 83 c4 20          	add    $0x20,%rsp
  4010f2:	5b                   	pop    %rbx
  4010f3:	c3                   	retq   
</code></pre>
<h3 id="第六关">第六关</h3>
<h3 id="隐藏关">隐藏关</h3>
<p>隐藏关藏在每一关的后面，</p>
<h2 id="gdb使用">GDB使用：</h2>
<p>基础：</p>
<pre><code>q : quit
h : help
file prog//加载程序，也可作为gdb命令的参数
r : run
k : kill
</code></pre>
<p>断点：</p>
<pre><code>b : breakpoints break
	- func_name
	- *0x400522
    - &amp;var
   	- main.c:100//源代码断点，运行前即可
		- if con//条件断点
w : watch //观察对象变化时断点
d : delete 
	- b n
disable b n
</code></pre>
<p>执行：</p>
<pre><code>c : continue
f : finish
stepi n
nexti

set args ./a.txt //从文件读取输入
</code></pre>
<p>检查代码：</p>
<pre><code>disas //展示汇编
	- funcname
    - 0x400000
    - 
list
edit
</code></pre>
<p>检查数据：</p>
<pre><code>x : examine
p : print 
格式控制：/[n][f][u]
	- n:内存单元个数
	- f:显示格式：
		-  x(hex) 按十六进制格式显示变量。
		-  d(decimal) 按十进制格式显示变量。
        -  u(unsigned decimal) 按十进制格式显示无符号整型。
        -  o(octal) 按八进制格式显示变量。
        -  t(binary) 按二进制格式显示变量。
        -  a(address) 按十六进制格式显示变量。
        -  c(char) 按字符格式显示变量。
        -  f(float) 按浮点数格式显示变量
    - u:单元长度（按字节） 
i : info 
	- r : registers 
	- b [n]
	
	- $rsp
</code></pre>
<p>表达式：</p>
<pre><code class="language-assembly">
</code></pre>
<p>堆栈：</p>
<pre><code class="language-assembly">bt : backtrace//显示堆栈
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[about_blog]]></title>
        <id>https://lonelyuan.github.io/post/about-blog/</id>
        <link href="https://lonelyuan.github.io/post/about-blog/">
        </link>
        <updated>2020-02-03T16:17:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="博客技术介绍">博客技术介绍</h1>
<blockquote>
<ul>
<li>不要：不写博客，使用 CSDN 等国内垃圾博客平台</li>
<li>推荐：利用 <a href="https://pages.github.com/">GitHub Pages</a> 搭建静态博客。注意，你的 git     仓库地址不是你的博客地址，假设仓库URL是 <a href="https://github.com/example/example.github.io/%EF%BC%8C%E5%8D%9A%E5%AE%A2URL%E4%B8%80%E8%88%AC%E6%98%AFhttps:/example.github.io/">https://github.com/example/example.github.io/，博客URL一般是https://example.github.io/</a></li>
<li>推荐：在 VPS 上用 Wordpress 搭建博客，或者在     VPS 上搭建静态博客（都需要持续的维护成本）</li>
<li>推荐：使用<a href="https://www.blogger.com/about/">Blogger</a>等国外平台</li>
</ul>
<p>来自 <a href="https://course.blue-whale.me/">https://course.blue-whale.me/</a></p>
</blockquote>
<h2 id="为什么要搞博客">为什么要搞博客？</h2>
<p>必要性：没有。有时候维护博客比写博客更花时间。</p>
<p>重要性：很大。学计算机的，没有技术博客说明你：</p>
<ul>
<li>不会搭，说明笨，建议马上转行。</li>
<li>不想搭，说明懒，建议退学啃老。</li>
</ul>
<p>总之只是搭好还是很简单的，不过要打磨的赏心悦目还是要费一番功夫。本文仅介绍主流框架，不讲具体操作。</p>
<h2 id="自建站点">自建站点</h2>
<p>要买服务器，之后可以自由搭建静态/动态博客。大牛都有自己的站点</p>
<p>步骤：</p>
<ul>
<li>买服务器，即vps：国内三大云（阿里，腾讯）都有10块一月的学生机，入门可用</li>
</ul>
<p><a href="https://www.54wzj.com/vps/%E5%BB%BA%E7%AB%99vps%E6%8E%A8%E8%8D%90/">https://www.54wzj.com/vps/%E5%BB%BA%E7%AB%99vps%E6%8E%A8%E8%8D%90/</a></p>
<ul>
<li>
<p>购买域名：专用域名商或服务器商提供</p>
</li>
<li>
<p>配置服务器：需要懂服务器运维的入门知识，</p>
</li>
<li>
<p>部署博客：动态静态都可以（不知道区别的建议自尽）</p>
</li>
<li>
<ul>
<li>动态框架：即博客类的CMS。</li>
</ul>
</li>
</ul>
<p>如：wordpress，使用php。操作简单易上手。</p>
<ul>
<li>静态：后文提到的都可以。</li>
</ul>
<p>优势：功能强，部署自由</p>
<p>劣势：需要持续运营成本（包括金钱和时间）</p>
<h2 id="发表到博客平台">发表到博客平台</h2>
<p>依托平台，具体操作依据平台而定</p>
<p>优点：操作较自建站点简单（其实也不一定）</p>
<p>缺点：功能较为受限。</p>
<ul>
<li>简书：</li>
</ul>
<p>和知乎等平台的区别在于注重文章和内容</p>
<p>ui清爽，不过不可定制。</p>
<p>另外这样的平台总有审查机制，这 不 自 由。</p>
<ul>
<li>博客园：</li>
</ul>
<p>老牌国内博客网站了，用的是.net框架。</p>
<p>前端可高度定制，懒得搞后端可以试。</p>
<p>随便一个例子：https://www.cnblogs.com/php09/</p>
<ul>
<li>CSDN：垃圾。</li>
</ul>
<p>说垃圾的原因是：抄袭严重，内容陈旧，吃相难看。</p>
<ul>
<li>Github pages：</li>
</ul>
<p>全球最大同性交友社区gayhub提供的静态网页托管服务，就是搭建静态博客用的。</p>
<p>下面介绍几种静态博客：</p>
<ul>
<li><strong>typeecho</strong>：轻量级php框架</li>
</ul>
<p>https://www.jianshu.com/p/ed2e655c3741</p>
<p>功能精简，是好也是坏</p>
<ul>
<li>**Hugo：**基于go</li>
<li><strong>Jekyll</strong>：基于ruby</li>
<li>**Hexo：**基于node.js的静态博客框架，目前使用规模最广的之一</li>
</ul>
<p>https://hexo.io/zh-cn/docs/</p>
<p>https://easyhexo.com/</p>
<p>步骤：使用githubpages的框架都大同小异</p>
<ul>
<li>
<ul>
<li>安装环境：git，node.js，npm，hexo</li>
<li>配置SSH密钥对</li>
<li>文章写作，上传，发布</li>
<li>网站配置：主题，拓展</li>
</ul>
</li>
</ul>
<p>基于不同的语言，要配的环境也不同。光是配环境就难倒不少萌新。而且，想精心打磨自己的站点也是一路险坑。不过，做起来吧。谁让我们是学计算机的呢。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSAPP-datalab]]></title>
        <id>https://lonelyuan.github.io/post/CSAPP-datalab/</id>
        <link href="https://lonelyuan.github.io/post/CSAPP-datalab/">
        </link>
        <updated>2020-01-20T16:00:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="csappdatalab">CSAPP：datalab</h1>
<p>读，就硬读。光读没用，得做练习。这个系列记录思路不写答案。</p>
<p>拿到文件夹先读README。</p>
<p>第一个lab，关于位运算。通过受限制的c语言编程实现函数功能。</p>
<p>直接读<code>bits.c</code>，里面有全部信息。每次测试程序都要先make一下。</p>
<ul>
<li>
<h4 id="1只用按位与和非实现异或">1：只用按位与和非实现异或</h4>
</li>
</ul>
<pre><code>/* 
 * bitXor - x^y using only ~ and &amp; 
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &amp;
 *   Max ops: 14
 *   Rating: 1
 */
</code></pre>
<p><code>&amp;</code>=全为1</p>
<p><code>~&amp;</code>=不全为1</p>
<p>异或=不全为0且不全为1，按此逻辑组合即可。</p>
<p>你让我用括号了？？？</p>
<p>反思：浪费时间，与和或傻傻分不清楚</p>
<ul>
<li>
<h4 id="2位运算取补码的最小值">2：位运算取补码的最小值</h4>
</li>
</ul>
<p>英语时间：补码（two's complement）反码：（one's complement）。结合公式很好理解</p>
<pre><code>/* 
 * tmin - return minimum two's complement integer 
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 4
 *   Rating: 1
 */
</code></pre>
<p>补码公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mn>2</mn><msub><mi>T</mi><mi>w</mi></msub><mo>(</mo><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>)</mo><mo>=</mo><mo>−</mo><msub><mi>x</mi><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>w</mi><mo>−</mo><mn>2</mn></mrow></munderover><msub><mi>x</mi><mi>i</mi></msub><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">B2T_w(\vec{x})=-x_{w-1}+\sum^{w-2}_{i=0}x_i2^i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>最高位是符号位，要求最小值，则最高位为负1，其他位为0。</p>
<p>由于题目限制，只能使用最大为0xff的数字和位运算符，又int长度为4*8=32，故对0x1左移31即得。</p>
<ul>
<li>
<h4 id="3判断一个数是否为补码的最大值">3：判断一个数是否为补码的最大值</h4>
</li>
</ul>
<pre><code>/*
 * isTmax - returns 1 if x is the maximum, two's complement number,
 *     and 0 otherwise //0=1111 1111=0000 0000
 *   Legal ops: ! ~ &amp; ^ | +
 *   Max ops: 10
 *   Rating: 1
 */
</code></pre>
<p>最大值：符号位0，其他位1，即max=011111...=0x7fffffff。</p>
<p><code>!0=1</code>，故应使每一位化为0，再取非即为1；其他任何数取非都为0。</p>
<p>注意到<code>max+1=~max</code>，补码max加一得到其反码。反码相加得11111111，取反即得0。</p>
<p>特例：<code>-1 = 0x1111 1111</code>也有这个性质，故须排除。</p>
<p>寻找另一性质：<code>!(max+1)=0</code>，而<code>!(-1+1)=1</code>，结合上一步结果即可。</p>
<p>反思：逻辑非！和按位非~</p>
<ul>
<li>
<h4 id="4判断所有奇数位为1">4：判断所有奇数位为1</h4>
</li>
</ul>
<pre><code>/* 
 * allOddBits - return 1 if all odd-numbered bits in word set to 1
 *   where bits are numbered from 0 (least significant) to 31 (most significant)
 *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 2
 */
</code></pre>
<p>要取奇数位，首先构造掩码：<code>0xaaaaaaaa</code>，用&amp;取出奇数位，再异或，取反即得。</p>
<p>错误示范：<code>m=0xaa;m+=m&lt;&lt;8;m+=m&lt;&lt;8;m+=m&lt;&lt;8;</code>算出来个啥？</p>
<ul>
<li>
<h4 id="5取相反数">5：取相反数</h4>
</li>
</ul>
<pre><code>/* 
 * negate - return -x 
 *   Example: negate(1) = -1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 5
 *   Rating: 2
 */
</code></pre>
<p>常识？？？反码加1</p>
<p>大佬题解：https://wdxtub.com/csapp/thick-csapp-lab-1/2016/04/16/</p>
<p>https://zhuanlan.zhihu.com/p/59534845题不一样？？？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深度学习入门——jetbot智能小车尝鲜（二）]]></title>
        <id>https://lonelyuan.github.io/post/jetbot-2/</id>
        <link href="https://lonelyuan.github.io/post/jetbot-2/">
        </link>
        <updated>2019-09-30T16:26:38.000Z</updated>
        <content type="html"><![CDATA[<p>那个男孩不想玩人工智能呢？在玄学修bug之后，我终于跑通了jetbot自带的深度学习demo。</p>
<p>怎样才能让ai程序发挥好的效果呢？众所周知，所谓人工智能，有多少人工就有多智能。</p>
<p>AI的发展离不开三个要素：<strong>算力</strong>，<strong>算法</strong>和<strong>算材</strong>。根据摩尔定律，算力的发展是不会停滞的（虽然定律快失效了）；进几年来的AI热正是算法的突破，即深度学习相关算法的突飞猛进；而算材就是用来训练模型的数据，未来几年AI应用的进一步落地离不开算材的进一步开发（中国在AI方面的最大优势正在于此）。数据集的丰富程度和有效程度直接影响了AI应用的效果，我将在下文详细说明。</p>
<p>在jetbot项目中，我们也能体验到用“人工”换“智能”的快乐。作为视觉识别类的AI应用，我们要在预设环境里创建数据集，并为其标注。有了数据集，jetbot搭载的NVIDIA牌GPU在方寸之间就能完成海量计算，仅用一颗摄像头就能实现自动避障，目标追踪，自动巡线等等炫酷功能！不要1999，也不要999，只要99！99刀NVIDIA计算卡带回家！（妮维雅打钱）</p>
<blockquote>
<p>给萌新理清几个概念：</p>
<p>人工智能，机器学习，深度学习的关系：</p>
<ul>
<li>深度学习：一种实现机器学习的技术；机器学习：一种实现人工智能的方法</li>
<li>【包含关系图】</li>
</ul>
<p>AI的发展路径：</p>
<ul>
<li>弱AI：单独领域工作效率超过人类→</li>
<li>通用AI：可以广泛应用于大部分领域→</li>
<li>强AI：有自主意识，即将灭绝人类（不是）→</li>
</ul>
<p>现在AI发展到什么地步了：弱AI，有生之年可能见到通用AI</p>
</blockquote>
<p>推荐一波汉化的很好的wiki，也有自己原创的内容：http://www.waveshare.net/wiki/JetBot_AI_Kit</p>
<p>本篇详细介绍两个demo的代码和可能遇到的问题，最后附上神经网络的入门笔记。同样是初次接触，大佬请绕道。</p>
<h3 id="demo1自动避障">demo1：自动避障</h3>
<p>小车如何实现自动避障的呢？用通俗的不能再通俗的说法，AI程序通过学习你给他的数据集，知道了什么样的图像是死路，什么样的图像是通路。得到新图像时就能判断是死路的概率有多少，在程序里可以很简单的看出，当这个概率大于0.5的时候就触发小车转向。</p>
<p>具体而言，你要在你的环境里拍至少200张照片，100张标记为通路（free），100张标记为死路（blocked）。这便是你的数据集（dataset）。构建数据集的时候尽量分散在环境的各个位置和各个方向，可以沿边界环绕一圈，走一段距离停下，转一圈，收集8-10张图片。反正你的数据越多，标记的越准确，模型效果越好。</p>
<p>下一步就开始训练模型了，从代码里看出，这个demo使用AlexNet模型，用pytorch实现（废话）。第一次运行你会下载一个244M左右的大文件，在<code>/home/jetbot/.torch/models</code>目录下会看到这个.pth文件。这便是AlexNet了。</p>
<p>继续运行程序，完整的输出结果有三十行，每行后面的小数代表当前模型的准确度（？），程序最后会从这30个模型中选取准确度最高的作为最终模型，也是一个pth文件：<code>best_model.pth</code></p>
<p>下载文件和训练模型都需要花挺长时间，看到kernel busy，也就是右上角的大黑点不要轻易打断。</p>
<p>什么是模型呢？稍微解释一下机器学习的概念。</p>
<p>模型就是函数，其要素为输入，输出，和变换关系。举例说明：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>细菌向养分移动</td>
<td>外界环境的化学信号</td>
<td>催动鞭毛的电信号</td>
</tr>
<tr>
<td>学生参加高考</td>
<td>试卷反射的光信号</td>
<td>试卷上问题的答案</td>
</tr>
<tr>
<td>小车自动避障</td>
<td>摄像头传输图像信号</td>
<td>前方被堵塞的概率</td>
</tr>
</tbody>
</table>
<p>实际上，知识的本质也是函数，生命延续的关键就在于该生命的模型是否适应环境。这里不深入解释了，觉得惊奇请参阅Yjango的频道https://space.bilibili.com/344849038他用机器学习的角度解释生物进化，非常颠覆三观。</p>
<p>总之训练出来的模型就是这样一个函数。其输入为经过处理的摄像头的图形信号，输出一个0-1的数，越接近1越意味着模型认为小车要撞墙了。但是当他大于0.5的时候就会触发转向，也就实现了自动避障。</p>
<blockquote>
<p>AlexNet是2012年提出的一种卷积神经网络（即CNN）算法。首次实现gpu加速。</p>
<p>主流深度学习框架：TensorFlow；PyTorch；Keras</p>
</blockquote>
<p>还挺好玩的😀</p>
<h3 id="demo2目标追踪">demo2：目标追踪</h3>
<p>基于上一个demo，我们还要下载一个模型，<a href="http://cocodataset.org/#home">coco数据集</a>神经网络，可以检测90种不同的物体。按教程把.engine文件下载到指定位置，顺着跑就完事了。（引入模型也要花挺长时间）</p>
<p>如果有数据集里的物品，从输出里能看到蓝框标出，小车会自动转向物体，同时还保留了自动避障的程序。</p>
<p>遇到bug：程序仅能读取一张图像进行识别，摄像头更新的功能无法执行。</p>
<h3 id="修bug摄像头问题">修bug：摄像头问题</h3>
<p>描述：摄像头只要调用了一次，后面就无法在其他地方调用。直接在jupyter上关闭输出并没有作用。而且只要在一个notebook里就能重复调用，换一个就不行。而且并没有报错信息，程序一直处在busy状态。</p>
<p>找到源码，在jetbot/jetbot/camera.py，但是所有样例里面调用摄像头都是用的Camera.instance()方法，而这个instance是在traitlets库里的，于是找到trailets官方文档</p>
<blockquote>
<p>Traitlets是一个纯 python 库，支持：</p>
<ul>
<li>对 python 对象属性的强类型实施( 类型属性称为 &quot;特征&quot; ) ；</li>
<li>动态计算的默认值；</li>
<li>当尝试改变时，自动验证和强制特征属性；</li>
<li>当特征值改变时注册接收通知；</li>
<li>从文件或者 命令行 参数中读取值- 在traitlets上不同层，因这里可以在没有配置机器的情况下使用 traitlets。</li>
</ul>
<p>Traitlets支持IPython和Jupyter的配置系统，以及IPython交互小部件的声明性 API。</p>
<p>ipython是一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。其中就包括traitlets库。</p>
</blockquote>
<p>https://traitlets.readthedocs.io/en/stable/config.html 在这里找到instance的功能：返回现有的类，如果没有就新建一个。</p>
<p>下面是样例中调用摄像头的代码：</p>
<pre><code class="language-python">import ipywidgets.widgets as widgets  #图像模块
from IPython.display import display   #ipy的显示模块
import traitlets                      
from jetbot import Camera, bgr8_to_jpeg #摄像头驱动，图像格式转换
camera = Camera.instance(width=500, height=500)#初始化摄像头对象
image = widgets.Image(format='jpeg', width=400, height=400)#创建图像
camera_link = traitlets.dlink((camera, 'value'), (image, 'value'), transform=bgr8_to_jpeg)     #连接摄像头到图像
display(image)  #显示图像
</code></pre>
<p>尝试从camera.py里调用原始api。得到报错：<code>Each object must be HasTraits, not &lt;class 'NoneType'&gt;</code>，是说必须为对象指定类型。那么HasTraits这个类型是啥？文档说:任何具有trait属性的类都必须从 <code>HasTraits</code> 继承。</p>
<p>再次梳理调用摄像头的流程：</p>
<ul>
<li>引入模型：<code>model.load_state_dict(torch.load('best_model.pth'))</code></li>
<li>连接摄像头：见上文</li>
<li>模型执行：</li>
</ul>
<pre><code class="language-python">def update():
	...#此处为模型执行函数，将输入图像预处理后，执行模型
update({'new': camera.value})  #初始化该函数
camera.observe(update, names='value')  #将update函数设为camera.value的observer
</code></pre>
<p>研究一下observe用法：当对象发生变化时调用函数。</p>
<p>https://traitlets.readthedocs.io/en/stable/using_traitlets.html#validation</p>
<p>执行如下代码：</p>
<pre><code class="language-python">import ipywidgets.widgets as widgets  #图像模块
from IPython.display import display   #ipy的显示模块
import traitlets                      
from jetbot import Camera, bgr8_to_jpeg #摄像头驱动，图像格式转换
camera = Camera.instance(width=500, height=500)#初始化摄像头对象
def update(change):
	x = change['new'] 
	display(x)  #显示图像
update({'new': camera.value})  
camera.observe(update, names='value') 
</code></pre>
<p>输出一大堆数组，说明camera.value是这一大堆像素。而且observe正常运行，数据一直冒出。</p>
<pre><code>array([[[122, 116, 130],
        [126, 113, 127],
        [125, 117, 129],
        ...,
        [ 84,  96, 107],
        [ 82,  96, 113],
        [ 93,  93, 113]],

       [[120, 119, 130],
        [122, 120, 119],
        [118, 123, 130],
        ...,
</code></pre>
<p>然而就是不实时更新数据，卒。</p>
<p>👴佛了。</p>
<h3 id="神经网络笔记">神经网络笔记</h3>
<h3 id="alexnetcnn">AlexNet——CNN</h3>
<p>2012年由Hinton学生Alex提出，是Lenet加宽版。其采用了一系列的新技术：成功的引用了relu、dropout和lrn等trick，首次采用gpu加速。其包含65万神经元，5个卷积层，三个后面带有池化层，最后用了三个全链接。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单片机入门——jetbot智能小车尝鲜(一)]]></title>
        <id>https://lonelyuan.github.io/post/jetbot-1/</id>
        <link href="https://lonelyuan.github.io/post/jetbot-1/">
        </link>
        <updated>2019-09-30T16:25:55.000Z</updated>
        <content type="html"><![CDATA[<p>那个男孩不想玩树莓派呢？机缘巧合之下，我得到了一台价值上百美元的智能小车的使用权。</p>
<p>小车的核心是NVIDIA家的jetson-nano开发板，这款19年三月才发布的微型AI计算机可谓是平民级核弹，四核A57的CPU，128核心Maxwell架构的GPU，4g内存，支持4k视频解码，而且这只五脏俱全的麻雀只需要5W的电源支持，任何一支充电宝都可以胜任。而它的定位是用它简单的搭建人工智能应用，非常的amazing。</p>
<p>本文的目的,不完全是新手教程,还有自己学习过程的记录和分享.初次接触,多有疏漏,欢迎指教.</p>
<p>【图片：主板证件照】</p>
<blockquote>
<p>给萌新理清几个概念：</p>
<p>单片机：Single-Chip Microcomputer。</p>
<p>树莓派：一款著名的微型电脑品牌（本文介绍的jetson-nano可以理解为是树莓派的竞品，相比树莓派，这款单片机价格更高，性能更好，主打AI应用）</p>
<p>jetbot：以jetson-nano为平台搭建的ai机器人应用，也就是所谓智能小车</p>
</blockquote>
<h3 id="硬件组装积木和电工">硬件组装:积木和电工</h3>
<p>本人拿到的是零件状态的小车，所以首先讲一讲组装的问题。有关具体步骤，官网教程十分详细，贴个连接给懒人吧：https://www.ncnynl.com/archives/201904/2927.html</p>
<p>这里只讲一讲我作为初学者的一些理解。首先，玩单片机和玩积木的区别就在于编程。当然，入门单片机还需要其他技能。比如，电工技能：你需要进行线材的简单加工，引脚的焊接，准备基本的工具就好，毕竟那个男孩没有一根热热的棒子呢（指<strong>电烙铁</strong>）。然后，各个部件的拼接固定需要一些做手工的技巧，这个也不用怕，赫鲁晓夫曾经说过：<strong>热熔胶</strong>可以让我们创造奇迹。</p>
<p>在这个层面上，初学者会浪费许多耗材，这是必要的练习手段，所以初学者也可以从最简单的芯片入手。同时你还要学习诊断硬件方面的问题，<strong>万用表</strong>会很有帮助。关于更详细的工具和耗材的需要，请自行查阅单片机入门有关资料。</p>
<p>在本项目中，焊接工作已经完成，剩下的连接都是可插拔式的。我们只需要两把螺丝刀即可完成组装。即便如此，本人还是花了一晚上才把小车点亮，原因是我得到的线材损坏近半，只得自己寻找和修理。</p>
<p>下面分析一下小车的结构:</p>
<ul>
<li>jetson-nano开发板:即本机的主板,可以看到有两层芯片,上层为核心层,包括cpu,gpu和内存可以像笔记本内存条一样拆卸;下层为主板,用于连接各种设备</li>
<li>intel无线网卡:将上层拆下即可安装.令连出两根天线,缠绕机身即可.</li>
<li>PiOLED显示器和拓展版:连接在I2C主线上</li>
<li>相机模块:官方样例展示了只用一个摄像头通过深度学习进行自动避障的demo.</li>
<li>马达和其驱动板:下文重点讲解</li>
</ul>
<p>开发板就可以运行一个完整的Ubuntu系统,其余设备是为其拓展功能的.</p>
<h3 id="硬件架构驱动芯片和i2c主线">硬件架构：驱动芯片和I2C主线</h3>
<p>我在玩小车的过程中耽误最长时间的就是电机（即马达）驱动了，借此讲一讲系统架构的事。</p>
<p>让轮子前进要靠马达，给马达供电不能直接让主板来做，要让主板给另一块小芯片发送指令，这块小芯片连接着独立的电源，收到指令才会给马达通电。这块小芯片即是电机驱动板。</p>
<p>驱动芯片是从硬件走向软件的第一道桥梁，可以类比PC的IO设备来理解。和物理世界交互的各种功能，都需要有专门的驱动芯片。包括马达，摄像头，扬声器，机械臂等等，只不过有的可以集成在一起，如：小车上的摄像头，PiOLED显示器等；有的出于体积，安全性，模块化的考虑需要分开，如电机和驱动板。</p>
<h4 id="电机驱动板">电机驱动板</h4>
<p>官方给出的电机驱动板型号为:DC-Stepper-Motor PCA9685+TB6612.可以驱动两个步进电机或四个直流电机。（四轴飞行器gkd）本项目只用到了两个直流电机。</p>
<p>各个引脚的讲解：https://learn.adafruit.com/adafruit-stepper-dc-motor-featherwing/pinouts</p>
<p>电机驱动板上共连接有10根跳线。一对电源输入，两对为马达输出。还需四根母-母杜邦线来连接至主板的<strong>I2C总线</strong>,具体来说,是在LED屏旁边的拓展板。分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:center">驱动板引脚</th>
<th style="text-align:center">主板I2C引脚</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3V3</td>
<td style="text-align:center">3V3</td>
<td style="text-align:center">为驱动板供电,即电源正极</td>
</tr>
<tr>
<td style="text-align:center">GND</td>
<td style="text-align:center">GND</td>
<td style="text-align:center">接地,即电源负极</td>
</tr>
<tr>
<td style="text-align:center">SDA</td>
<td style="text-align:center">3</td>
<td style="text-align:center">串行数据线，传输数据</td>
</tr>
<tr>
<td style="text-align:center">SCL</td>
<td style="text-align:center">5</td>
<td style="text-align:center">串行时钟线，传输控制信号</td>
</tr>
</tbody>
</table>
<p>【图片：驱动板引脚】</p>
<p>接错了有可能烧坏板子哦</p>
<h4 id="i2c总线">I2C总线</h4>
<p>所谓总线,可以理解为一条街道,每个设备就是街道两旁的房子,房内的住户出门走亲访友就是数据在不同设备间的传输。</p>
<p>I2C总线是常用于嵌入式系统的一种简易串行总线.他有简洁的双线结构(SCL+SDA),每个设备都有一个地址码,以此实现多个设备相互通讯。设备有主从之分，主设备/主端必须是带有CPU的逻辑模块，在同一总线上同一时刻使能有一个主端，可以有多个从端，从端的数量受地址空间和总线的最大电容 400pF的限制。</p>
<p>可以使用i2c-tools调试i2c总线:</p>
<ul>
<li>检测有几组i2c总线在系统上<code>i2cdetect -l</code></li>
<li>检测挂载在i2c-1上的设备<code>i2cdetect -r -y 1</code></li>
</ul>
<pre><code>  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
  00:          -- -- -- -- -- -- -- -- -- -- -- -- --
  10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- --（led）
  40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  60: 60 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --（电机驱动）
  70: 70 -- -- -- -- -- -- --
</code></pre>
<ul>
<li>
<p>查看设备(地址为0x20)上所有寄存器的值i2cdump -f -y 1 0x20</p>
</li>
<li>
<p>对单个寄存器进行读写:</p>
<p><code>i2cset -f -y 1 0x20 0x77 0x3f</code>（设置i2c-1上0x20器件的0x77寄存器值为0x3f）</p>
<p><code>i2cget -f -y 1 0x20 0x77</code>    （读取i2c-1上0x20器件的0x77寄存器值）</p>
</li>
</ul>
<p>jetson-nano开发板提供了6条I2C主线,以及其他丰富的接口。理解这些接口是拓展各种设备的前提。</p>
<h3 id="软件连接ssh远程桌面">软件连接:ssh远程桌面</h3>
<p>从头开始的话，我们还需要往sd卡里烧写系统镜像，不过我拿到的已经完成了这一步骤，故不再赘述。</p>
<p>在官方教程中,需要hdmi线连接显示屏,usb连接鼠标键盘,来进入jetson-nano的Ubuntu系统.其目的在于首次连接一个无线网络(手机热点),之后只要电脑和nano在同一网络,即可用电脑访问nano的IP(8888端口),直接操纵jetbot.</p>
<p>由于我并没有hdmi线,只有一根网线,反正都能插,插谁不一样?所以用网线把小车和笔记本连接起来组成局域网.用ssh的方式进入nano的系统.具体步骤如下:</p>
<ul>
<li>
<p>ip发现:在插入网线前后执行两次:<code>arp -a</code>,比较不同,会发现多出一个地址,类型为动态,此即为小车的内网IP.小车的led屏也会自动显示其ip.如<code>eth0:192.168.x.x</code></p>
</li>
<li>
<p>(如此,我们可以直接从浏览器访问这个ip的8888端口,并能运行jupyter notebook了.但我们不能让小车拖着网线跑啊,所以还是要配置无线网络.)</p>
</li>
<li>
<p>将笔记本的wifi连接设为对以太网可共享,这一步是为了让小车能通过笔记本联网</p>
</li>
<li>
<p>端口扫描:<code>nmap -sT 192.168.x.x</code>发现22端口开放,故连接之:<code>ssh jetbot@192.168.x.x</code>,就用官方教程给的账户密码.</p>
</li>
<li>
<p>连接成功后,就可以用命令行工具连接WiFi了,但还是安装一下远程桌面吧.</p>
</li>
<li>
<p>配置远程桌面:执行以下命令:</p>
<pre><code>sudo apt-get install tightvncserver
sudo apt-get install xrdp
sudo apt-get install vnc4server tightvncserver
</code></pre>
</li>
<li>
<p>之后在你的主机win+R，输入mstsc,进入远程登录桌面，输入小车的ip地址，点击连接</p>
</li>
<li>
<p>在xrdp的登陆界面输入用户名密码即可打开远程桌面</p>
<p>(这里我用jetbot用户登陆遭遇闪退,用root就可以,不清楚原因)(另外开了远程桌面内存疯涨,就很离谱)</p>
</li>
<li>
<p>连接上wifi后,你能在小车的led板上看到另一个ip:<code>wlan0:192.168.x.x</code></p>
</li>
</ul>
<p>不管怎样,连接上wifi之后的操作就很简单了.跟着教程,跑一跑demo,还是很有成就感的.</p>
<h3 id="排查bug">排查bug</h3>
<p>然而demo并没有让我跑出来,且指向同一个错误:</p>
<pre><code>OSError: [Errno 121] Remote I/O error
</code></pre>
<p>沿着jupyter notebook的报错一直走,一直到了最底层,向设备写入数据报错,<code>remote IO error</code>.</p>
<p>看起来像是硬件的问题。一步一步排查呗</p>
<ul>
<li>
<p>怀疑跳线错误</p>
<ul>
<li>更换跳线——无果</li>
<li>用万用表测量线两端的信号——正常，排除连接问题
<ul>
<li>时钟线保持3.3v每隔几秒跳到2.2v又回来，结合i2c的原理应该是正常现象？</li>
<li>数据线同样保持3.3v，间断跳至2.3，2.0</li>
</ul>
</li>
</ul>
</li>
<li>
<p>软件方法检验设备连接性</p>
<ul>
<li>用i2ctools可以检测到设备，拔下4根接线，在0x60,0x70处的设备消失（一个是i2c线，一个是逻辑供电？）</li>
</ul>
<pre><code> 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- 3c -- -- --
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
70: -- -- -- -- -- -- -- --
</code></pre>
</li>
</ul>
<p>然而，在通电状态下，把连线拔下又插上之后，i2c又能检测到设备，然后示例代码就能运行了？？？</p>
<p>迷惑。所以开机时机器并没能正确载入设备，反倒是重新连接后能识别了？？？本来我都要换驱动板了，orz。</p>
<p>又或者是和驱动板上的reset按钮有关？等下次遇到问题再说吧。</p>
<h3 id="拾遗">拾遗</h3>
<h4 id="linux内存占用">linux内存占用</h4>
<p>led屏会显示内存占用，然鹅时间长了总会到90%以上，可我并没有运行什么程序。</p>
<p>经查阅此处显示的是实际占有的加上buffer和cached mem部分，可以理解为缓存的，随时清理，并不占用实际内存。</p>
<p>可用top命令查看内存详情。</p>
<h4 id="供电问题">供电问题</h4>
<p>用充电宝供电方便，但是只要一断电系统就会重启，这对linux系统而言伤害很大。</p>
<p>而在充电宝电量不满时，经常发生开不了机的问题，大概是因为电量不足导致电压不稳。</p>
<h5 id="关机命令">关机命令：</h5>
<p><code>sudo shutdown -h now</code></p>
<h5 id="重启">重启：</h5>
<p><code>shutdown -h now -r</code></p>
<p><em>下一篇：操纵小车和AI初探</em></p>
<h3 id="参考链接">参考链接</h3>
<p>https://github.com/NVIDIA-AI-IOT/jetbot/wiki/Hardware-Setup</p>
<p>https://robocarstore.cn/</p>
<p>http://www.gpus.cn/gpus_list_page_techno_support_content?id=50</p>
<p>https://www.jianshu.com/p/789944463fd7</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[About Me]]></title>
        <id>https://lonelyuan.github.io/post/about/</id>
        <link href="https://lonelyuan.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>Do not go gentle into that good night,<br>
Old age should burn and rave at close of day;<br>
Rage, rage against the dying of the light.</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>Do not go gentle into that good night,<br>
Old age should burn and rave at close of day;<br>
Rage, rage against the dying of the light.</p>
</blockquote>
<!-- more -->
<h1 id="我是谁">🐭我是谁</h1>
<figure data-type="image" tabindex="1"><img src="https://lonelyuan.github.io/post-images/1623380216575.png" alt="" loading="lazy"></figure>
<ul>
<li>存在主义者。</li>
<li>性别男，爱好女。</li>
<li>本阶段人生目标：想理解计算机的一切。</li>
<li>目前还是Web狗一条。</li>
</ul>
<!-- more -->
<h1 id="本博客宗旨">🍌本博客宗旨</h1>
<ul>
<li>尽量不制造垃圾。</li>
<li>争取周更。</li>
</ul>
<h1 id="同好检测器">🤺同好检测器</h1>
<h3 id="masterpiece">Masterpiece</h3>
<p>//排名按时间顺序</p>
<p><strong>文</strong>：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2706903"><label class="task-list-item-label" for="task-item-2706903"> 大刘</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-986061"><label class="task-list-item-label" for="task-item-986061"> 王小波</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2227783"><label class="task-list-item-label" for="task-item-2227783"> 《GEB》</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7579336"><label class="task-list-item-label" for="task-item-7579336"> 《量子窃贼》三部曲</label></li>
</ul>
<p><strong>剧</strong>：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7557355"><label class="task-list-item-label" for="task-item-7557355"> Re:0</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4679039"><label class="task-list-item-label" for="task-item-4679039"> JOJO</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-7709658"><label class="task-list-item-label" for="task-item-7709658"> 爱死机</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6969926"><label class="task-list-item-label" for="task-item-6969926"> Rick&Morty</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-1762422"><label class="task-list-item-label" for="task-item-1762422"> 黑镜</label></li>
</ul>
<p><strong>第九艺术</strong>：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6261933"><label class="task-list-item-label" for="task-item-6261933"> Minecraft</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6342259"><label class="task-list-item-label" for="task-item-6342259"> Bioshock: Infinity</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-6874650"><label class="task-list-item-label" for="task-item-6874650"> Celeste</label></li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5663503"><label class="task-list-item-label" for="task-item-5663503"> 戴森球计划</label></li>
</ul>
<!--

### Habit
- [ ] 游泳（夏天）
- [ ] 游戏（冬天）
- [ ] 多巴胺实验（指毫无目的的刷屏bilibili和知乎，像极了多巴胺实验里的小鼠）
- [ ] 拖延症晚期（详见 [我和拖延症的战争](https://lonelyuan.github.io/post/ProcrastinationWar)）
-->
<h1 id="三观">🌌三观</h1>
<h3 id="world-view-放眼寰宇">world view | 放眼寰宇</h3>
<blockquote>
<p>资本主义秩序下的世界无可避免地走到周期的末尾，而第四次工业革命依然前途渺茫，所谓百年未有之大变革，人类文明正走向混沌的路口。</p>
</blockquote>
<h3 id="outlook-on-life-and-value-聚焦个人">outlook on life and value | 聚焦个人：</h3>
<blockquote>
<p>当赛博朋克悄然成为现实，当手机成为不可或缺的器官，当消费主义暴打了理想、蒙骗了爱情，当记录了你的喜怒哀乐的数据比你更值钱；<br>
作为信息时代原住民的我们，作为被资本主义异化、被互联网原子化了的个体，作为在内卷或被内卷中焦虑挣扎的普通人——</p>
</blockquote>
<ul>
<li>是否有勇气走出舒适区，向无处不在的信息茧房说不？</li>
<li>是否愿意审视自我的成见，尝试理解他人？</li>
<li>是否敢于走出自闭，建立真实深刻的社会关系？</li>
<li>是否相信人类意志的成长性，不断逼近生理和心理的极限？</li>
<li>是否敢于自我解构，而不放弃探求生活的真相？</li>
<li>是否接受人生的无意义，并选择继续热爱这一切？</li>
</ul>
]]></content>
    </entry>
</feed>