<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lonelyuan.github.io</id>
    <title>lonelyuan&apos;s Blog</title>
    <updated>2021-11-11T08:24:30.264Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lonelyuan.github.io"/>
    <link rel="self" href="https://lonelyuan.github.io/atom.xml"/>
    <subtitle> &gt;&gt; 不要恐慌 | Don&apos;t Panic </subtitle>
    <logo>https://lonelyuan.github.io/images/avatar.png</logo>
    <icon>https://lonelyuan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, lonelyuan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[MOSPI-ChCore lab (1)]]></title>
        <id>https://lonelyuan.github.io/post/mospi-lab-1/</id>
        <link href="https://lonelyuan.github.io/post/mospi-lab-1/">
        </link>
        <updated>2021-10-29T09:03:14.000Z</updated>
        <content type="html"><![CDATA[<p>由于👴觉得👴学校的操作系统讲了个🔨，慕名而来学习上交的 MOSPI 课程。银杏书看完之后👴发现👴学校的OS确实讲了个🔨。我直接当场来一段圣经吟唱：</p>
<p>那个额西电操作系统嗷，不会写教材可以不写，害特么在弄你那个管程，来我教你啊，看好了啊。首先 M.A.L.H. 原则，看懂了吗，然后开讲<strong>虚拟内存</strong>，哎我就不虚拟，我就讲那个空闲链表。哎，再扎个<strong>多线程</strong>，看到没，线程上下文切换了。我特么直接三段<strong>系统调度</strong>（短期，中期，长期），然后我直接~就一个多核调度，我就调度到<strong>IPC</strong>，进程现在已经可以通信了啊！别怪我没有教好你，进程通信了之后干什么，憋特么讲你那破几把处理机了。看好啊，讲出锁（嬉皮笑脸），讲出<strong>信号量</strong>直接就扔到互斥资源身上，就疯狂的进入他的临界区。然后我再一个，<strong>文件系统</strong>！加三段系统<strong>虚拟化</strong>（CPU虚拟化、内存虚拟化、IO虚拟化），全部吃满，完成强杀，你唛璧你懂个der，讲寄吧OS，我爱你。</p>
<p><em>圣经原文：</em><a href="https://www.bilibili.com/video/BV1Jf4y1L7EZ">拖更云的鹰佐教学</a></p>
<hr>
<blockquote>
<p>本系列为 ChCore lab 实验报告。<br>
Lab源码：https://gitee.com/ipads-lab/chcore-lab<br>
MOSPI在线网站：https://ipads.se.sjtu.edu.cn/mospi/</p>
</blockquote>
<h2 id="实验环境">实验环境</h2>
<p>需要docker和qemu，docker不赘述。linux下安装qemu：<br>
<code>sudo apt-get install qemu-system-arm</code><br>
安装完成之后查看版本号：</p>
<pre><code class="language-plain">$ qemu-system-aarch64 --version
QEMU emulator version 4.2.0
Copyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers
</code></pre>
<p>5个实验在源码仓库分别以5个分支存在。 git clone  -b即可。</p>
<p>内核构建和调试：</p>
<ul>
<li>用docker交叉编译内核：<code>make build</code></li>
<li>启动qemu：<code>make qemu</code>
<ul>
<li>这里遇到报错：<code>Unable to init server: Could not connect: Connection refused gtk initialization failed</code></li>
<li>解决方法：修改 Makefile ，在<code>QEMUOPTS</code>参数后加<code>-nographic</code></li>
</ul>
</li>
<li>启动qemu：<code>make qemu-gdb</code>
<ul>
<li>将监听1234端口以供gdb远程调用</li>
<li>退出：<code>ctrl+a</code>，然后按x。</li>
<li>如果意外退出，要杀死进程：<code>kill $(ps -ef | grep qemu | grep 1234 | awk '{print $2}')</code></li>
</ul>
</li>
<li>在另一个终端启动gdb调试：<code>make gdb</code>
<ul>
<li>这里可能需要安装gdb-multiarch：<code>sudo apt-get install gdb-multiarch</code></li>
</ul>
</li>
</ul>
<p>可以看到，本项目中 Makefile 主要是封装了一些命令。</p>
<hr>
<h2 id="lab1">Lab1</h2>
<h3 id="练习3-加载入口定义">练习3-加载入口定义</h3>
<pre><code class="language-shell">root@lastyear:~/chcore-lab# readelf -S build/kernel.img
There are 9 section headers, starting at offset 0x20cd8:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] init              PROGBITS         0000000000080000  00010000
       000000000000b5b0  0000000000000008 WAX       0     0     4096
  [ 2] .text             PROGBITS         ffffff000008c000  0001c000
       00000000000011dc  0000000000000000  AX       0     0     8
  [ 3] .rodata           PROGBITS         ffffff0000090000  00020000
       00000000000000f8  0000000000000001 AMS       0     0     8
  [ 4] .bss              NOBITS           ffffff0000090100  000200f8
       0000000000008000  0000000000000000  WA       0     0     16
  [ 5] .comment          PROGBITS         0000000000000000  000200f8
       0000000000000032  0000000000000001  MS       0     0     1
  [ 6] .symtab           SYMTAB           0000000000000000  00020130
       0000000000000858  0000000000000018           7    46     8
  [ 7] .strtab           STRTAB           0000000000000000  00020988
       000000000000030f  0000000000000000           0     0     1
  [ 8] .shstrtab         STRTAB           0000000000000000  00020c97
       000000000000003c  0000000000000000           0     0     1
</code></pre>
<p>看到init段的起始地址是<code>0x80000</code>，和<code>readelf -h</code>中的 Entry point address 一致，也和 GDB 刚进入时<code>where</code>的输出一致。</p>
<pre><code class="language-shell">0x0000000000080000 in ?? ()
(gdb) where
#0  0x0000000000080000 in _start ()
</code></pre>
<p>下面寻找<code>_start</code>的定义，在<code>CMakeLists.txt</code>中找到<code>_start</code>，</p>
<pre><code class="language-shell">set_property(
    TARGET kernel.img
    APPEND_STRING
    PROPERTY
        LINK_FLAGS
        &quot;-T ${CMAKE_CURRENT_BINARY_DIR}/${link_script} -e _start&quot;
)
</code></pre>
<p>这里为<code>kernel.img</code>指定了链接器脚本(-T)和入口函数(-e)。</p>
<p>于是跟随link_script：</p>
<pre><code class="language-shell">set(link_script &quot;linker.lds&quot;)
configure_file(&quot;./scripts/linker-aarch64.lds.in&quot; &quot;linker.lds.S&quot;)
</code></pre>
<p>进入脚本linker-aarch64.lds.in：</p>
<pre><code class="language-c">#include &quot;../boot/image.h&quot;

SECTIONS
{
    . = TEXT_OFFSET;
    img_start = .;
    init : {
        ${init_object}
    }
// ...
</code></pre>
<p>其中<code>init</code>段指定了加载<code>init_object</code>，它表示bootloader的所有目标文件集合。其定义回到<code>CmakeLists.txt</code>：</p>
<pre><code class="language-shell">set(init_object
        &quot;${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/start.S.o
        ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/mmu.c.o
        ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/tools.S.o
        ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/init_c.c.o
        ${BINARY_KERNEL_IMG_PATH}/${BOOTLOADER_PATH}/uart.c.o&quot;
    )
</code></pre>
<p>可发现<code>/boot/start.S</code>定义了<code>_start</code>。</p>
<p>下面继续寻找地址，在链接器脚本引用了<code>image.h</code>，其中有<code>TEXT_OFFSET</code>的定义：</p>
<pre><code class="language-c">#pragma once

#define SZ_16K                  0x4000
#define SZ_64K                  0x10000

#define KERNEL_VADDR            0xffffff0000000000
#define TEXT_OFFSET             0x80000
</code></pre>
<p>一切终于串起来了：</p>
<ul>
<li><code>CMakeLists.txt</code>：是CMake的脚本文件。 CMake 是跨平台的C/C++建构工具。
<ul>
<li>作用：
<ul>
<li>指定源文件集合<code>init_object</code></li>
<li>定义链接器脚本<code>link_script</code></li>
<li>指定入口函数<code>_start</code>并指定链接器脚本</li>
<li>最终生成<code>kernel.img</code></li>
</ul>
</li>
<li>//最近看到的挺好的CMake教程：https://www.bilibili.com/video/BV1rR4y1E7n9</li>
</ul>
</li>
<li><code>linker-aarch64.lds.in</code>：lds是链接器脚本文件，负责控制输出的ELF文件的细节。
<ul>
<li>作用：指定了起始地址<code>0x80000</code></li>
</ul>
</li>
</ul>
<h3 id="练习3-多处理器挂起">练习3-多处理器挂起</h3>
<p><code>start.S</code>中注释的很明白了，通过检查<code>mpidr_el1</code>寄存器来判断 cpuid ，如果不是0则进入死循环。</p>
<pre><code class="language-c">BEGIN_FUNC(_start)
        mrs     x8, mpidr_el1
        and     x8, x8, #0xFF
        cbz     x8, primary
  /* hang all secondary processors before we intorduce multi-processors */
secondary_hang:
        bl secondary_hang
primary:
        /* Turn to el1 from other exception levels. */
        bl      arm64_elX_to_el1
        /* Prepare stack pointer and jump to C. */
        adr     x0, boot_cpu_stack
        add     x0, x0, #0x1000
        mov     sp, x0
        bl      init_c
        /* Should never be here */
        b       .
END_FUNC(_start)
</code></pre>
<h3 id="练习4-lma和vma">练习4-LMA和VMA</h3>
<pre><code class="language-shell">root@lastyear:~/chcore-lab# objdump -h build/kernel.img

build/kernel.img:     file format elf64-little

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 init          0000b5b0  0000000000080000  0000000000080000  00010000  2**12
                  CONTENTS, ALLOC, LOAD, CODE
  1 .text         000011dc  ffffff000008c000  000000000008c000  0001c000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000f8  ffffff0000090000  0000000000090000  00020000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00008000  ffffff0000090100  0000000000090100  000200f8  2**4
                  ALLOC
  4 .comment      00000032  0000000000000000  0000000000000000  000200f8  2**0
                  CONTENTS, READONLY
</code></pre>
<p>可以发现只有init段的VMA和LMA相同。其赋值还是回到lds脚本：</p>
<pre><code class="language-c">SECTIONS
{
    . = TEXT_OFFSET;
    img_start = .;
    init : { //init段VMA==VMA
        ${init_object}
    }
    . = ALIGN(SZ_16K); // 对齐16k
    init_end = ABSOLUTE(.); // init段结束
    // KERNEL_VADDR在image.h定义为0xffffff0000000000
    .text KERNEL_VADDR + init_end : AT(init_end) { // AT指定LMA
        *(.text*)
    } // .text段：VMA = KERNEL_VADDR + init_end; LMA = init_end
    // 后面的段，全部按顺序对齐并递增，此时VMA和LMA已经不同，故后面的段也全都不同
    . = ALIGN(SZ_64K);
    .data : {
        *(.data*)
    }
    . = ALIGN(SZ_64K);
    .rodata : {
        *(.rodata*)
    }
    _edata = . - KERNEL_VADDR; // 这些外部变量指的是LMA，则减去虚拟地址头
    _bss_start = . - KERNEL_VADDR;
    .bss : {
        *(.bss*)
    }
    _bss_end = . - KERNEL_VADDR;
    . = ALIGN(SZ_64K);
    img_end = . - KERNEL_VADDR;
}
</code></pre>
<p>回答问题：</p>
<ul>
<li>
<p>为什么LMA和VMA不同</p>
<ul>
<li>VMA是对应虚拟内存的地址，但在内核启动时还处于物理地址模式，VMA可能超出物理内存范围。所以只能先加载，再映射到虚拟地址。</li>
<li>为什么内核段的VMA要映射到高位，应该是一种惯例。</li>
<li>为什么bootloader不用VMA，因为他负责初始化页表，他不能用，也没有必要。</li>
</ul>
</li>
<li>
<p>LMA到VMA在何时转换</p>
<ul>
<li>由上一问可知，页表初始化之后便可转换为VMA。</li>
</ul>
</li>
</ul>
<h3 id="练习5-c语言进制转换">练习5-c语言进制转换</h3>
<p>从后往前取余即可。</p>
<h3 id="练习6-函数栈">练习6-函数栈</h3>
<p><code>start.S</code>中赋值了sp：</p>
<pre><code class="language-assembly">        /* Prepare stack pointer and jump to C. */
        adr     x0, boot_cpu_stack
        add     x0, x0, #0x1000
        mov     sp, x0 /* sp = boot_cpu_stack + 0x1000 */
</code></pre>
<p><code>boot_cpu_stack</code>在<code>init.c</code></p>
<pre><code class="language-c">#define INIT_STACK_SIZE 0x1000
char boot_cpu_stack[PLAT_CPU_NUMBER][INIT_STACK_SIZE] ALIGN(16);
</code></pre>
<p>由于<code>PLAT_CPU_NUMBER</code>被定义为4，故<code>boot_cpu_stack</code>大小为4*4096，可供四个CPU使用。sp初始化后指向第一个4069，也就是第一个cpu内核栈的最高位。初始化时，fp=sp。</p>
<p>但这是bootloader的栈。后续进入内核后，会重新分配内核栈，参见<code>head.S</code>：</p>
<pre><code class="language-assembly">BEGIN_FUNC(start_kernel)
    mov     x3, #0
    msr     TPIDR_EL1, x3
    ldr     x2, =kernel_stack
    add     x2, x2, KERNEL_STACK_SIZE
    mov     sp, x2 
    bl      main
END_FUNC(start_kernel)
</code></pre>
<p>于是内核栈的定义在start_kernel函数。</p>
<p>有关内核栈的位置，因为kernel_stack是全局数组，且未初始化，因而位于.bss。同时没有其他未初始化变量，因此首地址在<code>.bss + KERNEL_STACK_SIZE</code>。</p>
<p>通过readelf得到.bss的VMA为0xffffff0000090100，KERNEL_STACK_SIZE为0x2000，进入gdb调试可以验证</p>
<pre><code>gef➤  x/g $sp
0xffffff0000092100 &lt;kernel_stack+8192&gt;: 0x0
</code></pre>
<h3 id="练习7-调用惯例">练习7-调用惯例</h3>
<p>先看stack_test函数。这里gdb安装了gef插件：</p>
<pre><code class="language-assembly">gef➤ b stack_test
Breakpoint 1 at 0xffffff000008c020
gef➤ disas
Dump of assembler code for function stack_test:
=&gt; 0xffffff000008c020 &lt;+0&gt;:     stp     x29, x30, [sp, #-32]! /* FP、LR 入栈 */
   0xffffff000008c024 &lt;+4&gt;:     mov     x29, sp
   0xffffff000008c028 &lt;+8&gt;:     str     x19, [sp, #16] /* x 入栈 */
   0xffffff000008c02c &lt;+12&gt;:    mov     x19, x0
   0xffffff000008c030 &lt;+16&gt;:    mov     x1, x0
   0xffffff000008c034 &lt;+20&gt;:    adrp    x0, 0xffffff0000090000 # 计算偏移
   0xffffff000008c038 &lt;+24&gt;:    add     x0, x0, #0x0
   0xffffff000008c03c &lt;+28&gt;:    bl      0xffffff000008c620 &lt;printk&gt;
   0xffffff000008c040 &lt;+32&gt;:    cmp     x19, #0x0
   0xffffff000008c044 &lt;+36&gt;:    b.gt    0xffffff000008c068 &lt;stack_test+72&gt; # greater than /* 递归 */
   0xffffff000008c048 &lt;+40&gt;:    bl      0xffffff000008c0dc &lt;stack_backtrace&gt; 
   0xffffff000008c04c &lt;+44&gt;:    mov     x1, x19
   0xffffff000008c050 &lt;+48&gt;:    adrp    x0, 0xffffff0000090000
   0xffffff000008c054 &lt;+52&gt;:    add     x0, x0, #0x20
   0xffffff000008c058 &lt;+56&gt;:    bl      0xffffff000008c620 &lt;printk&gt; 
   0xffffff000008c05c &lt;+60&gt;:    ldr     x19, [sp, #16] # x19 = sp + 16 /* x 出栈 */
   0xffffff000008c060 &lt;+64&gt;:    ldp     x29, x30, [sp], #32 # load pair  /* FP、LR 出栈 */
   0xffffff000008c064 &lt;+68&gt;:    ret
   0xffffff000008c068 &lt;+72&gt;:    sub     x0, x19, #0x1
   0xffffff000008c06c &lt;+76&gt;:    bl      0xffffff000008c020 &lt;stack_test&gt;
   0xffffff000008c070 &lt;+80&gt;:    mov     x1, x19
   0xffffff000008c074 &lt;+84&gt;:    adrp    x0, 0xffffff0000090000
   0xffffff000008c078 &lt;+88&gt;:    add     x0, x0, #0x20
   0xffffff000008c07c &lt;+92&gt;:    bl      0xffffff000008c620 &lt;printk&gt;
   0xffffff000008c080 &lt;+96&gt;:    ldr     x19, [sp, #16]
   0xffffff000008c084 &lt;+100&gt;:   ldp     x29, x30, [sp], #32
   0xffffff000008c088 &lt;+104&gt;:   ret
End of assembler dump.
</code></pre>
<p>运行，观察栈的变化，这里省略部分输出：</p>
<pre><code class="language-assembly">gef➤  c
───────────────────────────────────────── registers ────
$x0  : 0x0000000000000005  # 这一层函数的输入值
$x19 : 0x0000000000000000  # 上一层函数的返回值
$x29 : 0xffffff00000920f0                # FP
$x30 : 0xffffff000008c0d4  → &lt;main+72&gt;   # LR
$sp  : 0xffffff00000920f0 
───────────────────────────────────────────── stack ────
0xffffff00000920f0│+0x0000: 0x0000000000000000
0xffffff00000920f8│+0x0008: 0xffffff000008c018 # 栈头，可能是栈初始化的数据结构
──────────────────────────────────────────── trace ────
[#0] 0xffffff000008c020 → stack_test()
[#1] 0xffffff000008c0d4 → main()
───────────────────────────────────────────────────────
gef➤  c
───────────────────────────────────────── registers ────
$x0  : 0x0000000000000004 
$x19 : 0x0000000000000005 
$x29 : 0xffffff00000920d0  
$x30 : 0xffffff000008c070  #→  &lt;stack_test+80&gt;
$sp  : 0xffffff00000920d0  →  0xffffff00000920f0  
───────────────────────────────────────────── stack ────
0xffffff00000920d0│+0x0000: 0xffffff00000920f0 ─┐  # FP
0xffffff00000920d8│+0x0008: 0xffffff000008c0d4  │  # LR
0xffffff00000920e0│+0x0010: 0x0000000000000000  │
0xffffff00000920e8│+0x0018: 0x00000000ffffffc0  │
0xffffff00000920f0│+0x0020: 0x0000000000000000 ◄┘ 
0xffffff00000920f8│+0x0028: 0xffffff000008c018  
───────────────────────────────────────────── trace ────
[#0] 0xffffff000008c020 → stack_test()
[#1] 0xffffff000008c070 → stack_test()
[#2] 0xffffff000008c0d4 → main()
────────────────────────────────────────────────────────
gef➤  c
───────────────────────────────────────── registers ────
$x0  : 0x0000000000000003  
$x19 : 0x0000000000000004  
$x29 : 0xffffff00000920b0  →  0xffffff00000920d0  →  0xffffff00000920f0 
$x30 : 0xffffff000008c070  
$sp  : 0xffffff00000920b0  →  0xffffff00000920d0  →  0xffffff00000920f0 
──────────────────────────────────────────── stack ────
0xffffff00000920b0│+0x0000: 0xffffff00000920d0 ─┐ # [#1] 
0xffffff00000920b8│+0x0008: 0xffffff000008c070  │
0xffffff00000920c0│+0x0010: 0x0000000000000005  │  
0xffffff00000920c8│+0x0018: 0x00000000ffffffc0  │  
0xffffff00000920d0│+0x0020: 0xffffff00000920f0 ◄┘ # [#2]
0xffffff00000920d8│+0x0028: 0xffffff000008c0d4  │
0xffffff00000920e0│+0x0010: 0x0000000000000000  │
0xffffff00000920e8│+0x0018: 0x00000000ffffffc0  │
0xffffff00000920f0│+0x0020: 0x0000000000000000 ◄┘ # [#3]
0xffffff00000920f8│+0x0028: 0xffffff000008c018  
─────────────────────────────────────────── trace ────
[#0] 0xffffff000008c020 → stack_test()
[#1] 0xffffff000008c070 → stack_test()
[#2] 0xffffff000008c070 → stack_test()
[#3] 0xffffff000008c0d4 → main()
──────────────────────────────────────────────────────
</code></pre>
<p>可以看到每次递归调用压栈4个64位字，分别是：上一层FP，LR，参数x和0x00000000ffffffc0。最后一个64位字用途未知。</p>
<h3 id="练习9-backtrace">练习9-backtrace</h3>
<p>提供<code>read_fp()</code>接口，我们知道fp永远指向父函数的fp，故递归调用即可。</p>
<pre><code class="language-c">	u64* fp = (u64*) *((u64*)read_fp()); // 双层指针，因为第一层是本函数
	while(fp != 0) { 
        printk(&quot;LR %lx FP %lx Args %d %d %d %d %d\n&quot;, *(fp + 1), fp, *(fp - 2), *(fp - 1), *(fp), *(fp + 1), *(fp + 2)); //为什么5个参数是fp-2到fp+2？样例只包括一个参数，只要出现fp+2就能测试通过
        fp = (u64*) *fp; //下一层
	}
</code></pre>
<p>满分通过，懒得贴图了。</p>
<hr>
<p>看到大佬写的，瞬间不想写了，寄。<br>
https://www.cnblogs.com/kangyupl/p/chcore_lab1.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从scapy和wireshark学计算机网络]]></title>
        <id>https://lonelyuan.github.io/post/Computer_Network_Exp/</id>
        <link href="https://lonelyuan.github.io/post/Computer_Network_Exp/">
        </link>
        <updated>2021-10-22T15:55:54.000Z</updated>
        <content type="html"><![CDATA[<p>众所周知，计网被评为最困的计算机专业课，俗称计算机中的语文。👴看了《计算机网络－自顶向下方法》（后文简称CNTDA）之后，觉得翻译就像汤姆叔叔的烂苹果派一样糟糕，上帝啊，我发誓会狠狠踢他的屁股。建议带🔥去看英文原版。</p>
<p>但是👴最近接触的许多实验还是很好玩的，于是本文试图通过全程动手实操学习计网。</p>
<hr>
<p>实验来源：</p>
<ul>
<li>👴自己</li>
<li>SEEDLab，雪城大学的信息安全课配套实验，网络安全部分。国内知名度不高所以值得一做。<a href="https://seedsecuritylabs.org/Labs_20.04">官方网站</a></li>
<li>CNTDA 实验：<a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES">GIthub上抄的作业</a></li>
</ul>
<p>主要工具：</p>
<ul>
<li>wireshark是坠nb的网络封包分析软件。就是用来抓包的。</li>
</ul>
<blockquote>
<p>下载：<a href="https://www.wireshark.org/download.html">https://www.wireshark.org/download.html</a><br>
教程：<a href="https://www.javatpoint.com/wireshark">https://www.javatpoint.com/wireshark</a></p>
</blockquote>
<ul>
<li>scapy库是python的网络编程库，可以让你细致入微的操纵网络流量。就是用来发包的。
<ul>
<li>//不要和爬虫库scrapy混淆</li>
</ul>
</li>
</ul>
<blockquote>
<p>scapy文档：<a href="https://scapy.readthedocs.io/en/latest/">https://scapy.readthedocs.io/en/latest/</a><br>
中文版：<a href="https://www.osgeo.cn/scapy/introduction.html">https://www.osgeo.cn/scapy/introduction.html</a> //有些翻译错误</p>
</blockquote>
<hr>
<h2 id="计网基本概念">计网基本概念</h2>
<h3 id="包package">💣包(package)</h3>
<p>等等，啥是“抓包”？啥是“发包”？啥是“包”？</p>
<figure data-type="image" tabindex="1"><img src="https://lonelyuan.github.io/post-images/1635925682452.png" alt="原来这就是“包”" loading="lazy"></figure>
<p>当然，包不仅仅是一个 CSGO 术语，在计算机网络中，包(package)有多个近义词，包括：报文/数据报(Datagram)，分组/封包(Packet)……根据语境不同而区分，但大致指的是同一件事情：即网络中真正流动着的东西，我们希望网络来传递的东西。只不过“包”是最通俗的叫法，那么抓包和发包就不难理解了。</p>
<p>你还想问，包到底长什么样？众所周知，快递由包装和里面的东西组成，其实网络上的封包也差不多，也大致都有两部分：</p>
<ul>
<li>包头，学名首部(Header)——快递包装上的标签，写着目的地址，联系电话，快递号等信息</li>
<li>包体，学名载荷(Payload)——快递要运输的货物本身。某些语境下也喜欢称为报文。</li>
</ul>
<p>当然，网络封包归根结底还是线性的比特序列，于是我们需要包头来识别这个封包的相关信息，就像看快递先看标签一样。</p>
<p>另外，一个协议的封包也可以成为另一个协议的载荷，后面你会看到诸如<code>pkt.payload.payload.payload.payload</code>的套娃用法，要理解这种套娃，还需要知道分层思想。</p>
<h3 id="分层layering">🍰分层(layering)</h3>
<p>CNTDA 中用邮政系统类比计算机网络，这是最常用的例子，这里我们用快递物流网来举例。随便打开你的网购记录，你会发现快递物流大概经过以下过程：</p>
<blockquote>
<ul>
<li><strong>客户</strong>发货：把<em>货物</em>和<em>地址</em>交给快递点
<ul>
<li><strong>快递网点</strong>揽件：<em>包装</em>货物而变成包裹；包裹被送往最近的中转中心
<ul>
<li><strong>中转中心</strong>运输：根据包裹目的地不同，<em>分拣</em>并<em>装车</em>运输给不同的中转中心；若收到本片区的包裹，<em>卸车</em>并<em>分拣</em>给不同的网点</li>
</ul>
</li>
<li><strong>快递网点</strong>派送：按包裹的<em>地址</em>，快递员送货上门</li>
</ul>
</li>
<li><strong>客户</strong>取件：<em>拆箱</em>，拿到货物，确认无误签收</li>
</ul>
</blockquote>
<p>你知道发一个快递要经历怎样的困难吗？你不知道，你只关心你自己。这里的重点是，客户不需要关心中转中心如何指挥重型货车或飞机，网点也只需要关心如何包装好客户的货物。快递网络明显的呈现出三层的分层架构，<strong>每一层之间只需要关心自己的工作，并和相邻的层交互</strong>。这就是应对复杂系统的组织方法——分层。</p>
<p>课本上会提到OSI七层模型或者TCP/IP五层模型，这里的模型全称是<strong>协议分层模型</strong>，又来新词了，别急，后面还有：</p>
<ul>
<li>协议(Protocol)：同一层级内的交互规则。//横向</li>
<li>服务(Service)：不同层级间的交互规则。//纵向</li>
</ul>
<p>每一层的工作，就是调用下层的接口，并为上层提供服务。接口(Interface)和服务的区别是，服务作为实体，由本层负责实现，暴露出接口供上层调用；而接口则是抽象的，本层并不知道下一层的可靠性。</p>
<p>由此你能否看出分层思想的优越性？每一层只关注自己的实现，于是大问题被分解成了小问题。好比一个总工作量100的问题，不了解分层思想的你只能10+10+10+……=100；而分层思想提供了乘法法则，于是你可以通过10*10=100，只需要完成20工作量。个中思想也类似于OOP中的解耦思想。</p>
<p>上述类比中标注了一些对应关系：</p>
<ul>
<li>封包(Packaging)：包装，货物→包裹。信息在层次间传递的过程就是封包/解封的过程。</li>
<li>路由(Routing)：分拣。根据包裹上的标签，决定包装的去向。</li>
</ul>
<p>可以看到，每一层都有自己的“货物”，比如中转中心的载荷是满载包裹的长途货车而不是单个包裹。报文在每一层都被封装并交给下一层，要想得到原始报文只能一层一层解开，操作模式类似栈。由此协议分层模型也被简称为<strong>协议栈</strong>(Protocol stack)。</p>
<p>实际上不管5层还是7层，他们都可以简化成三层，正如上述快递网络体现的那样（自底向上顺序）：</p>
<ul>
<li>通信层：负责物理通信。
<ul>
<li>本层负责对接各种物理介质，向上提供点对点的通信服务</li>
<li>对应五层模型的物理层、链路层</li>
</ul>
</li>
<li>网络层：建立网络连接。
<ul>
<li>本层负责将点对点的通信组织成网状结构，将物理的通信转化为逻辑的通信服务</li>
<li>对应五层模型的网络层、运输层</li>
</ul>
</li>
<li>端层：发出原始报文。
<ul>
<li>本层负责实现用户需求，向用户提供透明可靠的网络服务</li>
<li>对应五层模型的应用层</li>
</ul>
</li>
</ul>
<p>偶剋！你已经了解了分层思想，下面来设计互联网吧！（迫真）</p>
<h2 id="️开始实验">⌚️开始实验</h2>
<p>有关计网的学习顺序自古就有自顶向下还是自底向上的分歧，自底向上就像搭积木，学的明白但较枯燥；自顶向下则有趣但总像雾里看花。而本系列实验将遵从浅入深出的原则，从应用层逐步深入到链路层再返回应用层，同时难度不断加大。</p>
<p>//【想看哪个没更新的可以催👴】</p>
<h3 id="应用层-web服务器-todo">应用层: Web服务器 | ⭐ | TODO</h3>
<h4 id="intro">Intro</h4>
<ul>
<li>
<p>目标：用scapy/socket做一个静态服务器。</p>
<ul>
<li>
<p>实际上，python3已经自带了一个简易http服务器：</p>
<pre><code class="language-shell">$ python3 -m http.server
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
127.0.0.1 - - [10/Nov/2021 14:51:57] &quot;GET / HTTP/1.1&quot; 200 -
</code></pre>
<p>浏览器访问：<code>localhost:8000</code>，如果当前目录下有<code>index.html</code>文件，浏览器即可显示该html文档。</p>
</li>
<li>
<p>该http服务器也是基于另一个python标准库socket编写的，本实验我们直接用socket实现一个更简单的http服务器。</p>
</li>
</ul>
</li>
<li>
<p>前置：</p>
<ul>
<li>
<p>术语：</p>
<ul>
<li>
<p>C/S架构(client-server)：互联网的基本模型。通信的双方通常分成两个角色：</p>
<ul>
<li>发起的一方称为客户端(C)，即前端。</li>
<li>接收的一方称为服务端(C)，即后端。为了保证随时接收请求，服务端需要持久监听某通信端口</li>
</ul>
</li>
<li>
<p>URL：统一资源标识符。也就是互联网上的地址，网址。</p>
<ul>
<li>完整语法：<code>[协议名]://[用户名]:[密码]@[服务器地址]:[服务器端口号]/[路径]?[查询字符串]#[片段]</code></li>
</ul>
</li>
<li>
<p>HTTP协议：应用层最普遍的文本协议之一。文本协议表示其所有内容都是可读的，其主要格式如下：</p>
<ul>
<li>
<pre><code>GET / HTTP/1.1\r\n                                           /* 一个状态行 */
Host: localhost\r\n                                          /* 多个首部行 */
...
Connection: close\r\n\r\n       /* 以两个CRLF(回车换行，编程时用\r\n表示)隔断 */
&lt;html&gt;... &lt;/html&gt;                                              /* payload */
</code></pre>
</li>
</ul>
</li>
<li>
<p>HTML：标记语言，用&lt;&gt;组织起网页的骨架。浏览器会把HTML源码渲染成好看的网页。</p>
</li>
<li>
<p>socket：应用层网络接口。</p>
<ul>
<li>上文提到网络层为应用层提供了逻辑通信的服务，socket就是该服务的基本接口。</li>
<li>socket将进程/应用和 (地址host,端口port) 二元组绑定，于是通过该二元组即可和网络上的进程通信。</li>
<li>一个主机有一个地址和多个端口。地址和端口的关系，就像房子和窗户的关系。</li>
<li>socket不仅由操作系统提供，如linux中进程得到socket之后便可像文件一样读写；各编程语言也都提供socket接口，本实验用到的就是python对socket的封装。</li>
<li>//其翻译“套接字”非常具有误导性，建议直接用英文单词。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>建议花5分钟通读《图解HTTP》前6章（或者《CNTDA》2.1-2.2节），以理解上述术语</p>
</li>
</ul>
</li>
</ul>
<h4 id="guidelines">Guidelines</h4>
<ol>
<li>
<h5 id="socket通信">Socket通信</h5>
</li>
</ol>
<p>要使用socket通信，通信双方都需要持有一个socket对象，其主要方法和生命周期如下：</p>
<pre><code>  SERVER                CLIENT

 socket()              socket()
    │                     │
    ▼                     │
  bind((host,port))       │
    │                     │
    ▼                     │
 listen(num)              │
    │                     │
    ▼                     ▼
 accept()             connect((host,port))
    │                     │
    ├──►send()──►recv()◄──┤
    │                     │
    ├──►recv()◄──send()◄──┤
    │                     │
    ▼                     ▼
 close()               close()
</code></pre>
<p>SERVER：</p>
<ul>
<li><code>bind()</code> 绑定地址和端口，绑定后该端口即不可被其他进程占用</li>
<li><code>listen(num)</code> 开始监听，num表示最大连接数量</li>
</ul>
<p>CLIENT：</p>
<ul>
<li><code>connect()</code>建立连接，默认是TCP连接</li>
</ul>
<p>于是我们可以建立起服务器代码的框架：</p>
<pre><code class="language-python">import socket

s = socket.socket() 
s.bind(('0.0.0.0', 8000))
s.listen(5)

while True:
    c, addr = s.accept()
    print('[+] accepted:', addr)
    req = c.recv(1024) 
    print('[+] recieved:', req.decode('utf-8')) # 接收类型为字节数组bytes，要打印则应当编码为字符串
    res = http_handler(req) # 解析请求，返回响应
    c.send(res)
    c.close()
</code></pre>
<p>你可以自己尝试编写socket客户端跟该服务器进行明文的通信。不过我们的目标是HTTP服务器，先复习一下HTTP协议格式，状态码，首部等知识吧。</p>
<ol start="2">
<li>
<h5 id="http解析">HTTP解析</h5>
</li>
</ol>
<p>如果编程能力尚可，你可以自己写HTTP类来把报文解析成对象。这里还是用现成的，scapy库提供的<code>HTTPRequest</code>和<code>HTTPResponse</code>类。</p>
<pre><code class="language-python">def http_handler(req_str):
    req = HTTPRequest()
    req.do_dissect(req_str) # 解析请求
    print('[+] req: ', req.summary())
    # body = route(req.Path.decode()) # 路由函数
    body = &quot;&lt;h1&gt;Hello~~~&lt;/h1&gt;&quot;
    res = HTTPResponse()
    res = HTTP() / res / body
    print('[+] res: ', res.summary())
    return raw(res)
</code></pre>
<ul>
<li>
<p><code>do_dissect()</code>方法将字符串解析为对象</p>
</li>
<li>
<p><code>HTTP()/res/body</code>：scapy核心语法<code>/</code>，表示协议栈的堆叠，可以链式调用。</p>
</li>
<li>
<p>这里的类型为：<code>HTTP / HTTPResponse / Raw</code>，之所以要这样三层表示，是因为HTTPResponse/HTTPRequest类仅仅是一个中间层，如果没有HTTP层，scapy会报warning。</p>
</li>
<li>
<p><code>raw()</code>方法返回封包的字节数组，可以看到在socket之上，我们先把报文转化为对象，解析之后再返回报文。</p>
</li>
<li>
<p>建议经常用这个方法观察封包的堆叠，有助于加深理解</p>
</li>
</ul>
<p>现在运行服务器，用浏览器访问<code>localhost:8000</code>，你可以看到大大的“Hello”了！</p>
<h4 id="task">Task</h4>
<p>下面的任务交给你，目标是尽量接近python自带http服务器的表现。</p>
<p>为了实现静态服务器，你需要根据访问的路径返回对应的内容。为此，请完善<code>route()</code>函数：</p>
<ul>
<li>访问根路径<code>/</code>将返回<code>index.html</code></li>
<li>使用os模块读取文件，注意文本文件和二进制文件（如图片）的处理</li>
<li>用HTTP响应码进行错误处理，比如<code>404 NOT FOUND</code>，<code>302 REDIRECT</code></li>
</ul>
<p>最后，在根目录(你在哪里运行你的服务器脚本，那里就是你的根目录)下放入任意文件，浏览器都可以访问其内容，如果不存在则会返回404。</p>
<h4 id="expand">Expand</h4>
<ul>
<li>本实验几乎没有讲解HTTP首部的细节，请自行了解诸如<code>Content-Type:</code>，<code>Content-Length:</code>，<code>Transfer-Encoding:</code>等首部，看看传输图片/压缩文件时的标准做法，以及在遇到大文件时如何实现分段运输。（尽管我们的实现很简陋，浏览器还是能正常工作，说明HTTP和HTML是相当健壮的协议）</li>
<li>你的服务器是否有安全问题？访问<code>/../../../../etc/passwd</code>（linux下），是否暴露了某些秘密？</li>
<li>服务器概念辨析：Web初学者容易对服务器概念感到迷惑。软件语境下，服务器指对外提供服务的程序，常用服务器如apache、nginx，tomcat等；硬件语境下则指运行着服务器软件的机器。</li>
<li>我们实现的是静态网站，你可能疑惑是不是还有动态网站。当然有，区分动态和静态并不是网页会不会自己动，而是服务器上的数据是否可以动态的改变，而我们的服务器只能被动的显示文件，客户端无法做出任何更改。现代web框架诸如Springboot，Flask之类当然是动态网站框架。</li>
</ul>
<p>实际上，计网并不关心应用层以上的东西，让我们向下看，探究socket背后的原理吧。</p>
<h3 id="传输层-tcp观察-todo">传输层: TCP观察 | ⭐ | TODO</h3>
<p>术语：</p>
<ul>
<li>传输层：负责可靠运输</li>
<li>帧，报文</li>
<li>TCP/UDP</li>
</ul>
<p>实验：</p>
<ul>
<li>用wireshark观察TCP连接的建立和结束。</li>
<li>尝试用scapy建立TCP连接 https://www.cnblogs.com/darkpig/p/7629854.html</li>
</ul>
<p>拓展：</p>
<ul>
<li>TCP核心：滑动窗口，重传策略，阻塞控制</li>
</ul>
<p>那么，网络如何寻找一个地址？</p>
<h3 id="网络层-路由追踪">网络层: 路由追踪 | ⭐</h3>
<h4 id="intro-2">Intro</h4>
<p>术语：</p>
<ul>
<li>IP层：IP协议，ICMP协议，路由协议</li>
<li>路由追踪：请求某地址经过了那些路由器？</li>
</ul>
<h4 id="guidelines-2">Guidelines</h4>
<p>scapy实现了路由追踪函数，你可以钻研一下<a href="https://github.com/secdev/scapy/blob/master/scapy/layers/inet.py#L1740-L1773">源码</a>（很短），下面写一个自己的traceroute。</p>
<h4 id="task-2">Task</h4>
<p>下面用Ipython演示：</p>
<pre><code class="language-python">In [1]: from scapy.all import *

In [2]: target=&quot;www.amazon.com&quot;

In [3]: ans, unans = sr(IP(dst=target,ttl=(1,30))/TCP(flags=0x2))
Begin emission:
Finished sending 30 packets.
.*****..**********..........................................................................^C
Received 92 packets, got 15 answers, remaining 15 packets

In [4]: for snd, rcv in ans:
   ...:     print(snd.ttl, rcv.src, isinstance(rcv.payload, TCP))
   ...:
1 11.206.119.46 False
2 11.110.80.173 False
3 10.102.15.74 False
4 11.73.2.241 False
5 124.160.189.101 False
6 219.158.97.2 False
7 219.158.34.190 False
8 69.192.14.38 True
9 219.158.24.134 False
10 219.158.10.30 False
11 69.192.14.38 True
12 69.192.14.38 True
13 69.192.14.38 True
14 69.192.14.38 True
</code></pre>
<p>下面讲解核心代码：</p>
<p><code>ans,unans=sr(IP(dst=target,ttl=(1,30),id=RandShort())/TCP(flags=0x2))</code></p>
<ul>
<li>sr()：send and receive，返回的两个参数分别是得到应答的数据包列表和未应答的包列表。</li>
<li>ttl=(4,30)：ttl参数在IP层表示ICMP包的转发次数（跳数）。此外，传入tuple表示一个范围，sr函数将会为这个范围内的每个值生成一个发包。（如果有多个tuple参数，则会按笛卡尔积规则生成发包列表）</li>
<li>TCP(flags=0x2)：在TCP头部设定flag字段的值，0x2对应ACK，即确认收到包。</li>
<li>综合起来，这条代码将发送30个包，其ttl从1到30。并筛选返回ACK的包。</li>
<li>这样根据IP层路由算法，到达ttl的包无论是否找到目标都会返回，直到找到目标，TCP层返回ACK。遍历ttl形成的列表即是经过的所有路由。</li>
</ul>
<h4 id="expand-2">Expand</h4>
<h3 id="网络层-欺骗ping-todo">网络层: 欺骗ping | ⭐ | TODO</h3>
<h4 id="intro-3">Intro</h4>
<ul>
<li>来源：https://seedsecuritylabs.org/Labs_20.04/Files/ICMP_Redirect/ICMP_Redirect.pdf</li>
<li>术语：</li>
</ul>
<h4 id="guidelines-3">Guidelines</h4>
<h4 id="task-3">Task</h4>
<h4 id="expand-3">Expand</h4>
<h3 id="链路层-arp缓存投毒-todo">链路层: ARP缓存投毒 | ⭐⭐ | TODO</h3>
<p>https://seedsecuritylabs.org/Labs_20.04/Files/ARP_Attack/ARP_Attack.pdf</p>
<h3 id="传输层-tcp攻击-todo">传输层: TCP攻击 | ⭐⭐ | TODO</h3>
<p>https://seedsecuritylabs.org/Labs_20.04/Files/TCP_Attacks/TCP_Attacks.pdf</p>
<p>TCP协议<br>
SYN泛洪<br>
TCP reset<br>
TCP session hijacking反弹shell （重点）</p>
<h3 id="网络层-natdhcp和虚拟机-todo">网络层: NAT，DHCP和虚拟机 |  ⭐⭐ | TODO</h3>
<p>相信折腾过虚拟机的同学都绕不过这个问题：我的虚拟机怎么连不上网？本实验基于wmware虚拟机平台，讲解几种虚拟机网络模式及其原理。</p>
<h3 id="应用层-dns本地攻击-todo">应用层: DNS本地攻击 | ⭐⭐⭐ | TODO</h3>
<p>https://seedsecuritylabs.org/Labs_20.04/Files/DNS_Local/DNS_Local.pdf</p>
<h3 id="应用层-ssl协议和https-todo">应用层: SSL协议和HTTPS | ⭐⭐⭐⭐ | TODO</h3>
<h3 id="应用层-多线程web代理服务器-todo">应用层: 多线程Web代理服务器 | ⭐⭐⭐⭐⭐  | TODO</h3>
<h3 id="应用层-vpn-todo">应用层: VPN | ⭐⭐⭐⭐⭐ | TODO</h3>
<p>探究VPN原理</p>
<h3 id="应用层-v2ray协议学习-todo">应用层: V2Ray协议学习 | ？？？ | TODO</h3>
<p>有生之年研究一下Vmess等协议</p>
<!-- 省略的：
- 防火墙iptables实验
- mitnick攻击
- BGP 
- 802.11
- -->]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[年轻人的第二个网站（二） - flask-supreme-tutorial]]></title>
        <id>https://lonelyuan.github.io/post/flask-supreme-tutorial/</id>
        <link href="https://lonelyuan.github.io/post/flask-supreme-tutorial/">
        </link>
        <updated>2021-09-16T04:43:23.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://lonelyuan.github.io/post/flask-mega-tutorial/">上回书</a>说到，网站初具雏形，但经高人指点，还是有很多不足。<br>
本文将大胆扩充网站结构，目标是将网站拓展成一个 CMS 。<br>
所以，不要停下来啊！👆（指开发</p>
</blockquote>
<hr>
<h2 id="0x00-蓝图与重构">0x00 蓝图与重构</h2>
<p>与之前相比，网站将增加以下功能：</p>
<ul>
<li>图库：文件上传模块</li>
<li>评论：楼中楼功能</li>
<li>后台：权限模块，后台模块</li>
<li>优化：更健壮的数据库接口，更细致的权限控制</li>
<li>plus功能：用 redis 实现热搜</li>
</ul>
<p>在开发这些功能之前，首先重整项目结构。如：</p>
<ul>
<li>完全蓝图化。<a href="https://blog.csdn.net/ldq_sd/article/details/104766636">参考</a>
<ul>
<li>模板也放入独立子目录里，蓝图注册时使用template_folder参数，不过这样容易产生bug，flask 官方推荐使用硬编码，汗。</li>
</ul>
</li>
<li>清理依赖，不使用维护状态差的库。
<ul>
<li>开发新功能的时候，去哪里找最佳实践，找好用的库呢？有一个 Github 搜索小技巧，名为 &quot;awesome-xxx&quot; 的仓库通常是某技术的优质资源列表。如：https://github.com/humiaozuzu/awesome-flask</li>
</ul>
</li>
</ul>
<h2 id="0x01-文件系统">0x01 文件系统</h2>
<blockquote>
<p>本部分参考了<a href="https://greyli.com">李辉</a>大佬的系列文章，<br>
https://zhuanlan.zhihu.com/p/23731819?refer=flask</p>
</blockquote>
<p>头像，照片……文件上传是绕不开的话题。在<a href="#shangyipian">上一篇</a>参考的教程中，头像的实现是由托管网站生成随机的图片。遗憾的是并没有像 ORM 一样方便数据库处理的文件处理框架可供使用，还是自己把他啃下来吧。</p>
<p>注意踩坑！大部份资料推荐使用Flask_uploads插件，然而使用该插件时出现如下报错：</p>
<pre><code>ImportError: cannot import name 'secure_filename' from 'werkzeug' 
</code></pre>
<p>查阅Stackoverflow得知是PYPI源上的Flask_uploads插件不再维护了，于是和 werkzeug 库的api不兼容，是插件内在的bug。网上的解决方法有二：</p>
<ul>
<li>一是修改库源码</li>
<li>二是换另一个库，维护良好且可无缝迁移，名为<a href="https://pypi.org/project/Flask-Reuploaded/">Flask-Reuploaded</a></li>
</ul>
<p>前者不利于后续部署，本人倾向于后者。然而，使用新库也遇到了诸多麻烦，使用<code>UploadSet.url()</code>方法时，报错如下：</p>
<pre><code>werkzeug.routing.BuildError: Could not build url for endpoint '_uploads.uploaded_file' with values ['filename', 'setname']. 
</code></pre>
<p><code>UploadSet.url()</code>方法返回对应文件的可访问url，返回的url默认带有<code>_upload/</code>前缀，这是 Flask-Uploads 自带的路由，也被称为 autoserve 。<br>
然而官方文档里有这样一句话</p>
<blockquote>
<p>autoserve of uploaded images now has been deactivated; this was a poorly documented “feature”, which even could have lead to unwanted data disclosure; if you want to activate the feature again, you need to set UPLOADS_AUTOSERVE=True</p>
</blockquote>
<p>看来 Flask-Reuploaded 的作者似乎认为文件读取功能与我无瓜。好吧，这部分我们自己实现。</p>
<p>// 浪费了一晚上debug，结果只是因为文档没看明白，再次证明读文档的重要性。</p>
<h3 id="flask-reuploaded-文件上传">Flask-Reuploaded: 文件上传</h3>
<p>插件将上传的一类文件抽象成集合<code>UploadSet</code>。对每个 Set 有如下操作：</p>
<ul>
<li>配置文件类型：<code>photos = UploadSet('photos', IMAGES)</code> //类型包括：IMAGES、TEXT、AUDIO……</li>
<li>配置存贮路径：<code>app.config['UPLOADED_PHOTOS_DEST']</code> // Photos 为 Set 的变量名</li>
<li>保存文件：<code>filename = photos.save(request.files['photo'])</code></li>
<li>返回链接：<code>photos.url(filename)</code></li>
</ul>
<p>最后，注册 Set 和插件注册类似：<code>configure_uploads(app, [avatars, photos])</code> //可一次性全部注册</p>
<p>实现头像上传的步骤如下：</p>
<ul>
<li>模型层： User 添加 avatar 字段，储存头像的文件名。原<code>avatar()</code>方法作为默认头像。</li>
<li>表单层： edit_profile 表单增加<code>FileField</code>字段</li>
<li>视图层： 储存文件，向数据库提交文件名。</li>
<li>模板层： 改用硬路由获取url。// 最终 .url() 还是有bug，再次说明不要乱用不知名的插件</li>
</ul>
<h3 id="图库模块">图库模块</h3>
<p>本模块包括如下路由：</p>
<ul>
<li><code>/index</code>：主页显示瀑布流</li>
<li><code>/upload</code>：上传接口：参考头像上传</li>
<li><code>/detail</code>：详情，显示评论</li>
<li><code>/delete</code>：删除接口：同时删除文件</li>
</ul>
<p>由于本项目前端框架是 Bootstrap ，👴不想写Jquery，所以直接刷新页面，也不弄无限滚动了，按钮了事。另外为了不同列长度尽量均匀，故采用取巧的方法，平均分配。根据大数定理，只要随机图片足够多肯定会差不多均匀。。。。</p>
<h2 id="0x02-评论系统">0x02 评论系统</h2>
<h3 id="数据库设计">数据库设计</h3>
<p>评论包含了两个一对多关系，既是评论和文章的一对多关系，也是评论和用户的一对多。为此，只需要给User和Post添加关系即可。<br>
然而，我们希望设计统一的Comment模型，评论的对象既可以是文章，也可以是图片，也可以是其他评论。为此，添加一个枚举类型的字段指示评论类型，从而采用不同的处理逻辑。</p>
<h3 id="楼中楼">楼中楼</h3>
<p>而主流网站不光支持对文章评论，还支持楼中楼。对楼中楼的实现有以下几种方案：</p>
<ul>
<li>按时间平铺：以原百度贴吧为例
<ul>
<li>添加 <code>reply_id</code> 字段，指示要回复的人</li>
</ul>
</li>
<li>套娃式缩进：以某些老式bbs为例
<ul>
<li>添加 <code>parent_id</code> 字段，指示父评论（顶层评论则为本身id），在实体类中保存子评论列表</li>
</ul>
</li>
<li>弹窗式查看：以知乎，b站为例
<ul>
<li>在按时间平铺的基础上，若 <code>reply_id</code>存在添加“查看对话”按钮，递归的构建对话并弹窗。</li>
</ul>
</li>
</ul>
<p>其中，第一种实现简单，用户不友好；第二种实现复杂，对多层级对话无法胜任；第三种是最主流的实现方式。</p>
<p>通过以<code>reply_id</code>作为指针，所有评论连接成了一棵树，在任意一个节点进行“查看对话”操作，就是执行树的寻根。“查看对话”函数如下：</p>
<pre><code class="language-python">    @staticmethod
    def view_dialogue(c_id):
        dialogue = [c_id]
        while Comment.query.get(c_id).type == 'comment':
            c_id = Comment.query.get(c_id).reply_id
            if Comment.query.get(c_id) is None:
                break
            dialogue.append(c_id)
        return dialogue
</code></pre>
<h2 id="0x03-网站后台">0x03 网站后台</h2>
<p>网站的后台通常给管理员提供统一监管数据库的界面。有以下插件帮助实现：</p>
<ul>
<li>Flask-admin：一键生成后台页面，并可以自定义视图和模型。</li>
<li>Flask-Security： 比admin层次更高，封装了常用视图和模板。但是文档少，且很多功能我们已经实现了，再使用它就要推翻重做。遂弃用。</li>
</ul>
<p>本教程中使用了 RBAC（Role-Based Access Control) 基于角色的访问控制，简单说就是设计一个角色表，用户表和角色表用关联表实现多对多关联。这样做的好处是，针对角色的权限分配，修改权限时无需修改每个用户。</p>
<h2 id="0x04-热搜">0x04 热搜</h2>
<p>本节再加入一个重量级内容，利用 redis 实现浏览量排行榜，也就是热搜。当然，真正的热搜榜单排名规则更加复杂，这里只通过简单的浏览量计数来练习 redis 的使用。</p>
<p>【👴有时间再做】</p>
<h2 id="不要让开发停下来">不要让开发停下来</h2>
<p>可以加的功能还有很多：时间线，emoji支持，多媒体，前后端分离(Vue)，，</p>
<p>除了功能，当面对更高量级的流量时，网站性能便更加重要，这时候消息队列，PRC，微服务/分布式，，，更让人头秃。</p>
<p>Web开发之路，道阻且长。但是，只要开发不停下来，道路就会不断延申。。。（希望之花.mp3）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[年轻人的第二个网站 - The Flask Mega Tutorial]]></title>
        <id>https://lonelyuan.github.io/post/flask-mega-tutorial/</id>
        <link href="https://lonelyuan.github.io/post/flask-mega-tutorial/">
        </link>
        <updated>2021-09-09T12:18:56.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文为 Flask 框架学习笔记，主要参考了 <a href="https://luhuisicnu.gitbook.io/the-flask-mega-tutorial-zh">The-Flask-Mega-Tutorial</a> 和 《Flask Web开发：基于Python的Web应用开发实战》两本书，并在原项目的基础上拓展。（下文统称这两个资源为“本教程”）<br>
不熟悉 Flask 框架请先阅读<a href="https://dormousehole.readthedocs.io/en/latest/quickstart.html">快速上手 - flask 中文文档</a> 。</p>
<p>这两本书的作者是同一个人，就内容上说后者算是前者的豪华版。本教程的优点是内容全面，从入门到部署一站式服务；缺点是不够深入，且有些过时，书中举例的诸多插件均为作者为了此书而开发的，已经许久不再维护，导致很难在其示例项目上拓展。一看扉页，2015年出版，那没事了。<br>
至于第一个网站？参见<a href="#%E6%88%91%E8%BF%98%E6%B2%A1%E5%86%99%E5%91%A2">#TODO:年轻人的第一个网站</a></p>
</blockquote>
<hr>
<h2 id="0x00-大型项目结构">0x00 大型项目结构</h2>
<p>在大部分面向初学者的 demo 中，应用以简单的项目结构甚至单文件表示。在大型项目中，网站的不同功能被拆分成独立的模块，以方便拓展和维护。一个更通用的 Flask 项目代码架构如下：（仅考虑业务代码）</p>
<pre><code>microblog/ # 根目录
  app/ # 项目源码
    __init__.py # 项目初始化，当该包被import，首先执行__init__.py
    routes.py
    forms.py
    ...
  main.py # 框架入口
  config.py # Config配置类
  .flaskenv
  ...
</code></pre>
<p>根目录下的文件有：</p>
<ul>
<li><code>app/</code>所有网站源代码统一归到app目录下。
<ul>
<li>在<code>app/</code>内部，不同的功能可进一步划分成独立模块，详见[模块化应用](#0x05 模块化应用：功能解耦)一章。</li>
</ul>
</li>
<li><code>main.py</code>: 入口脚本，通过该文件引入app中的代码并生成应用实例（命名随意）</li>
<li><code>.flaskenv</code>: flask环境变量，以配合flask命令。入口脚本被定义为<code>FLASK_APP</code>，执行<code>flask run</code>时将启动该脚本。</li>
<li><code>config.py</code>: 配置脚本，整个项目的配置信息都写在Config类里。与环境变量的区别在于，因为是python脚本，功能更强大，可被任何地方的代码引用。</li>
</ul>
<h2 id="0x01-hello-world模板和视图">0x01 Hello world：模板和视图</h2>
<p>最基本的 web 功能，无非接受请求、返回数据。其中，路由 (route) 用来区分不同的请求，模板 (templates) 用来生成不同的数据。</p>
<h4 id="路由视图">路由/视图</h4>
<p>在非前后端分离的项目中，视图函数直接返回渲染好的网页，由<code>@app.route()</code>修饰后，视图和路由便绑定在一起。<br>
在mvc模型中更像controller控制器的角色，然而在flask生态中更喜欢称为视图函数。</p>
<ul>
<li><code>url_for()</code> 使用URL到视图函数的内部映射关系来生成URL，用来替换硬链接。在业务功能解耦后必须使用这种方式。
<ul>
<li>NOTE：当路由和视图函数名不一致，访问该路由可以正确响应，但是使用<code>url_for()</code>调用该视图时会报错</li>
</ul>
</li>
<li><code>{{% extends &quot;base.html&quot; %}}</code> and <code>{{% include &quot;_post.html&quot; %}}</code> 使用子模板来实现网页公用的部分。如：页眉，页脚，列表项等。
<ul>
<li>模板和 Python 代码的关系有些类似与 JSP 和 Java 代码的关系，但模板语法并不是完整的脚本语言，相较而言限制更多，安全性更好。</li>
</ul>
</li>
</ul>
<h4 id="表单">表单</h4>
<blockquote>
<p>几乎所有成功的框架都有丰富的插件生态。下面引入新功能时，大多借助插件来方便的实现。大多数Flask插件使用<code>flask_&lt;name&gt;</code> 命名约定。</p>
</blockquote>
<p>Flask-WTF插件提供了对Web表单的抽象，只需定义表单类以及设置类属性即可。</p>
<p>模板语法：</p>
<ul>
<li><code>{{ form.&lt;name&gt;.label }}</code>渲染标签</li>
<li><code>{{ form.&lt;name&gt;() }}</code>获取属性值</li>
<li><code>form.hidden_tag()</code>模板参数生成了一个隐藏字段，其中包含一个用于保护表单免受CSRF攻击的token</li>
</ul>
<p>将表单引入模板</p>
<pre><code class="language-python">form = LoginForm() # 生成了一个实例传入模板
return render_template('login.html', title='Sign In', form=form)
</code></pre>
<h4 id="flash-闪现消息">flash 闪现消息</h4>
<p>flash 通过 session 储存，用于显示只出现一次的提示消息。用法：</p>
<ul>
<li>在路由中使用<code>flash()</code>，触发时消息便写入 session 中的 message 列表</li>
<li>在模板中使用<code>get_flashed_messages()</code>，从 session 中读取</li>
</ul>
<h2 id="0x02-数据库-orm">0x02 数据库 ORM</h2>
<p>很久很久以前，web网站和数据库交互还需要写很多很硬的 SQL 语句，效率低且容易出现注入漏洞(SQLi)。现代web开发都使用 ORM 框架简化数据库交互，且基本杜绝了 SQLi 漏洞。</p>
<p>本项目使用如下插件打通数据库：</p>
<ul>
<li>Flask-SQLAlchemy: Python生态最知名的ORM框架</li>
<li>Flask-Migrate: 本教程作者编写的数据库迁移框架</li>
</ul>
<blockquote>
<p>插件首先要注册。统一流程: 初始化app实例，传入插件类作为插件实例的参数</p>
<pre><code class="language-python"># app/__init__.py
app = Flask(__name__) # flask基类
app.config.from_object(Config)
db = SQLAlchemy(app)
migrate = Migrate(app, db)
</code></pre>
</blockquote>
<h3 id="sqlalchemymodel层">SQLalchemy：model层</h3>
<h4 id="模型定义">模型定义</h4>
<p>使用类和类属性代表 table 和 colunm ，便可轻松编写数据模型。SQLalchemy 的概念抽象如下图：<br>
<img src="https://lonelyuan.github.io/post-images/1631793936306.png" alt="" loading="lazy"></p>
<p>Flask-SQLAlchemy 自动设置类名为小写来作为对应表的名称，也可以用<code>__tablename__</code>类属性来定义。</p>
<pre><code class="language-python">class Post(db.Model): # 表
    id = db.Column(db.Integer, primary_key=True) # 列
    ....
</code></pre>
<h4 id="curd基本操作">CURD基本操作</h4>
<p>ORM 框架通常集成了常用操作，但也支持更底层的数据库接口。</p>
<blockquote>
<p>在 Springboot Jpa 中，根据方法名的拼写来写自定义查询，而在 SQLalchemy 中，提供的接口通过链式调用拼接。</p>
</blockquote>
<p>在 SQLalchemy 中，基本操作大都有基于事务 (session) 的和基于查询 (query) 的两种方式。</p>
<ul>
<li>
<p>查</p>
<pre><code class="language-python">session.query(User)
</code></pre>
<p>query方法只有构造一个查询，只有在<code>Query.get()</code>、<code>Query.all()</code>、<code>Query.one()</code>等结束符之后才会执行查询</p>
</li>
<li>
<p>增：</p>
<pre><code class="language-python">db.session.add(user)
db.session.commit()
</code></pre>
</li>
<li>
<p>删</p>
<pre><code class="language-python">session.query(User).delete()
# or
session.delete(session.query(User).get(1))
session.commit()
</code></pre>
</li>
<li>
<p>改</p>
<pre><code class="language-python">query = (session
	.query(User)
	.filter_by(id=1)
	.update({&quot;username&quot;: User.username + &quot;a&quot;}, synchronize_session=False)
)
# or
user = (session.query(User).get(1))
user.password = &quot;zxcv&quot;
session.commit()
</code></pre>
</li>
</ul>
<h3 id="flask-migrate-数据库迁移">Flask-Migrate: 数据库迁移</h3>
<p>配置数据库的初始数据框架，一般写成SQL脚本形式。<br>
migrate 框架直接根据 model 层生成迁移脚本，可以方便的跟踪数据模型的修改和数据库的切换。（这个框架还是本教程作者自己开发的，强）</p>
<p>flask db子命令</p>
<ul>
<li><code>flask db init</code>：初始化，生成migrations目录</li>
<li><code>flask db migrate</code>：生成迁移脚本，修改model后使其生效
<ul>
<li><code>flask db migrate -m &quot;posts table&quot;</code></li>
</ul>
</li>
<li><code>flask db upgrade</code>：应用数据库修改（开发阶段默认使用sqlite数据库</li>
<li><code>flask db downgrade</code>：回滚上次的迁移</li>
</ul>
<h2 id="0x03-开发范式用户系统">0x03 开发范式：用户系统</h2>
<blockquote>
<p>mixin：混入，多重继承的一种形式</p>
</blockquote>
<p>表单和数据库支持分别解决了前端和后端的基本需求，下面可以上线一个基本功能了，用户登录。<br>
所需插件：Flask-Login。</p>
<h4 id="usermixin类">UserMixin类</h4>
<p>UserMixin类集成了login插件要求的用户模型属性，将其混入到 User 模型中，即可用<code>@login_required</code>实现权限控制。</p>
<pre><code>@app.route('/result/', methods=['POST']) # NOTE：有顺序关系，反之则不生效
@login_required 
</code></pre>
<p>用户系统，包括登录、登出、注册几个功能。编写这些功能的步骤其实很类似：</p>
<ul>
<li>设计数据库，在model.py中</li>
<li>设计表单对象，在form.py中</li>
<li>设计页面，在模板.html中</li>
<li>设计视图函数，在routes.py中</li>
</ul>
<p>也对应了mvc框架的设计理念，比如设计表单就有些像 javaweb 中的 DAO 层。但也有区别， Flask 框架更希望业务逻辑写在数据库模型中，而视图函数尽量保持简洁，以方便单元测试。</p>
<h4 id="prg-模式">PRG 模式</h4>
<p>即为 <code>Post/Redirect/Get</code>，其格式大概如下：</p>
<pre><code class="language-python">@bp.route('/some_form', methods=['GET', 'POST'])
def some_form():
    # prepare forms 
    if form.validate_on_submit():
        # submit modification
        return redirect(url_for('main.some_form'))
    elif request.method == 'GET':
    	# GET data
    return render_template('some_form.html', form=form)
</code></pre>
<p>默认情况，提交 POST 请求后，如果直接刷新浏览器，会重新在 POST 一次。使用PRG模式即可解决重复提交表单的问题。</p>
<h2 id="0x04-深入数据库粉丝机制">0x04 深入数据库：粉丝机制</h2>
<h3 id="数据库关系">数据库关系</h3>
<p>要关注别人，就要让数据库记住我关注的人的名字，当然，只记住名字肯定不够，万一改名了呢。因此每个用户都需要有唯一有效的标识（其实更重要的是性能因素）。正因如此，数据库中每个表都要有一个唯一的列，称为<strong>主键</strong>(primary key)。当不同表之间存在关系，一个表要通过主键寻找其他表项，其他表的主键储存在本表中，称为<strong>外键</strong>(foreign key)。外键关联既可以表示一对一的关系，也可以一对多(1-&gt;n)。</p>
<p>SQLalchemy 对关系的定义如下：</p>
<ul>
<li>外键：<code>db.ForeignKey('user.id')</code></li>
<li>关系：<code>db.relationship('Post', backref='author', lazy='dynamic')</code>
<ul>
<li>参数1：所关联的表(n in 1-&gt;n)，这里是模型的变量名</li>
<li>参数2：由 &quot;n&quot; 回调 &quot;1&quot; 的虚拟字段，用法：<code>post.author</code></li>
</ul>
</li>
</ul>
<h3 id="粉丝机制">粉丝机制</h3>
<p>然而，粉丝机制包括关注和被关注。这是一种多对多的关系，于是需要用含有两个外键的<strong>关联表</strong>表示。又因为关注者和被关注者在一个表里（User），这种关系又称为<strong>自引用</strong>。</p>
<h4 id="模型">模型</h4>
<ul>
<li>
<p>关联表只有引用类型，故不需要派生模型类</p>
<pre><code class="language-python">followers = db.Table(
    'followers',
    db.Column('follower_id', db.Integer, db.ForeignKey('user.id')),
    db.Column('followed_id', db.Integer, db.ForeignKey('user.id'))
)
</code></pre>
</li>
<li>
<p>为User添加关系</p>
<pre><code class="language-python">followed = db.relationship('User', # 右侧实体
    secondary=followers, # 指定关联表
    primaryjoin=(followers.c.follower_id == id), # 指定左关系
    secondaryjoin=(followers.c.followed_id == id), # 指定右关系
    backref=db.backref('followers', lazy='dynamic'), lazy='dynamic') # 指定回调
</code></pre>
</li>
</ul>
<h4 id="复杂查询">复杂查询</h4>
<ul>
<li>
<p>查询粉丝列表</p>
<ul>
<li>
<p>SQL 语句：<code>SELECT * FROM user, followers WHERE followers.follower_id = 3 AND followers.followed_id = user.id</code></p>
</li>
<li>
<p>SQLalchemy 接口：<code>user.followers.all()</code></p>
</li>
<li>
<p>实际执行的 SQL 语句：（打印 query 对象得到）</p>
<pre><code>SELECT ,,,  FROM user, followers 
WHERE followers.followed_id = ? AND followers.follower_id = user.id
</code></pre>
</li>
<li>
<p>NOTE：如果方法集成在model里，方法名不要和字段名相同，自己定义的方法会覆盖该字段。</p>
</li>
</ul>
</li>
<li>
<p>查看已关注用户的动态</p>
<ul>
<li>
<p>SQL 语句：<code>SELECT * FROM post JOIN followers on followers.followed_id = post.user_id where followers.follower_id = 2</code></p>
</li>
<li>
<p>SQLalchemy 接口：</p>
</li>
</ul>
<pre><code class="language-sql">Post.query.join(
  followers, (followers.c.followed_id == Post.user_id)).filter(
    followers.c.follower_id == self.id).order_by(
       Post.timestamp.desc())
</code></pre>
<ul>
<li>
<p>实际执行的SQL语句：</p>
<pre><code class="language-sql">SELECT ,,, FROM 
(SELECT ,,,
   FROM post JOIN followers ON followers.followed_id = post.user_id 
   WHERE followers.follower_id = ? 
   UNION SELECT * 
   FROM post 
   WHERE post.user_id = ?
) 
AS anon_1 ORDER BY anon_1.post_timestamp DESC
</code></pre>
</li>
</ul>
</li>
</ul>
<p>由于python的弱类型特征，有时候很难明白函数之间传递的是什么对象。我们从上往下梳理一遍：</p>
<ul>
<li>请求到达路由函数，开始执行查询<code>Post.query.....</code>，此时只是在构造查询，并未取得数据，此时的对象类型：<code>&lt;class 'sqlalchemy.orm.query.Query'&gt;</code></li>
<li>直到<code>get()</code>,<code>all()</code>,<code>paginate().items</code>结束符等出现，查询才被执行，返回数据类型实例，如User。</li>
<li>数据类实例传入模板，并由<code>__str__</code>等方法参与渲染。</li>
</ul>
<h2 id="0x05-网站美化">0x05 网站美化</h2>
<p>本教程提供的flask-bootstrap插件，较为简陋，且该插件年久失修，遂替换之。在此之前，先搞明白目前项目前端的架构</p>
<pre><code>/templates
   auth/
   errors/
   base.html
   _posts.html
   index.html
   ... 
</code></pre>
<p>所有模板都有一个父模版：<code>base.html</code>，其结构如下：</p>
<pre><code class="language-html">{% extends 'bootstrap/base.html' %}
{% block title %}Hallo Wolrd{% endblock %}
{% block head %} ... {% endblock %}
{% block scripts %} ... {% endblock %}
{% block navbar %} ... {% endblock %}
{% block content %}
    ...
    {% block app_content %}{% endblock %}
{% endblock %}
</code></pre>
<p><code>app_content</code>留空，即其余模板均在<code>app_content</code>内填充。</p>
<p>进一步追溯<code>bootstrap/base.html</code>的源码，发现其它 block 诸如<code>navbar</code>也都留空或仅仅配置了 Bootstrap 的 cdn。 由此，只需将<code>base.html</code>迁移即可。</p>
<p>在网上寻找新的UI模板，不要在中文互联网搜索，basically garbage。找到一个 <a href="https://demos.creative-tim.com/material-kit/index.html">Meterial 模板</a> 还算顺眼，遂用之。</p>
<p>不熟悉 Bootstrap 布局的可以使用可视化工具来设计前端，如：http://www.ibootstrap.cn/</p>
<p>对照模板，将<code>base.html</code>掏空，效果如下：</p>
<figure data-type="image" tabindex="1"><img src="https://lonelyuan.github.io/post-images/1631795716824.png" alt="" loading="lazy"></figure>
<p>遇到的bug有：</p>
<ul>
<li>下拉菜单失效：查询得知有可能是bootstrap版本冲突
<ul>
<li>//结果并不是，只是忘记引入js文件而已，我是傻逼。</li>
</ul>
</li>
<li>文件上传按钮消失：本教程中，表单渲染采用<code>wtf.quick_form()</code>，这玩意还是来自<code>bootstrap/wtf.html</code></li>
</ul>
<p>最后决定整个🐏了 Flask-Bootstrap 插件。</p>
<h4 id="富文本编辑器">富文本编辑器</h4>
<p>在《Flask Web开发：基于Python的Web应用开发实战》中提到了markdown编辑器的实现。</p>
<p>需要的包：</p>
<ul>
<li>PageDown: JS 版 Markdown 渲染器，用于客户端预览。</li>
<li>Flask-PageDown: flask 集成插件。该插件需要注册</li>
<li>Markdown: Python 版 Markdown 渲染器，用于服务端渲染。</li>
<li>Bleach: HTML 清理器，保证安全性</li>
</ul>
<p>为了兼顾安全和效率，做法是同时保存 markdown 源文本和 HTML 文件。步骤如下：</p>
<ul>
<li>表单改为 <code>PageDownField</code></li>
<li>模板引入 PageDown 宏，以实现即时预览</li>
<li>为 Post 模型增加字段，并添加 markdown 渲染方法，该方法为类方法，需要<code>@staticmethod</code>修饰</li>
<li>在模型外部监听数据库事件，仅当 markdown 文本出现变动时调用渲染方法。</li>
<li>修改模板以显示服务端返回的 html 文本</li>
</ul>
<p>然而预览器过于简陋，也很难修改。在github仓库上发现该插件也是本教程作者写的，已经很久没有维护。顿时对本书作者有些不满。</p>
<h2 id="0x06-模块化应用功能解耦">0x06 模块化应用：功能解耦</h2>
<p>保持 app 作为全局变量的模式，可能会给后续引入新功能和单元测试带来麻烦。<br>
要适应大型项目需求，需要把网站功能拆分成独立的模块。</p>
<h3 id="blueprint化">Blueprint化</h3>
<p>要实现解耦，一种功能的相关代码可以借助Blueprint归类到一个包里。其文件结构大致如下：</p>
<pre><code class="language-angular2html">app/ 
    some_fuction/                       &lt;-- blueprint package
        __init__.py                     &lt;-- blueprint creation
        ... other code ...
    templates/
        some_fuction/                   &lt;--  templates
    __init__.py                         &lt;-- blueprint registration
</code></pre>
<p>创建blueprint与创建应用非常相似。</p>
<pre><code class="language-python">from flask import Blueprint
bp = Blueprint('func', __name__)
from app.func import Func
</code></pre>
<p>而消灭了<code>app</code>，蓝图内部的引用统一变成了蓝图名。而外部诸如<code>url_for</code>的参数则需要加上<code>包名.</code>做前缀。</p>
<h3 id="应用工厂模式">应用工厂模式</h3>
<p>工厂函数是一个外部函数，在这个函数内部执行插件注册和配置工作，并通过他返回应用实例。</p>
<pre><code class="language-python"># app/__init__.py
db = SQLAlchemy()
# ...
def create_app(config_class=Config):
    app = Flask(__name__)
    app.config.from_object(config_class)
    db.init_app(app)
    # ...
</code></pre>
<p>返回后，flask提供的上下文对象<code>current_app</code>将指向应用实例。详见官方文档：<a href="http://docs.jinkan.org/docs/flask/appcontext.html">应用上下文</a></p>
<h4 id="多线程">多线程</h4>
<p><code>current_app</code>是线程绑定的，若要在诸如邮件服务的位于其他线程的功能调用他，则会发现没有赋值。<br>
需要使用<code>current_app._get_current_object()</code>表达式。</p>
<h4 id="python概念辨析包库插件">Python概念辨析：包，库，插件</h4>
<blockquote>
<p>包 (package) 是指一种代码结构，只要有文件夹和 <code>__init__.py</code> 都是包。<br>
库 (library) 和插件 (plugin) 都是从外部引入的包，区别在于，插件要集成进应用，所以需要注册等步骤；而库更独立，可以随时随地调用</p>
</blockquote>
<h2 id="0x07-开发帮手">0x07 开发帮手</h2>
<p>本节讲解一些杂项。</p>
<h4 id="调试">调试</h4>
<ul>
<li><code>flask shell</code>命令：为避免每次调试都要重新import app，使用上下文调用解释器，用<code>@app.shell_context_processor</code>装饰上下文函数</li>
</ul>
<h4 id="单元测试">单元测试</h4>
<p>unittest 库，详见<a href="">下一篇</a>。</p>
<h4 id="记录日志到文件">记录日志到文件</h4>
<p>logger 库</p>
<pre><code class="language-python">    if not app.debug:
        if not os.path.exists('logs'):
            os.mkdir('logs')
        file_handler = RotatingFileHandler('logs/microblog.log', maxBytes=10240,
                                           backupCount=10)
        file_handler.setFormatter(logging.Formatter(
            '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'))
        file_handler.setLevel(logging.INFO)
        app.logger.addHandler(file_handler)

        app.logger.setLevel(logging.INFO)
        app.logger.info('Microblog startup')
</code></pre>
<h4 id="requirementtxt">requirement.txt</h4>
<p>装的库太多怎么办？只需要两条命令：</p>
<pre><code class="language-shell">pip freeze &gt; requirements.txt
pip install -r requirements.txt
</code></pre>
<h2 id="0x08-网站上线">0x08 网站上线</h2>
<p>最后简单列出几种网站部署的方法，详情参考本教程或自行搜索。</p>
<h4 id="native模式">native模式</h4>
<ul>
<li>买主机
<ul>
<li>连主机：ssh</li>
</ul>
</li>
<li>买域名
<ul>
<li>配域名</li>
</ul>
</li>
<li>配环境
<ul>
<li>数据库</li>
<li>服务器</li>
<li>其他依赖</li>
</ul>
</li>
<li>持续运维</li>
</ul>
<h4 id="容器化技术docker">容器化技术：docker</h4>
<ul>
<li>写dockerfile</li>
<li>docker-compose up --build -d</li>
</ul>
<h4 id="云技术paas">云技术：PaaS</h4>
<ul>
<li>注册云平台账户</li>
<li>写Procfile</li>
<li>git push</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CISCN2021华东百赛区分区选拔赛AWD复盘]]></title>
        <id>https://lonelyuan.github.io/post/awd-da-pian/</id>
        <link href="https://lonelyuan.github.io/post/awd-da-pian/">
        </link>
        <updated>2021-06-16T08:54:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="">🛁</h2>
<p>这是👴第一次打高达80支队伍的大型AWD，👴此行的目标就是称霸酒店的游泳池。后来发现游泳池要钱，👴只能遗憾败北。（后来发现情报出了问题，根本不要钱，血亏）总的来说，酒店浴缸很带，主办方态度很好，赛场很清真，参赛体验很爽，赚了。</p>
<figure data-type="image" tabindex="1"><img src="https://lonelyuan.github.io/post-images/1624254620015.gif" alt="" loading="lazy"></figure>
<blockquote>
<p>“终端越炫，嗨客越带；嗨客越带，帽子越带”</p>
</blockquote>
<!-- 
在CISCN2021华东百赛区分区赛中，友队StudentUnion战队成功成为了CISCN2021华东百赛区分区赛的👴，喜提第三，逼平贵校历史最好成绩，并荣登学院公众号；👴率领的队伍则逼平👴们在CISCN2021线上初赛中的排名，我们都有美好的未来。
-->
<h2 id="awd复盘">🐐AWD复盘</h2>
<p>首先根据参赛手册，进行一个规则的复制：</p>
<pre><code class="language-plain">1、 采用线下赛的方式，参赛团队通过有线连接到局域网，并进行网络连通性的测试。请自备连接网络所需要的设备如usb转RJ45转换器等工具。
2、 攻防赛部署若干道赛题，初始分值为10500分。
3、 使用xctf用户通过ssh连接GameBox，GameBox的ip地址和登录密码通过赛事页面下载获取。
4、 比赛10分钟/回合，每个回合会更新GameBox上的flag。
5、 每个回合内，一个战队的一个服务被渗透攻击成功（被获取到flag并提交），则扣除10分，攻击成功的战队平分这些分数。
6、 每个回合内，服务宕机或无法通过check则会被扣除10分，服务正常的战队平分这些分数。
7、 参赛战队在修复漏洞时，请保持服务的正常功能和打印字符、界面样式，否则将无法通过系统check。
8、 每个回合内，服务异常和被拿flag可以同时发生，即战队在一个回合内单个服务可能会被扣除两者叠加的分数，最多扣除20分。
。。。
7、 请参赛战队在比赛开始时对所有服务进行备份，主办方仅提供2次重置机会，2次机会使用后不予重置。申请重置时请提供战队名称。
8、 禁止使用通用防御方法如waf等工具，违规者第一次被发现扣除当前分值的10%，第二次被发现扣除当前分值的50%，第三次被发现取消参赛资格并向其学校发文进行通报批评。
</code></pre>
<ul>
<li>比赛全程收手机，断外网，不能用waf，不准用不死马，大家都很清真，找回了ctf最初的快乐。</li>
</ul>
<p>然后按照AWD开局的任务清单，进行一个盘的复：</p>
<h3 id="准备阶段">准备阶段</h3>
<ul>
<li>ssh连接：
<ul>
<li>主办方提供了ssh密钥，和靶机ip
<ul>
<li>于是省略<code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@xx.xx.xx.xx</code>环节。</li>
</ul>
</li>
<li>但是万能的Windows Terminal连不上去（依然不知道为啥），👴只能用图形化ssh客户端添加私钥连接。</li>
</ul>
</li>
<li>IP扫描：
<ul>
<li>共有7道题，3道web，4道pwn，每道题目一个独立靶机，有独立的ip地址。不同靶机d段不同，不同队伍c段不同，按初赛排名分配。平台上告知了全部的ip列表。
<ul>
<li>于是省略<code>nmap -sn xx.xx.xx.0/24</code>环节。</li>
</ul>
</li>
<li>选手机和靶机池在一个局域网内。不同队伍c段不同，一个队伍内的不同电脑d段不同。</li>
</ul>
</li>
<li>流量监控：
<ul>
<li>主办方贴心的提供了被打流量(但是只有下行流量)，直接在~/package目录下给出.pcap文件。
<ul>
<li>于是省略<code>tcpdump tcp -i eth0 -t -s 0 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap</code>环节。</li>
<li>(不过用户名叫xctf，权限卡的很死。不给流量的话估计也只能在站里上流量监控脚本)</li>
</ul>
</li>
<li>更新速度很快，被打之后几乎可以立刻找到流量。于是手速很重要。</li>
</ul>
</li>
</ul>
<h3 id="开局阶段">开局阶段</h3>
<ul>
<li>备份源码：<code>tar -zcvf w.tar.gz /var/www/html</code>
<ul>
<li>结果<code>&gt; Permission Denied</code>，遂跳过</li>
</ul>
</li>
<li>扫马删马：D盾
<ul>
<li>👴直接在图形化shell里下载代码，然后崩屎了几次，手速慢了。</li>
<li>每个web题都有一个不明小文件，显然是小马，删除之。</li>
</ul>
</li>
<li>备份数据库：<code>mysqldump -uctf -p --databases [dbname] &gt; /tmp/db.sql</code>
<ul>
<li>结果<code>&gt; Permission Denied</code>，遂跳过</li>
</ul>
</li>
<li>改数据库密码：<code>mysql&gt;SET PASSWORD FOR ctf@localhost=PASSWORD('newpass');</code>
<ul>
<li>结果<code>&gt; Permission Denied</code>，(╯▔皿▔)╯玩nm<br>
<img src="https://lonelyuan.github.io/post-images/1624253899126.gif" alt="" loading="lazy"></li>
</ul>
</li>
<li>然后开始源码审计(❌)</li>
<li>然后等待被打之后翻流量(✔️)</li>
</ul>
<h3 id="攻防阶段">攻防阶段</h3>
<p>👴只看得懂web题目。三道web题全是cms，是经典lamp环境。可是👴看不懂cms，👴是five。</p>
<h4 id="web1safecms">web1：safecms</h4>
<ul>
<li>比赛一开始，啪的一下很快啊，全场被打，翻流量抓到payload，是一个模板文件的任意读漏洞。直接批量拿flag。</li>
<li>定位到路由，注释之，不好使，还是被打；删除这个.class.php，不好使；👴怀疑是运行时缓存不更新，直接<code>service restart apache2</code>
<ul>
<li>结果<code>&gt;Permission Denied</code>，👴佛了</li>
</ul>
</li>
<li>就这样被打了好一会，才发现直接修改index.php，能直接生效，血亏。</li>
</ul>
<h4 id="web2eyou">web2：eyou</h4>
<ul>
<li>这道题被打的很少，被宕机的很多。抓流量，发现很多混淆流量。（日志写shell？）</li>
<li>👴跟着流量尝试用过滤的方法修复，但是还是被宕。</li>
<li>若干轮后，👴没办法，只好申请重置，并在下一轮被宕。</li>
<li>若干轮后，👴没办法，只好申请重置，并在这一轮被宕。</li>
<li>若干轮后，👴没办法，只好白给，并在某一轮恢复正常并坚持到最后。我？？？
<ul>
<li>该不会是某队或者裁判看我们太可怜帮我们重置了吧，世界上还有这么温柔的人，我真的哭死</li>
</ul>
</li>
<li>这道题无了。（赛后才知道，有队伍找到sqli并登录后台，在后台关闭了站点并羊了管理员账号。修nm。</li>
</ul>
<h4 id="web3lol">web3：lol</h4>
<ul>
<li>这道题是最后三小时放的，👴这时候已经自闭了几个小时。于是👴痛定思痛，开局直接把admin.php羊了，然后奇迹般的守到了最后。坏了，好起来了。</li>
<li>全场被打，翻流量找到payload，某路径下有白给shell，直接删马并反打。</li>
<li>某队使用了在网页输出中塞随机字符串的防御方法，但是没破坏flag，且填充的字符是固定的，被我肉眼识破，我直接进行一个<code>if ip == xx: flag = flag[12:]</code>。虽然没什么卵用，但是很快乐。</li>
</ul>
<h4 id="pwn">pwn：</h4>
<p>一看到4个pwn👴直接傻掉。👴觉得👴不会做，因此也没去看，但听大佬说，直接抓流量进行一个转发就能拿分，👴下次一定准备好pwntools。</p>
<h2 id="自动化攻防框架">🔒自动化攻防框架</h2>
<p>AWD中，手交flag实在是很浪费时间的行为。虽然有时候自动化不太好写只能手交，像这次十分钟一轮，有72支队伍，就算你手速惊奇，也没有时间审计源码了。因此打AWD重点就在一个自动化。网上能找到各种框架，但是用的时候总是不顺手，遇到bug也不会修。只有自己写的才最好用。</p>
<p>先说说用处最大的工具，就是批量攻击框架/自动化攻击脚本。这个框架主要有以下要素：</p>
<ul>
<li>输入：
<ul>
<li>待攻击ip列表：通常写在ip.txt里</li>
<li>攻击函数：即封装好的payload请求</li>
<li>交flag函数：根据平台接口封装</li>
</ul>
</li>
<li>输出：
<ul>
<li>批量攻击，输出攻击结果</li>
<li>攻击成功则提交</li>
<li>反馈得分结果</li>
</ul>
</li>
</ul>
<p>框架的核心无非以下逻辑：</p>
<pre><code class="language-python">while True:
    for j in challenge_list: # 攻击函数索引
        for i in ip_list: # 首先生成ip列表
            flag = get_flag(i,j) # 根据j找到相应攻击函数
            if flag!='Attacked failed':
                submit_flag(flag)
    print_result(j)
    time.sleep(round)
</code></pre>
<p>比赛时，找到漏洞或者抓到流量，立刻写好相应的攻击函数，重启脚本即可。</p>
<p>为了提高稳定性和易用性，这套框架可以写的很复杂。比如：</p>
<ul>
<li>加入多线程，让框架非阻塞的持续运行</li>
<li>加入面向对象，写成类库</li>
<li>自带一些trick，比如流量混淆器等。</li>
<li>当然，还可以写一个网站来可视化管理</li>
</ul>
<p>这里就涉及框架编程了，能深挖的地方还有很多。</p>
<p>除了批量攻击脚本，用到的脚本还有：</p>
<ul>
<li>权限维持/批量shell脚本：用于管理多个shell
<ul>
<li>但是不死马被禁用，因此本次比赛中shell出现的不是很多。</li>
<li>（👴还准备了拿到白给shell之后持久化的脚本，结果一个shell都没拿到，准备个🔨。</li>
</ul>
</li>
<li>文件监控脚本：用于监控flag等重要文件被读取和修改的准确时间，可以帮助确定payload
<ul>
<li>再牛逼一点还可以提供系统备份和回复功能。</li>
</ul>
</li>
</ul>
<p>上述都是系统脚本，大多在本机用python写的。下面说几种网页脚本，即直接用require/include包含的php脚本</p>
<ul>
<li>流量监控脚本：区别于系统级流量监控，用于监控敏感流量以抓取payload</li>
<li>通防脚本：也就是waf，可以进行很充分的过滤
<ul>
<li>本次比赛中被禁用，因为确实破坏游戏体验</li>
</ul>
</li>
</ul>
<p>这些脚本，用好了才是趁手的兵器。这次比赛中👴的手速远不够快，延误了很多战机。</p>
<h2 id="快进到考试周破防">🌊快进到《考试周破防》</h2>
<p>回顾整场比赛，相比正经的漏洞挖掘，随机应变的能力对分数也有很大影响。总结几个因素：</p>
<ul>
<li>
<p>awd的得分是随时间积累的，因此要掌控全局，时刻盯紧每道题有无薄弱环节和突破口。本次比赛题目数量多达7道，👴队有大佬没来，还带了一个萌新，约等于二打四，出现了看不过来题的情况。</p>
</li>
<li>
<p>还有就是手速，由于流量很及时，payload一被抓到，甚至可以在一轮check之内丢进批量攻击脚本，直接和首先挖掘到漏洞的队伍平分分数。这要求自动化脚本的熟练运用，尽量避免手交flag。</p>
</li>
<li>
<p>最后还有一点策略问题。分析三种题目状态，列个表定性分析一波最优解：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">能反打</th>
<th style="text-align:center">不能反打</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">场上大多数Attacked</td>
<td style="text-align:center">先反打再修洞</td>
<td style="text-align:center">不能修洞则down自己</td>
</tr>
<tr>
<td style="text-align:center">场上大多数CheckDown</td>
<td style="text-align:center">打他喵的</td>
<td style="text-align:center">尽量别down</td>
</tr>
</tbody>
</table>
<ul>
<li>出现漏洞大部分人会被打，这时如果你不能立刻修补而能立刻反打，相当程度上是不亏的。如果你修不好也可以选择宕机，因为这样分摊了丢掉的分数。</li>
<li>尽量避免被打+被宕，扣双倍分数属实是血亏。如果决定宕机，先摸清check的时间和结算的时间，最好在新一轮结算后立即删站down自己。</li>
<li>当然，如果您能挖到洞，宁就是垂直上分的👴。</li>
</ul>
<p>从8点半到6点半，打10个小时的AWD，要全程保持敏感和机智，确实对身体素质有些要求。👴坐高铁到合肥坐了6小时，打比赛坐了10小时，好悬没给我痔疮坐出来。晚上回到青岛并进行最后一次夜店，快进到《考试周破防》。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于vivado的基于FPGA的一种基于MIPS的一种五级流水线CPU实现的注释]]></title>
        <id>https://lonelyuan.github.io/post/mips_pipeline_cpu/</id>
        <link href="https://lonelyuan.github.io/post/mips_pipeline_cpu/">
        </link>
        <updated>2021-06-09T09:14:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文所述为计算机组成原理课拓展实验的相关记录，基于“龙芯体系结构与CPU设计教学实验系统”<br>
项目官网： http://www.loongson.cn/business/general/teach/356.html；<br>
相关资料代码：#TODO:: github仓库<br>
PS：标题可简记为《基于基于的一种基于的一种实现》</p>
</blockquote>
<h2 id="吐槽时间">🤓吐槽时间</h2>
<p>快考试了，👴发觉👴计组学了个🔨，👴去年也学了个🔨，但是去年可以归因于晦气的晦气，今年只能说自己晦气。难道还要重蹈去年的晦气吗？👴本应该回去背课本，刷考研题，但是👴一看ppt就想起我们敬爱的《计算机组成原理》课的任课老师，丐哥老师反复强调的至理名言：“听不懂的举手（无停顿）都没举手，都听懂了，非常好。”本人十分钦佩丐哥老师对幽默感的独特理解。<br></p>
<p><em>（但是特此声明：本人不了解、不认同其关于&quot;5G是个几把&quot;，&quot;高晓松很nb这个人&quot;，&quot;钱=浪漫&quot;等议题的看法）</em><br></p>
<p>而且👴这人很怪，课本上的重点，不好玩；选做的实验，好玩！哎就是玩，怪不得卷不过别人，你也配卷？滚去考研吧。<br></p>
<p>众所周知，计算机学生的本科生涯，如果能做到在自己设计的CPU上运行自己写的操作系统并用自己写的编译器跑代码，那就非常成功了。👴差不多，👴能在自己搜的代码上写自己的注释并用自己的电脑截图，都是三个&quot;自己&quot;。那么今天给大家爆个啥捏，流水线奥。<br></p>
<h2 id="用计算机造计算机">🔧 “用”计算机→“造”计算机</h2>
<p>上回书说到（#TODO:: CSAPP大篇），汇编器(as)让我们得到了机器能看懂的比特流，最后一步只需要连接器(ld)将其和其他调用一起载入内存。这回答了程序如何在CPU这个平台上运行的问题，然而一个更基本的问题是，这个现有的平台是如何实现的？一个粗略的认识是，我们知道这些足以实现CPU的复杂的逻辑，其最小单元总对应到简单的诸如逻辑门上面，但是落实到真正的物理实现之上，如何使效率最高？功耗最小？这些问题所跨越的复杂度的量级依然是一片巨大的迷雾。照亮这片迷雾的知识，大概隶属于IC学科。<br></p>
<p>However，作为CS专业而不是IC专业，我们的目标仅在于理解所谓“组成原理”。在IC产业的复杂度规模数轴上，向下是专有芯片（又称嵌入式？），功能专用，规模较小；向上是通用芯片，即手机电脑等的核心，其难度不言而喻。位于中间的FPGA则既兼顾了自由度也考虑了速度，因此，这玩意能满足CS本科教学的需要（主要是便宜耐操）。<br></p>
<h2 id="高贵的ic工程师都用啥轮子">🔮高贵的IC工程师都用啥轮子</h2>
<p>Vivado是一个FPGA集成设计平台（也算一个EDA？），他主界面左侧的工作流窗口很好的概括了利用FPGA开发的基本流程。即</p>
<ul>
<li>编写设计源码(Source)：使用Verilog语言编写逻辑或引入IP
<ul>
<li>设计仿真模拟(Simulation)：通过观察仿真波形图和编写testbench来对设计进行debug
<ul>
<li>综合(Systhesis)门级网表：从RTL级描述降维到门级网表
<ul>
<li>生成(Implementation)布局布线：根据管脚约束，将依然是虚拟的门级连线落实为实际的线路
<ul>
<li>进行硬件编程(program)：生成比特流并写入目标设备</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://lonelyuan.github.io/post-images/1623373911775.png" alt="" loading="lazy"></figure>
<blockquote>
<p>名词解释：<br>
IC：集成电路<br>
FPGA：现场可编程门阵列<br>
Verilog：一种硬件描述语言，语法涵盖了自顶向下五个抽象层面：系统级、算法级、RTL级、门级、开关级。<br>
RTL：寄存器传输级。一般使用最多的就是RTL级。<br>
IP：Intellectual Property内核模块，可以理解为将代码封装为函数。分为，软IP内核(soft IP core)，固IP内核(firm IP core)和硬IP内核(hard IP core)3个层次，相当于集成电路的毛坯、半成品和成品。<br>
SoC：片上系统，大概是芯片及其装载的第一层软件接口的集合，很宽泛的概念。<br>
EDA：电子设计自动化。</p>
</blockquote>
<p>由此，我们可以大致探清了这片迷雾，CPU的设计如何从高抽象层次的逻辑，梳理成最底层的逻辑门，再实现为小小的芯片。那么我们有了轮子，要造一个CPU，还要确定目标指令集。由于本项目由龙芯公司赞助，那必然要选MIPS了。</p>
<h2 id="mips指令集格式">📌MIPS指令集格式</h2>
<p>啥叫指令集呢，学过几种语言就不难理解。高级程序语言规定每个ascii码的组合所对应的含义，指令集规定0和1的组合所对应的寄存器，ALU的各种信号。MIPS指令集从属于RISC系列，最基本的指令有31条。<br></p>
<p>//讲到这里本应该打个表展示31条指令，但是👴懒得打了。<br></p>
<p>Vivado中，.coe文件用于初始化IP核，本实验给出的.coe文件中存放了几条指令，不过是16进制数字，写个小脚本打印成可读的形式。</p>
<pre><code class="language-python"># mips_dump.py
with open(path,'r') as f:
    hex_list = f.read().split('\n')
    bin_list = list(map(lambda x:bin(int(x,16)),hex_list))
    # bin_code_list = [&quot;{:0&gt;32}&quot;.format(i[2:],'b') for i in bin_list]
    bin_code_list = [i[2:].zfill(32) for i in bin_list]

IType_op_dict = {
    '001000':'addi',
    '001001':'addiu',
    '001100':'ori',
    '001101':'xori',
    '001111':'lui',
    '100011':'lw',
    '101011':'sw',
    '000100':'beq',
    '000101':'bne',
    '001010':'slti',
    '001011':'sltiu'
}

RType_func_dict = {
    '100000':'add',
    '100001':'addu',
    '100010':'sub',
    '100011':'subu',
    '100100':'and',
    '100101':'or',
    '100110':'xor',
    '100111':'nor',
    '101010':'slt',
    '101011':'sltu',
    '000000':'sll',
    '000010':'srl',
    '000011':'sra',
    '000100':'sllv',
    '000110':'srlv',
    '000111':'srav',
    '001000':'jr',
}

def f_hex(ori, width): # bin-&gt;hex
    return &quot;0x&quot;+hex(int(ori,2))[2:].zfill(width)
def f_reg(ori): # print register num
    return &quot;$&quot;+str(int(ori,2)).zfill(2)
def code_dump(type:str,inst:str,params:list):
    if type == 'R':
        s = inst.ljust(6) + &quot;, &quot;.join([f_reg(params[0]),f_reg(params[1]),f_reg(params[2]),f_hex(params[3],2)])
    elif type == 'I':
        s = inst.ljust(6) + &quot;, &quot;.join([f_reg(params[0]),f_reg(params[1]),f_hex(params[2],8)])
    else:
        s = inst.ljust(6) +'0x'+ hex(int(params[0],2))[2:].zfill(8)
    return s

assembly_list = []
for _ in bin_code_list:
    op = _[:6] # public field
    try:
        if op == '000000': # R-Type
            rs = _[6:11]
            rt = _[11:16]
            rd = _[16:21]
            shamt = _[21:26]
            func = _[26:]
            assembly_list.append(code_dump('R',RType_func_dict[func],[rs,rt,rd,shamt]))
        elif op in ['000010', '000011']:  # J-Type
            target = _[6:]
            assembly_list.append(code_dump('J','j',[target]))
        else: # I-Type
            rs = _[6:12]
            rt = _[12:18]
            imm = _[18:]
            assembly_list.append(code_dump('I',IType_op_dict[op],[rs, rt, imm]))
    except Exception as e:
        assembly_list.append(&quot;***** decode error! *****&quot;)

head = &quot;+---hexdump----|--------- assembly ---------+&quot;
print(head)
addr = 0
for i in range(len(bin_code_list)):
    print(&quot;|&quot;+ f_hex(bin(addr),2) +&quot; &quot;+ hex_list[i] +&quot; | &quot;+ assembly_list[i].ljust(26) + &quot; |&quot;)
    addr += 4
tail = &quot;+&quot;+&quot;-&quot;*43+&quot;+&quot;
print(tail)
</code></pre>
<p>打印出来👴傻了，怎么还有不在31条范围里的。</p>
<pre><code>+---hexdump----|--------- assembly ---------+
|0x00 24010001 | addiu $00, $04, 0x00000001 |
|0x04 00011100 | sll   $00, $01, $02, 0x04  |
|0x08 00411821 | addu  $02, $01, $03, 0x00  |
|0x0c 00022082 | srl   $00, $02, $04, 0x02  |
|0x10 28990005 | slti  $09, $36, 0x00000005 |
|0x14 07210010 | ***** decode error! *****  |
|0x18 00642823 | subu  $03, $04, $05, 0x00  |
|0x1c AC050014 | sw    $00, $20, 0x00000014 |
|0x20 00A23027 | nor   $05, $02, $06, 0x00  |
|0x24 00C33825 | or    $06, $03, $07, 0x00  |
|0x28 00E64026 | xor   $07, $06, $08, 0x00  |
|0x2c AC08001C | sw    $00, $32, 0x0000001c |
|0x30 11030002 | beq   $16, $12, 0x00000002 |
|0x34 00C7482A | slt   $06, $07, $09, 0x00  |
|0x38 24010008 | addiu $00, $04, 0x00000008 |
|0x3c 8C2A0014 | lw    $02, $40, 0x00000014 |
|0x40 15450004 | bne   $20, $20, 0x00000004 |
|0x44 00415824 | and   $02, $01, $11, 0x00  |
|0x48 AC2B001C | sw    $02, $44, 0x0000001c |
|0x4c AC240010 | sw    $02, $16, 0x00000010 |
|0x50 0C000019 | j     0x00000019           |
|0x54 3C0C000C | lui   $00, $48, 0x0000000c |
|0x58 004CD007 | srav  $02, $12, $26, 0x00  |
|0x5c 003AD804 | sllv  $01, $26, $27, 0x00  |
|0x60 0360F809 | ***** decode error! *****  |
|0x64 A07A0005 | ***** decode error! *****  |
|0x68 0063682B | sltu  $03, $03, $13, 0x00  |
|0x6c 1DA00003 | ***** decode error! *****  |
|0x70 00867004 | sllv  $04, $06, $14, 0x00  |
|0x74 000E7883 | sra   $00, $14, $15, 0x02  |
|0x78 002F8006 | srlv  $01, $15, $16, 0x00  |
|0x7c 1A000008 | ***** decode error! *****  |
|0x80 002F8007 | srav  $01, $15, $16, 0x00  |
|0x84 240B008C | addiu $00, $44, 0x0000008c |
|0x88 06000006 | ***** decode error! *****  |
|0x8c 8D5C0003 | lw    $21, $48, 0x00000003 |
|0x90 179D0007 | bne   $57, $52, 0x00000007 |
|0x94 A0AF0008 | ***** decode error! *****  |
|0x98 80B20008 | ***** decode error! *****  |
|0x9c 90B30008 | ***** decode error! *****  |
|0xa0 2DF8FFFF | sltiu $31, $35, 0x00003fff |
|0xa4 0185E825 | or    $12, $05, $29, 0x00  |
|0xa8 01600008 | jr    $11, $00, $00, 0x00  |
|0xac 31F4FFFF | ori   $31, $19, 0x00003fff |
|0xb0 35F5FFFF | xori  $31, $23, 0x00003fff |
|0xb4 39F6FFFF | ***** decode error! *****  |
|0xb8 08000000 | j     0x00000000           |
+-------------------------------------------+
</code></pre>
<p>总之，代码都给你了，下面给出一个vivado实验的完整流程，不全面，但是都是踩坑经验。</p>
<h2 id="vivado使用">🆒Vivado使用</h2>
<p>本流程环境：Vivado 2020.2<br><br>
开发板型号：LS-CPU-EXB-1<br></p>
<h3 id="创建项目">创建项目</h3>
<p>下一步，下一步，下一步，，，确认。<br>
这一步只需要注意选器件，一定要选对。否则有可能在Implementation遇到“端口电平不匹配”“端口数量不足”等硬件问题。当然，有可能型号相近的性能规格也差不多，这属于玄学问题了。实验书上选择的的型号应该是“xc7a200tfbg676-2”，但是👴用的是“xc7a200tfbv676-2”也能成功写入比特流。</p>
<h3 id="编写代码并仿真">编写代码并仿真</h3>
<p>本实验的代码大多来自“2016-04-14”，那就是龙芯公司给的源代码。在该系列代码中有一处bug，位于“单周期CPU实验”的single_cycle_cpu.v中。214行，<code>resetn</code>应该为<code>{4{resetn}}</code>，写使能位宽应为为4。<br>
<img src="https://lonelyuan.github.io/post-images/1623379687932.png" alt="" loading="lazy"></p>
<p>下面讲解一下项目结构，所有实验都是类似的：<br>
<img src="https://lonelyuan.github.io/post-images/1623374928604.png" alt="" loading="lazy"><br>
三个顶层文件夹分别对应Add Source里的三类源文件：添加设计，添加仿真，添加约束。如果不需要上板，只完成仿真，那么只需要添加设计（几个.v），添加仿真（testbench.v/tb.v）就足够了，xxx_display.v也是上板需要的故而可以忽略。（实际上，图中我用箭头标记的都用不到）。</p>
<p>编写tb，无非是给tb里声明为input的信号赋值，还可以使用<code>#xx</code>，让tb等待一段时间。</p>
<p>点击Run Simulation，等一会就能看到波形图。波形图有三种颜色：</p>
<ul>
<li>绿色代表信号正常正常；</li>
<li>红色的X代表信号不确定；</li>
<li>蓝色的Z代表信号休眠。</li>
</ul>
<p>一般遇到红X，都是未初始化问题。蓝Z大概是没有模块调用这些信号。Vivado波形图的操作极其难用，这里介绍一个相对好用的操作：左键从左向右水平划，会直接缩放到鼠标滑过的这一段。右键选择进制等操作略。</p>
<figure data-type="image" tabindex="2"><img src="https://lonelyuan.github.io/post-images/1623378896380.png" alt="" loading="lazy"></figure>
<p>仿真需要注意的问题：</p>
<ul>
<li>如果文件没问题，模块调用层次会被自动解析从而呈现成一棵树，而不是好几个顶层文件。</li>
<li>注意set as top，应该设为根部模块（调用其他模块的）和tb
<ul>
<li>//如果设错了可能在Implementation会出现“端口未赋初值”的报错。</li>
</ul>
</li>
<li>中文乱码是经典字符集问题，有可能在换行处导致语法错误。建议统一换成utf-8。
<ul>
<li>简单解决方法：从vscode里复制。</li>
</ul>
</li>
</ul>
<h3 id="引入ip核">引入IP核</h3>
<p>对于流水线CPU，data_ram和inst_rom需要同步写，自己实现比较复杂，故直接实例化封装好的内存块IP。如何引入？首先说明几种文件格式：</p>
<ul>
<li>.dcp 原意为checkpoints文件，是一种加密压缩文件。用于封装模块方便调用，但对版本要求极其敏感。</li>
<li>.xci/.xcix IP核配置文件，本质是一个xml。是Vivado在新版本提倡使用xci而不是dcp。</li>
<li>.xdc 管脚约束文件。在Implementation用到，此处按下不表。</li>
</ul>
<p>这几种文件格式都是可以直接Add Source添加进来的。实验老师同时提供dcp和xci文件，添加dcp崩屎了，原因估计如上。添加xci之后，提示我将IP更新为core cointainer的形式</p>
<figure data-type="image" tabindex="3"><img src="https://lonelyuan.github.io/post-images/1623377228417.png" alt="" loading="lazy"></figure>
<p>更新就完了。然后需要等一会，IP还要执行一步synth，这段时间里IP属于锁住的状态，不能修改配置。</p>
<figure data-type="image" tabindex="4"><img src="https://lonelyuan.github.io/post-images/1623377562565.png" alt="" loading="lazy"></figure>
<p>注意更换器件后，IP核都会锁住。这表示IP的配置和当前环境不匹配。对所有IP锁住的问题，只需要点击菜单栏Reports→Reports IP  Status，然后点upgrade即可解除锁定。</p>
<h3 id="我直接上板">我直接上板</h3>
<p>直接点生成比特流，会一步步的按工作流向下运行，等待几分钟就能愉快的收获你的报错了！</p>
<figure data-type="image" tabindex="5"><img src="https://lonelyuan.github.io/post-images/1623379096063.jpg" alt="" loading="lazy"></figure>
<p>在把上文提到的坑都踩过一遍之后，终于没有critical warning，泪目。</p>
<p>但是此时实验课已经结束了，👴偷溜到没人的实验室，并留下以下珍贵画面</p>
<figure data-type="image" tabindex="6"><img src="https://lonelyuan.github.io/post-images/1623379266894.jpg" alt="" loading="lazy"></figure>
<p>然后👴发现data_ram写入失败。但是👴没时间搞了，👴还是滚去复习课本吧。</p>
<h2 id="多周期流水线cpu原理">🗿多周期流水线CPU原理</h2>
<p>最后，继续复习计组。<br></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我和拖延症的战争]]></title>
        <id>https://lonelyuan.github.io/post/ProcrastinationWar/</id>
        <link href="https://lonelyuan.github.io/post/ProcrastinationWar/">
        </link>
        <updated>2021-04-15T15:01:29.000Z</updated>
        <content type="html"><![CDATA[<p>//这是一篇永远不会完结的文章。<br>
//先准备目录</p>
<p>0x01 | 拖延症的生理基础</p>
<ul>
<li>习惯的重要性</li>
<li>习惯行为学</li>
<li>生理基础：多巴胺</li>
<li>演化论证据</li>
</ul>
<p>0x02 | 对拖延症的方法论综述</p>
<ul>
<li>可行的计划</li>
<li>积极的环境</li>
<li>正向的反馈</li>
<li>能战胜拖延症的，是爱</li>
</ul>
<p>0x03 | 高级作战录像</p>
<ul>
<li>拖延循环</li>
<li>拖延症不是你失败的唯一原因</li>
<li>此身不灭，壮志不渝</li>
</ul>
<p>0x04 | 西西弗斯计划</p>
<ul>
<li>模型比方法更重要</li>
<li>对话机制</li>
<li>提示机制</li>
<li>这场战争，我们还没输，但也只能说还没输</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSAPP - Bomblab]]></title>
        <id>https://lonelyuan.github.io/post/CSAPP-Bomblab/</id>
        <link href="https://lonelyuan.github.io/post/CSAPP-Bomblab/">
        </link>
        <updated>2020-02-27T14:43:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="csappbomblab">CSAPP：Bomblab</h1>
<p>逆向的传统艺能拆炸弹，👴的青春回来了。</p>
<p>文件结构：</p>
<pre><code>bomb
   ├── README
   ├── bomb
   └── bomb.c
</code></pre>
<p>只有一个程序，给的源码基本没用，我们要用逆向工程的方法理解程序，找到正确的字符串。</p>
<p>讲反汇编器的结果导出：<code>objdump -d bomb &gt; bomb.txt</code></p>
<p>可以看到有6关，每一关接受一个字符串，若跳转到explode_bomb函数，则答案错误。</p>
<h3 id="第一关字符串比较">第一关：字符串比较</h3>
<pre><code class="language-assembly">0000000000400ee0 &lt;phase_1&gt;:
  400ee0:	48 83 ec 08          	sub    $0x8,%rsp
  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi
  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;
</code></pre>
<p>逻辑是直接比较字符串是否相等，不过<code>$0x402400</code>不是程序内地址，说明答案被藏在了我们看不到的内存位置。</p>
<p>于是上GDB，在&lt;phase_1&gt;下断点，<code>stepi</code>单步执行到callq之前，查看寄存器:<code>x\s $esi</code>，得到答案。（每台电脑的答案都不一样）</p>
<h3 id="第二关循环">第二关：循环</h3>
<pre><code class="language-assembly">0000000000400efc &lt;phase_2&gt;:
  400efc:	55                   	push   %rbp //压栈
  400efd:	53                   	push   %rbx
  400efe:	48 83 ec 28          	sub    $0x28,%rsp //开辟栈帧
  400f02:	48 89 e6             	mov    %rsp,%rsi//栈顶地址→rsi参数二
  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;
</code></pre>
<p>如函数名所示，读6个数字，为什么是6呢，大概是因为存放参数的寄存器总共有6个吧。（然而并不）</p>
<p>可以看到调用前开辟了0x28的栈上空间，足够存放6个整数。栈顶地址被存入%rsi，以此传递该地址。</p>
<pre><code class="language-assembly">000000000040145c &lt;read_six_numbers&gt;:
//%rsi:父进程&lt;phase_2&gt;的栈顶地址
  40145c:	48 83 ec 18          	sub    $0x18,%rsp //栈帧长24
  401460:	48 89 f2             	mov    %rsi,%rdx  //rsi→参数三：num1
  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx //rsi+4→参数四：num2
  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax  //rsi+20→rax
  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp) //rax→栈顶+8：num6
  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax //rsi+16→rax
  401474:	48 89 04 24          	mov    %rax,(%rsp) //rax→栈顶：num5
  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9 //rsi+12→参数六：num4
  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8 //rsi+8→参数五：num3
  401480:	be c3 25 40 00       	mov  $0x4025c3,%esi//0x4025c3:&quot;%d %d %d %d %d %d&quot;
  401485:	b8 00 00 00 00       	mov    $0x0,%eax //返回值赋0
  40148a:	e8 61 f7 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt; //sscanf()
  40148f:	83 f8 05             	cmp    $0x5,%eax //返回值和5比较，即输入6个值才能通过
  401492:	7f 05                	jg     401499 &lt;read_six_numbers+0x3d&gt;
  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;
  401499:	48 83 c4 18          	add    $0x18,%rsp //出栈
  40149d:	c3                   	retq   
</code></pre>
<p>看&lt;read_six_numbers&gt;，%rsi中的地址以4为步长被分别储存。猜测sscanf函数的返回值中，第一个表示输入参数的个数；程序要求6个输入，加上rsi被占用，于是多的两个存入栈中。且sscanf函数的返回值按参数寄存器（多的地址在栈上）存放的地址传输，即输入值被按顺序存入phase_2的栈帧中。</p>
<pre><code class="language-assembly">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)  //栈顶位置取双字和1比较
  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;
  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;
  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax //循环头：num1→eax
  400f1a:	01 c0                	add    %eax,%eax   // eax*2
  400f1c:	39 03                	cmp    %eax,(%rbx) //和num2比较
  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt; //相等才通过
  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;
  400f25:	48 83 c3 04          	add    $0x4,%rbx //rbx增4
  400f29:	48 39 eb             	cmp    %rbp,%rbx //rbx和rsp+24比较，相等则跳出
  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt; //循环尾，循环共6轮
  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt; 
  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx //num2地址→rbx
  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp//rbx地址→rbp
  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt; //开始循环
</code></pre>
<p>跳出&lt;read_six_numbers&gt;后，首先检查栈顶地址指向的值是否为1，即第一个数字是1。</p>
<p>之后进入循环，循环体每次都会把当前数字*2和下一个数字比较，即每个数字都是前一个的二倍；%rbx作计数变量，共循环6次。答案呼之欲出。</p>
<h3 id="第三关分支">第三关：分支</h3>
<pre><code class="language-assembly">0000000000400f43 &lt;phase_3&gt;:
  400f43:	48 83 ec 18          	sub    $0x18,%rsp 
  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx //rsp+12→rcx: mun2
  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx //rsp+8→rdx: mun1
  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi //0x4025cf:  &quot;%d %d&quot;
  400f56:	b8 00 00 00 00       	mov    $0x0,%eax
  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;
  400f60:	83 f8 01             	cmp    $0x1,%eax  //不少于一个输入
  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;
  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;
  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp) //
  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt; //超过7则爆炸
  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax //取num1
  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8) 
</code></pre>
<p>此处<code>*</code>相当于c中的取地址符<code>&amp;</code>，</p>
<pre><code class="language-assembly">400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax
400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;
······
</code></pre>
<p>这里有7段形式重复的代码，结合第一个数字不能大于7，猜测这里是switch型结构。</p>
<pre><code class="language-assembly">400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;
400fb2:	b8 00 00 00 00       	mov    $0x0,%eax
400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;
400fb9:	b8 37 01 00 00       	mov    $0x137,%eax 
400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax //比较num2和eax
400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;
400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;
400fc9:	48 83 c4 18          	add    $0x18,%rsp
400fcd:	c3                   	retq   
</code></pre>
<p>第二个数字是%eax的值，由第一个数决定。故答案有7个。</p>
<h3 id="第四关递归">第四关：递归</h3>
<pre><code class="language-assembly">000000000040100c &lt;phase_4&gt;:
......
  401029:	83 f8 02             	cmp    $0x2,%eax //只能有2参数
  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;
  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp) //0 &lt;= num1 &lt;= 14
  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;
  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;
  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx
  40103f:	be 00 00 00 00       	mov    $0x0,%esi
  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi //num1→edi
  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt; //
</code></pre>
<p>输入规则和上一关一样，第一个数需在0到14之间（cmpl只能用于无符号数？）</p>
<pre><code class="language-assembly">0000000000400fce &lt;func4&gt;:
//首次调用时：%eax:0x2 %ebx:0 %ecx:0 %edx:0xe %esi:0x0 %edi:num1
  400fce:	48 83 ec 08          	sub    $0x8,%rsp
  400fd2:	89 d0                	mov    %edx,%eax //eax:14
  400fd4:	29 f0                	sub    %esi,%eax //eax:14-0
  400fd6:	89 c1                	mov    %eax,%ecx //ecx:14
  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx //ecx:0 //逻辑右移31，即取符号位。
  400fdb:	01 c8                	add    %ecx,%eax //eax:14+0
  400fdd:	d1 f8                	sar    %eax //算术右移1位？eax:14/2=7
  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx //ecx:7+0
  400fe2:	39 f9                	cmp    %edi,%ecx //比较num1和7
  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt; //不大于→r17
  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx //edx:ecx-1=6
  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt; //递归→r3
  400fee:	01 c0                	add    %eax,%eax 
  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt; //跳出
  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax 
  400ff7:	39 f9                	cmp    %edi,%ecx //比较num1和7
  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt; //不小于
  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi //esi:ecx+1=8
  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt; //递归→r3
  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax //eax=2*eax+1
  401007:	48 83 c4 08          	add    $0x8,%rsp
  40100b:	c3                   	retq   
</code></pre>
<p>前面一通算术操作，后面设计了递归。</p>
<p>这里一步移位操作看起来像是取符号位，但是输入一定大于0，符号位是0，所以这个操作意义何在？</p>
<p>人肉IDA走起：</p>
<pre><code class="language-c">int fun4(int num1,int x,int y){
    int s,a;
    s=(x-y)/2+y;
    if(num1&gt;s)	return 2*fun4(num1,s-1,y);
    a=0;
    if(num1&lt;s)	return 2*fun4(num1,x,s+1)+1;
   	return a;
}
fun4(num1,14,0);
</code></pre>
<p>第一个数设为7可避免递归调用，但返回值不是0，不符合。</p>
<pre><code class="language-assembly">40104d:	85 c0                	test   %eax,%eax //eax=0
40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;//不等于0爆炸
401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp) //mun2和0比较？
401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;//不等于0爆炸
401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;
40105d:	48 83 c4 18          	add    $0x18,%rsp
401061:	c3                   	retq   
</code></pre>
<p>看到<func4>的返回值和num2皆需为0，则num2确定。</p>
<p>大不了爆破呗，索性试了1次就成了。emm</p>
<h3 id="第五关">第五关</h3>
<pre><code class="language-assembly">0000000000401062 &lt;phase_5&gt;:
  401062:	53                   	push   %rbx
  401063:	48 83 ec 20          	sub    $0x20,%rsp
  401067:	48 89 fb             	mov    %rdi,%rbx
  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax //???
  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  401078:	31 c0                	xor    %eax,%eax //eax:0
  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt;
  40107f:	83 f8 06             	cmp    $0x6,%eax //输入长度为6
  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;
  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt;
  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;
  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx //循环头。新指令
  40108f:	88 0c 24             	mov    %cl,(%rsp)
  401092:	48 8b 14 24          	mov    (%rsp),%rdx
  401096:	83 e2 0f             	and    $0xf,%edx
  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx //？？？
  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1) 
  4010a4:	48 83 c0 01          	add    $0x1,%rax //计数变量rax
  4010a8:	48 83 f8 06          	cmp    $0x6,%rax //循环6轮
  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt; //循环尾
  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)
  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi //？？
  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt;
  4010c2:	85 c0                	test   %eax,%eax
  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;
  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt;
  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1) //？？？
  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;//跳出
  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax
  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;
  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax //？？？
  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;
  4010e9:	e8 42 fa ff ff       	callq  400b30 &lt;__stack_chk_fail@plt&gt;
  4010ee:	48 83 c4 20          	add    $0x20,%rsp
  4010f2:	5b                   	pop    %rbx
  4010f3:	c3                   	retq   
</code></pre>
<h3 id="第六关">第六关</h3>
<h3 id="隐藏关">隐藏关</h3>
<p>隐藏关藏在每一关的后面，</p>
<h2 id="gdb使用">GDB使用：</h2>
<p>基础：</p>
<pre><code>q : quit
h : help
file prog//加载程序，也可作为gdb命令的参数
r : run
k : kill
</code></pre>
<p>断点：</p>
<pre><code>b : breakpoints break
	- func_name
	- *0x400522
    - &amp;var
   	- main.c:100//源代码断点，运行前即可
		- if con//条件断点
w : watch //观察对象变化时断点
d : delete 
	- b n
disable b n
</code></pre>
<p>执行：</p>
<pre><code>c : continue
f : finish
stepi n
nexti

set args ./a.txt //从文件读取输入
</code></pre>
<p>检查代码：</p>
<pre><code>disas //展示汇编
	- funcname
    - 0x400000
    - 
list
edit
</code></pre>
<p>检查数据：</p>
<pre><code>x : examine
p : print 
格式控制：/[n][f][u]
	- n:内存单元个数
	- f:显示格式：
		-  x(hex) 按十六进制格式显示变量。
		-  d(decimal) 按十进制格式显示变量。
        -  u(unsigned decimal) 按十进制格式显示无符号整型。
        -  o(octal) 按八进制格式显示变量。
        -  t(binary) 按二进制格式显示变量。
        -  a(address) 按十六进制格式显示变量。
        -  c(char) 按字符格式显示变量。
        -  f(float) 按浮点数格式显示变量
    - u:单元长度（按字节） 
i : info 
	- r : registers 
	- b [n]
	
	- $rsp
</code></pre>
<p>表达式：</p>
<pre><code class="language-assembly">
</code></pre>
<p>堆栈：</p>
<pre><code class="language-assembly">bt : backtrace//显示堆栈
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSAPP - datalab]]></title>
        <id>https://lonelyuan.github.io/post/CSAPP-datalab/</id>
        <link href="https://lonelyuan.github.io/post/CSAPP-datalab/">
        </link>
        <updated>2020-01-20T16:00:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="csappdatalab">CSAPP：datalab</h1>
<p>读，就硬读。光读没用，得做练习。这个系列记录思路不写答案。</p>
<p>拿到文件夹先读README。</p>
<p>第一个lab，关于位运算。通过受限制的c语言编程实现函数功能。</p>
<p>直接读<code>bits.c</code>，里面有全部信息。每次测试程序都要先make一下。</p>
<ul>
<li>
<h4 id="1只用按位与和非实现异或">1：只用按位与和非实现异或</h4>
</li>
</ul>
<pre><code>/* 
 * bitXor - x^y using only ~ and &amp; 
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &amp;
 *   Max ops: 14
 *   Rating: 1
 */
</code></pre>
<p><code>&amp;</code>=全为1</p>
<p><code>~&amp;</code>=不全为1</p>
<p>异或=不全为0且不全为1，按此逻辑组合即可。</p>
<p>你让我用括号了？？？</p>
<p>反思：浪费时间，与和或傻傻分不清楚</p>
<ul>
<li>
<h4 id="2位运算取补码的最小值">2：位运算取补码的最小值</h4>
</li>
</ul>
<p>英语时间：补码（two's complement）反码：（one's complement）。结合公式很好理解</p>
<pre><code>/* 
 * tmin - return minimum two's complement integer 
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 4
 *   Rating: 1
 */
</code></pre>
<p>补码公式：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mn>2</mn><msub><mi>T</mi><mi>w</mi></msub><mo>(</mo><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>)</mo><mo>=</mo><mo>−</mo><msub><mi>x</mi><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>w</mi><mo>−</mo><mn>2</mn></mrow></munderover><msub><mi>x</mi><mi>i</mi></msub><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">B2T_w(\vec{x})=-x_{w-1}+\sum^{w-2}_{i=0}x_i2^i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.20772em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>最高位是符号位，要求最小值，则最高位为负1，其他位为0。</p>
<p>由于题目限制，只能使用最大为0xff的数字和位运算符，又int长度为4*8=32，故对0x1左移31即得。</p>
<ul>
<li>
<h4 id="3判断一个数是否为补码的最大值">3：判断一个数是否为补码的最大值</h4>
</li>
</ul>
<pre><code>/*
 * isTmax - returns 1 if x is the maximum, two's complement number,
 *     and 0 otherwise //0=1111 1111=0000 0000
 *   Legal ops: ! ~ &amp; ^ | +
 *   Max ops: 10
 *   Rating: 1
 */
</code></pre>
<p>最大值：符号位0，其他位1，即max=011111...=0x7fffffff。</p>
<p><code>!0=1</code>，故应使每一位化为0，再取非即为1；其他任何数取非都为0。</p>
<p>注意到<code>max+1=~max</code>，补码max加一得到其反码。反码相加得11111111，取反即得0。</p>
<p>特例：<code>-1 = 0x1111 1111</code>也有这个性质，故须排除。</p>
<p>寻找另一性质：<code>!(max+1)=0</code>，而<code>!(-1+1)=1</code>，结合上一步结果即可。</p>
<p>反思：逻辑非！和按位非~</p>
<ul>
<li>
<h4 id="4判断所有奇数位为1">4：判断所有奇数位为1</h4>
</li>
</ul>
<pre><code>/* 
 * allOddBits - return 1 if all odd-numbered bits in word set to 1
 *   where bits are numbered from 0 (least significant) to 31 (most significant)
 *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 2
 */
</code></pre>
<p>要取奇数位，首先构造掩码：<code>0xaaaaaaaa</code>，用&amp;取出奇数位，再异或，取反即得。</p>
<p>错误示范：<code>m=0xaa;m+=m&lt;&lt;8;m+=m&lt;&lt;8;m+=m&lt;&lt;8;</code>算出来个啥？</p>
<ul>
<li>
<h4 id="5取相反数">5：取相反数</h4>
</li>
</ul>
<pre><code>/* 
 * negate - return -x 
 *   Example: negate(1) = -1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 5
 *   Rating: 2
 */
</code></pre>
<p>常识？？？反码加1</p>
<p>大佬题解：https://wdxtub.com/csapp/thick-csapp-lab-1/2016/04/16/</p>
<p>https://zhuanlan.zhihu.com/p/59534845题不一样？？？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深度学习入门——jetbot智能小车尝鲜（二）]]></title>
        <id>https://lonelyuan.github.io/post/jetbot-2/</id>
        <link href="https://lonelyuan.github.io/post/jetbot-2/">
        </link>
        <updated>2019-09-30T16:26:38.000Z</updated>
        <content type="html"><![CDATA[<p>那个男孩不想玩人工智能呢？在玄学修bug之后，我终于跑通了jetbot自带的深度学习demo。</p>
<p>怎样才能让ai程序发挥好的效果呢？众所周知，所谓人工智能，有多少人工就有多智能。</p>
<p>AI的发展离不开三个要素：<strong>算力</strong>，<strong>算法</strong>和<strong>算材</strong>。根据摩尔定律，算力的发展是不会停滞的（虽然定律快失效了）；进几年来的AI热正是算法的突破，即深度学习相关算法的突飞猛进；而算材就是用来训练模型的数据，未来几年AI应用的进一步落地离不开算材的进一步开发（中国在AI方面的最大优势正在于此）。数据集的丰富程度和有效程度直接影响了AI应用的效果，我将在下文详细说明。</p>
<p>在jetbot项目中，我们也能体验到用“人工”换“智能”的快乐。作为视觉识别类的AI应用，我们要在预设环境里创建数据集，并为其标注。有了数据集，jetbot搭载的NVIDIA牌GPU在方寸之间就能完成海量计算，仅用一颗摄像头就能实现自动避障，目标追踪，自动巡线等等炫酷功能！不要1999，也不要999，只要99！99刀NVIDIA计算卡带回家！（妮维雅打钱）</p>
<blockquote>
<p>给萌新理清几个概念：</p>
<p>人工智能，机器学习，深度学习的关系：</p>
<ul>
<li>深度学习：一种实现机器学习的技术；机器学习：一种实现人工智能的方法</li>
<li>【包含关系图】</li>
</ul>
<p>AI的发展路径：</p>
<ul>
<li>弱AI：单独领域工作效率超过人类→</li>
<li>通用AI：可以广泛应用于大部分领域→</li>
<li>强AI：有自主意识，即将灭绝人类（不是）→</li>
</ul>
<p>现在AI发展到什么地步了：弱AI，有生之年可能见到通用AI</p>
</blockquote>
<p>推荐一波汉化的很好的wiki，也有自己原创的内容：http://www.waveshare.net/wiki/JetBot_AI_Kit</p>
<p>本篇详细介绍两个demo的代码和可能遇到的问题，最后附上神经网络的入门笔记。同样是初次接触，大佬请绕道。</p>
<h3 id="demo1自动避障">demo1：自动避障</h3>
<p>小车如何实现自动避障的呢？用通俗的不能再通俗的说法，AI程序通过学习你给他的数据集，知道了什么样的图像是死路，什么样的图像是通路。得到新图像时就能判断是死路的概率有多少，在程序里可以很简单的看出，当这个概率大于0.5的时候就触发小车转向。</p>
<p>具体而言，你要在你的环境里拍至少200张照片，100张标记为通路（free），100张标记为死路（blocked）。这便是你的数据集（dataset）。构建数据集的时候尽量分散在环境的各个位置和各个方向，可以沿边界环绕一圈，走一段距离停下，转一圈，收集8-10张图片。反正你的数据越多，标记的越准确，模型效果越好。</p>
<p>下一步就开始训练模型了，从代码里看出，这个demo使用AlexNet模型，用pytorch实现（废话）。第一次运行你会下载一个244M左右的大文件，在<code>/home/jetbot/.torch/models</code>目录下会看到这个.pth文件。这便是AlexNet了。</p>
<p>继续运行程序，完整的输出结果有三十行，每行后面的小数代表当前模型的准确度（？），程序最后会从这30个模型中选取准确度最高的作为最终模型，也是一个pth文件：<code>best_model.pth</code></p>
<p>下载文件和训练模型都需要花挺长时间，看到kernel busy，也就是右上角的大黑点不要轻易打断。</p>
<p>什么是模型呢？稍微解释一下机器学习的概念。</p>
<p>模型就是函数，其要素为输入，输出，和变换关系。举例说明：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>细菌向养分移动</td>
<td>外界环境的化学信号</td>
<td>催动鞭毛的电信号</td>
</tr>
<tr>
<td>学生参加高考</td>
<td>试卷反射的光信号</td>
<td>试卷上问题的答案</td>
</tr>
<tr>
<td>小车自动避障</td>
<td>摄像头传输图像信号</td>
<td>前方被堵塞的概率</td>
</tr>
</tbody>
</table>
<p>实际上，知识的本质也是函数，生命延续的关键就在于该生命的模型是否适应环境。这里不深入解释了，觉得惊奇请参阅Yjango的频道https://space.bilibili.com/344849038他用机器学习的角度解释生物进化，非常颠覆三观。</p>
<p>总之训练出来的模型就是这样一个函数。其输入为经过处理的摄像头的图形信号，输出一个0-1的数，越接近1越意味着模型认为小车要撞墙了。但是当他大于0.5的时候就会触发转向，也就实现了自动避障。</p>
<blockquote>
<p>AlexNet是2012年提出的一种卷积神经网络（即CNN）算法。首次实现gpu加速。</p>
<p>主流深度学习框架：TensorFlow；PyTorch；Keras</p>
</blockquote>
<p>还挺好玩的😀</p>
<h3 id="demo2目标追踪">demo2：目标追踪</h3>
<p>基于上一个demo，我们还要下载一个模型，<a href="http://cocodataset.org/#home">coco数据集</a>神经网络，可以检测90种不同的物体。按教程把.engine文件下载到指定位置，顺着跑就完事了。（引入模型也要花挺长时间）</p>
<p>如果有数据集里的物品，从输出里能看到蓝框标出，小车会自动转向物体，同时还保留了自动避障的程序。</p>
<p>遇到bug：程序仅能读取一张图像进行识别，摄像头更新的功能无法执行。</p>
<h3 id="修bug摄像头问题">修bug：摄像头问题</h3>
<p>描述：摄像头只要调用了一次，后面就无法在其他地方调用。直接在jupyter上关闭输出并没有作用。而且只要在一个notebook里就能重复调用，换一个就不行。而且并没有报错信息，程序一直处在busy状态。</p>
<p>找到源码，在jetbot/jetbot/camera.py，但是所有样例里面调用摄像头都是用的Camera.instance()方法，而这个instance是在traitlets库里的，于是找到trailets官方文档</p>
<blockquote>
<p>Traitlets是一个纯 python 库，支持：</p>
<ul>
<li>对 python 对象属性的强类型实施( 类型属性称为 &quot;特征&quot; ) ；</li>
<li>动态计算的默认值；</li>
<li>当尝试改变时，自动验证和强制特征属性；</li>
<li>当特征值改变时注册接收通知；</li>
<li>从文件或者 命令行 参数中读取值- 在traitlets上不同层，因这里可以在没有配置机器的情况下使用 traitlets。</li>
</ul>
<p>Traitlets支持IPython和Jupyter的配置系统，以及IPython交互小部件的声明性 API。</p>
<p>ipython是一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。其中就包括traitlets库。</p>
</blockquote>
<p>https://traitlets.readthedocs.io/en/stable/config.html 在这里找到instance的功能：返回现有的类，如果没有就新建一个。</p>
<p>下面是样例中调用摄像头的代码：</p>
<pre><code class="language-python">import ipywidgets.widgets as widgets  #图像模块
from IPython.display import display   #ipy的显示模块
import traitlets                      
from jetbot import Camera, bgr8_to_jpeg #摄像头驱动，图像格式转换
camera = Camera.instance(width=500, height=500)#初始化摄像头对象
image = widgets.Image(format='jpeg', width=400, height=400)#创建图像
camera_link = traitlets.dlink((camera, 'value'), (image, 'value'), transform=bgr8_to_jpeg)     #连接摄像头到图像
display(image)  #显示图像
</code></pre>
<p>尝试从camera.py里调用原始api。得到报错：<code>Each object must be HasTraits, not &lt;class 'NoneType'&gt;</code>，是说必须为对象指定类型。那么HasTraits这个类型是啥？文档说:任何具有trait属性的类都必须从 <code>HasTraits</code> 继承。</p>
<p>再次梳理调用摄像头的流程：</p>
<ul>
<li>引入模型：<code>model.load_state_dict(torch.load('best_model.pth'))</code></li>
<li>连接摄像头：见上文</li>
<li>模型执行：</li>
</ul>
<pre><code class="language-python">def update():
	...#此处为模型执行函数，将输入图像预处理后，执行模型
update({'new': camera.value})  #初始化该函数
camera.observe(update, names='value')  #将update函数设为camera.value的observer
</code></pre>
<p>研究一下observe用法：当对象发生变化时调用函数。</p>
<p>https://traitlets.readthedocs.io/en/stable/using_traitlets.html#validation</p>
<p>执行如下代码：</p>
<pre><code class="language-python">import ipywidgets.widgets as widgets  #图像模块
from IPython.display import display   #ipy的显示模块
import traitlets                      
from jetbot import Camera, bgr8_to_jpeg #摄像头驱动，图像格式转换
camera = Camera.instance(width=500, height=500)#初始化摄像头对象
def update(change):
	x = change['new'] 
	display(x)  #显示图像
update({'new': camera.value})  
camera.observe(update, names='value') 
</code></pre>
<p>输出一大堆数组，说明camera.value是这一大堆像素。而且observe正常运行，数据一直冒出。</p>
<pre><code>array([[[122, 116, 130],
        [126, 113, 127],
        [125, 117, 129],
        ...,
        [ 84,  96, 107],
        [ 82,  96, 113],
        [ 93,  93, 113]],

       [[120, 119, 130],
        [122, 120, 119],
        [118, 123, 130],
        ...,
</code></pre>
<p>然而就是不实时更新数据，卒。</p>
<p>👴佛了。</p>
<h3 id="神经网络笔记">神经网络笔记</h3>
<h3 id="alexnetcnn">AlexNet——CNN</h3>
<p>2012年由Hinton学生Alex提出，是Lenet加宽版。其采用了一系列的新技术：成功的引用了relu、dropout和lrn等trick，首次采用gpu加速。其包含65万神经元，5个卷积层，三个后面带有池化层，最后用了三个全链接。</p>
]]></content>
    </entry>
</feed>